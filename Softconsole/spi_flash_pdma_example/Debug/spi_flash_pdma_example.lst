
spi_flash_pdma_example:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003240  20000000  20000000  00008000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000011c  20003240  20003240  0000b240  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000018bc  2000335c  2000335c  0000b35c  2**2
                  ALLOC
  3 .stack        00003000  20004c18  20004c18  0000b35c  2**0
                  ALLOC
  4 .comment      00000183  00000000  00000000  0000b35c  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000000e0  00000000  00000000  0000b4df  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000659  00000000  00000000  0000b5bf  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000050ec  00000000  00000000  0000bc18  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000a73  00000000  00000000  00010d04  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001aaa  00000000  00000000  00011777  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000a88  00000000  00000000  00013224  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001f73  00000000  00000000  00013cac  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000010e2  00000000  00000000  00015c1f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macinfo 00039453  00000000  00000000  00016d01  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .ARM.attributes 00000025  00000000  00000000  00050154  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

20000000 <__text_start>:
20000000:	20010000 	.word	0x20010000
20000004:	20000189 	.word	0x20000189
20000008:	200001f9 	.word	0x200001f9
2000000c:	200001fb 	.word	0x200001fb
20000010:	200001fd 	.word	0x200001fd
20000014:	200001ff 	.word	0x200001ff
20000018:	20000201 	.word	0x20000201
	...
2000002c:	20000203 	.word	0x20000203
20000030:	20000205 	.word	0x20000205
20000034:	00000000 	.word	0x00000000
20000038:	20000207 	.word	0x20000207
2000003c:	20000209 	.word	0x20000209
20000040:	2000020b 	.word	0x2000020b
20000044:	2000020d 	.word	0x2000020d
20000048:	20001fbd 	.word	0x20001fbd
2000004c:	20001fe1 	.word	0x20001fe1
20000050:	20000213 	.word	0x20000213
20000054:	20000215 	.word	0x20000215
20000058:	20000217 	.word	0x20000217
2000005c:	20000219 	.word	0x20000219
20000060:	2000021b 	.word	0x2000021b
20000064:	2000021d 	.word	0x2000021d
20000068:	2000021f 	.word	0x2000021f
2000006c:	20000221 	.word	0x20000221
20000070:	20000223 	.word	0x20000223
20000074:	20002749 	.word	0x20002749
20000078:	20000227 	.word	0x20000227
2000007c:	20000229 	.word	0x20000229
20000080:	2000022b 	.word	0x2000022b
20000084:	2000022d 	.word	0x2000022d
20000088:	2000022f 	.word	0x2000022f
2000008c:	20000231 	.word	0x20000231
20000090:	20000233 	.word	0x20000233
20000094:	20000235 	.word	0x20000235
20000098:	20000237 	.word	0x20000237
2000009c:	20000239 	.word	0x20000239
200000a0:	2000023b 	.word	0x2000023b
200000a4:	2000023d 	.word	0x2000023d
200000a8:	2000023f 	.word	0x2000023f
200000ac:	20000241 	.word	0x20000241
200000b0:	20000243 	.word	0x20000243
200000b4:	20000245 	.word	0x20000245
200000b8:	20000247 	.word	0x20000247
200000bc:	20000249 	.word	0x20000249
200000c0:	2000024b 	.word	0x2000024b
200000c4:	2000024d 	.word	0x2000024d
200000c8:	2000024f 	.word	0x2000024f
200000cc:	20000251 	.word	0x20000251
200000d0:	20000253 	.word	0x20000253
200000d4:	20000255 	.word	0x20000255
200000d8:	20000257 	.word	0x20000257
200000dc:	20000259 	.word	0x20000259
200000e0:	2000025b 	.word	0x2000025b
200000e4:	2000025d 	.word	0x2000025d
200000e8:	2000025f 	.word	0x2000025f
200000ec:	20000261 	.word	0x20000261
200000f0:	20000263 	.word	0x20000263
200000f4:	20000265 	.word	0x20000265
200000f8:	20000267 	.word	0x20000267
200000fc:	20000269 	.word	0x20000269
20000100:	2000026b 	.word	0x2000026b
20000104:	2000026d 	.word	0x2000026d
20000108:	2000026f 	.word	0x2000026f
2000010c:	20000271 	.word	0x20000271
20000110:	20000273 	.word	0x20000273
20000114:	20000275 	.word	0x20000275
20000118:	20000277 	.word	0x20000277
2000011c:	20000279 	.word	0x20000279
20000120:	2000027b 	.word	0x2000027b
20000124:	2000027d 	.word	0x2000027d
20000128:	2000027f 	.word	0x2000027f
2000012c:	20000281 	.word	0x20000281
20000130:	20000283 	.word	0x20000283
20000134:	20000285 	.word	0x20000285
20000138:	20000287 	.word	0x20000287
2000013c:	20000289 	.word	0x20000289
20000140:	2000028b 	.word	0x2000028b
20000144:	2000028d 	.word	0x2000028d
20000148:	2000028f 	.word	0x2000028f
2000014c:	20000291 	.word	0x20000291
20000150:	20000293 	.word	0x20000293
20000154:	20000295 	.word	0x20000295
20000158:	20000297 	.word	0x20000297
2000015c:	20000299 	.word	0x20000299
20000160:	2000029b 	.word	0x2000029b
20000164:	2000029d 	.word	0x2000029d
20000168:	2000029f 	.word	0x2000029f
2000016c:	200002a1 	.word	0x200002a1
20000170:	200002a3 	.word	0x200002a3
20000174:	200002a5 	.word	0x200002a5
20000178:	200002a7 	.word	0x200002a7
2000017c:	200002a9 	.word	0x200002a9
20000180:	200002ab 	.word	0x200002ab
20000184:	200002ad 	.word	0x200002ad

20000188 <Reset_Handler>:
20000188:	4849      	ldr	r0, [pc, #292]	; (200002b0 <mscc_post_hw_cfg_init+0x2>)
2000018a:	4780      	blx	r0
2000018c:	4849      	ldr	r0, [pc, #292]	; (200002b4 <mscc_post_hw_cfg_init+0x6>)
2000018e:	2800      	cmp	r0, #0
20000190:	d10b      	bne.n	200001aa <copy_data>
20000192:	4849      	ldr	r0, [pc, #292]	; (200002b8 <mscc_post_hw_cfg_init+0xa>)
20000194:	4949      	ldr	r1, [pc, #292]	; (200002bc <mscc_post_hw_cfg_init+0xe>)
20000196:	4a4a      	ldr	r2, [pc, #296]	; (200002c0 <mscc_post_hw_cfg_init+0x12>)
20000198:	4288      	cmp	r0, r1
2000019a:	d006      	beq.n	200001aa <copy_data>

2000019c <copy_code_loop>:
2000019c:	4291      	cmp	r1, r2
2000019e:	bf1c      	itt	ne
200001a0:	f850 3b04 	ldrne.w	r3, [r0], #4
200001a4:	f841 3b04 	strne.w	r3, [r1], #4
200001a8:	d1f8      	bne.n	2000019c <copy_code_loop>

200001aa <copy_data>:
200001aa:	4846      	ldr	r0, [pc, #280]	; (200002c4 <mscc_post_hw_cfg_init+0x16>)
200001ac:	4946      	ldr	r1, [pc, #280]	; (200002c8 <mscc_post_hw_cfg_init+0x1a>)
200001ae:	4a47      	ldr	r2, [pc, #284]	; (200002cc <mscc_post_hw_cfg_init+0x1e>)
200001b0:	4288      	cmp	r0, r1
200001b2:	d006      	beq.n	200001c2 <clear_bss>

200001b4 <copy_data_loop>:
200001b4:	4291      	cmp	r1, r2
200001b6:	bf1c      	itt	ne
200001b8:	f850 3b04 	ldrne.w	r3, [r0], #4
200001bc:	f841 3b04 	strne.w	r3, [r1], #4
200001c0:	d1f8      	bne.n	200001b4 <copy_data_loop>

200001c2 <clear_bss>:
200001c2:	4843      	ldr	r0, [pc, #268]	; (200002d0 <mscc_post_hw_cfg_init+0x22>)
200001c4:	4943      	ldr	r1, [pc, #268]	; (200002d4 <mscc_post_hw_cfg_init+0x26>)
200001c6:	4a44      	ldr	r2, [pc, #272]	; (200002d8 <mscc_post_hw_cfg_init+0x2a>)

200001c8 <clear_bss_loop>:
200001c8:	4291      	cmp	r1, r2
200001ca:	bf18      	it	ne
200001cc:	f841 0b04 	strne.w	r0, [r1], #4
200001d0:	d1fa      	bne.n	200001c8 <clear_bss_loop>
	...

200001e0 <call_glob_ctor>:
200001e0:	f8df 00f8 	ldr.w	r0, [pc, #248]	; 200002dc <mscc_post_hw_cfg_init+0x2e>
200001e4:	f20f 0e03 	addw	lr, pc, #3
200001e8:	4700      	bx	r0

200001ea <branch_to_main>:
200001ea:	f04f 0000 	mov.w	r0, #0
200001ee:	f04f 0100 	mov.w	r1, #0
200001f2:	f8df f0ec 	ldr.w	pc, [pc, #236]	; 200002e0 <mscc_post_hw_cfg_init+0x32>

200001f6 <ExitLoop>:
200001f6:	e7fe      	b.n	200001f6 <ExitLoop>

200001f8 <NMI_Handler>:
200001f8:	e7fe      	b.n	200001f8 <NMI_Handler>

200001fa <HardFault_Handler>:
200001fa:	e7fe      	b.n	200001fa <HardFault_Handler>

200001fc <MemManage_Handler>:
200001fc:	e7fe      	b.n	200001fc <MemManage_Handler>

200001fe <BusFault_Handler>:
200001fe:	e7fe      	b.n	200001fe <BusFault_Handler>

20000200 <UsageFault_Handler>:
20000200:	e7fe      	b.n	20000200 <UsageFault_Handler>

20000202 <SVC_Handler>:
20000202:	e7fe      	b.n	20000202 <SVC_Handler>

20000204 <DebugMon_Handler>:
20000204:	e7fe      	b.n	20000204 <DebugMon_Handler>

20000206 <PendSV_Handler>:
20000206:	e7fe      	b.n	20000206 <PendSV_Handler>

20000208 <SysTick_Handler>:
20000208:	e7fe      	b.n	20000208 <SysTick_Handler>

2000020a <WdogWakeup_IRQHandler>:
2000020a:	e7fe      	b.n	2000020a <WdogWakeup_IRQHandler>

2000020c <RTC_Wakeup_IRQHandler>:
2000020c:	e7fe      	b.n	2000020c <RTC_Wakeup_IRQHandler>
2000020e:	e7fe      	b.n	2000020e <RTC_Wakeup_IRQHandler+0x2>
20000210:	e7fe      	b.n	20000210 <RTC_Wakeup_IRQHandler+0x4>

20000212 <I2C0_IRQHandler>:
20000212:	e7fe      	b.n	20000212 <I2C0_IRQHandler>

20000214 <I2C0_SMBAlert_IRQHandler>:
20000214:	e7fe      	b.n	20000214 <I2C0_SMBAlert_IRQHandler>

20000216 <I2C0_SMBus_IRQHandler>:
20000216:	e7fe      	b.n	20000216 <I2C0_SMBus_IRQHandler>

20000218 <I2C1_IRQHandler>:
20000218:	e7fe      	b.n	20000218 <I2C1_IRQHandler>

2000021a <I2C1_SMBAlert_IRQHandler>:
2000021a:	e7fe      	b.n	2000021a <I2C1_SMBAlert_IRQHandler>

2000021c <I2C1_SMBus_IRQHandler>:
2000021c:	e7fe      	b.n	2000021c <I2C1_SMBus_IRQHandler>

2000021e <UART0_IRQHandler>:
2000021e:	e7fe      	b.n	2000021e <UART0_IRQHandler>

20000220 <UART1_IRQHandler>:
20000220:	e7fe      	b.n	20000220 <UART1_IRQHandler>

20000222 <EthernetMAC_IRQHandler>:
20000222:	e7fe      	b.n	20000222 <EthernetMAC_IRQHandler>
20000224:	e7fe      	b.n	20000224 <EthernetMAC_IRQHandler+0x2>

20000226 <Timer1_IRQHandler>:
20000226:	e7fe      	b.n	20000226 <Timer1_IRQHandler>

20000228 <Timer2_IRQHandler>:
20000228:	e7fe      	b.n	20000228 <Timer2_IRQHandler>

2000022a <CAN_IRQHandler>:
2000022a:	e7fe      	b.n	2000022a <CAN_IRQHandler>

2000022c <ENVM0_IRQHandler>:
2000022c:	e7fe      	b.n	2000022c <ENVM0_IRQHandler>

2000022e <ENVM1_IRQHandler>:
2000022e:	e7fe      	b.n	2000022e <ENVM1_IRQHandler>

20000230 <ComBlk_IRQHandler>:
20000230:	e7fe      	b.n	20000230 <ComBlk_IRQHandler>

20000232 <USB_IRQHandler>:
20000232:	e7fe      	b.n	20000232 <USB_IRQHandler>

20000234 <USB_DMA_IRQHandler>:
20000234:	e7fe      	b.n	20000234 <USB_DMA_IRQHandler>

20000236 <PLL_Lock_IRQHandler>:
20000236:	e7fe      	b.n	20000236 <PLL_Lock_IRQHandler>

20000238 <PLL_LockLost_IRQHandler>:
20000238:	e7fe      	b.n	20000238 <PLL_LockLost_IRQHandler>

2000023a <CommSwitchError_IRQHandler>:
2000023a:	e7fe      	b.n	2000023a <CommSwitchError_IRQHandler>

2000023c <CacheError_IRQHandler>:
2000023c:	e7fe      	b.n	2000023c <CacheError_IRQHandler>

2000023e <DDR_IRQHandler>:
2000023e:	e7fe      	b.n	2000023e <DDR_IRQHandler>

20000240 <HPDMA_Complete_IRQHandler>:
20000240:	e7fe      	b.n	20000240 <HPDMA_Complete_IRQHandler>

20000242 <HPDMA_Error_IRQHandler>:
20000242:	e7fe      	b.n	20000242 <HPDMA_Error_IRQHandler>

20000244 <ECC_Error_IRQHandler>:
20000244:	e7fe      	b.n	20000244 <ECC_Error_IRQHandler>

20000246 <MDDR_IOCalib_IRQHandler>:
20000246:	e7fe      	b.n	20000246 <MDDR_IOCalib_IRQHandler>

20000248 <FAB_PLL_Lock_IRQHandler>:
20000248:	e7fe      	b.n	20000248 <FAB_PLL_Lock_IRQHandler>

2000024a <FAB_PLL_LockLost_IRQHandler>:
2000024a:	e7fe      	b.n	2000024a <FAB_PLL_LockLost_IRQHandler>

2000024c <FIC64_IRQHandler>:
2000024c:	e7fe      	b.n	2000024c <FIC64_IRQHandler>

2000024e <FabricIrq0_IRQHandler>:
2000024e:	e7fe      	b.n	2000024e <FabricIrq0_IRQHandler>

20000250 <FabricIrq1_IRQHandler>:
20000250:	e7fe      	b.n	20000250 <FabricIrq1_IRQHandler>

20000252 <FabricIrq2_IRQHandler>:
20000252:	e7fe      	b.n	20000252 <FabricIrq2_IRQHandler>

20000254 <FabricIrq3_IRQHandler>:
20000254:	e7fe      	b.n	20000254 <FabricIrq3_IRQHandler>

20000256 <FabricIrq4_IRQHandler>:
20000256:	e7fe      	b.n	20000256 <FabricIrq4_IRQHandler>

20000258 <FabricIrq5_IRQHandler>:
20000258:	e7fe      	b.n	20000258 <FabricIrq5_IRQHandler>

2000025a <FabricIrq6_IRQHandler>:
2000025a:	e7fe      	b.n	2000025a <FabricIrq6_IRQHandler>

2000025c <FabricIrq7_IRQHandler>:
2000025c:	e7fe      	b.n	2000025c <FabricIrq7_IRQHandler>

2000025e <FabricIrq8_IRQHandler>:
2000025e:	e7fe      	b.n	2000025e <FabricIrq8_IRQHandler>

20000260 <FabricIrq9_IRQHandler>:
20000260:	e7fe      	b.n	20000260 <FabricIrq9_IRQHandler>

20000262 <FabricIrq10_IRQHandler>:
20000262:	e7fe      	b.n	20000262 <FabricIrq10_IRQHandler>

20000264 <FabricIrq11_IRQHandler>:
20000264:	e7fe      	b.n	20000264 <FabricIrq11_IRQHandler>

20000266 <FabricIrq12_IRQHandler>:
20000266:	e7fe      	b.n	20000266 <FabricIrq12_IRQHandler>

20000268 <FabricIrq13_IRQHandler>:
20000268:	e7fe      	b.n	20000268 <FabricIrq13_IRQHandler>

2000026a <FabricIrq14_IRQHandler>:
2000026a:	e7fe      	b.n	2000026a <FabricIrq14_IRQHandler>

2000026c <FabricIrq15_IRQHandler>:
2000026c:	e7fe      	b.n	2000026c <FabricIrq15_IRQHandler>

2000026e <GPIO0_IRQHandler>:
2000026e:	e7fe      	b.n	2000026e <GPIO0_IRQHandler>

20000270 <GPIO1_IRQHandler>:
20000270:	e7fe      	b.n	20000270 <GPIO1_IRQHandler>

20000272 <GPIO2_IRQHandler>:
20000272:	e7fe      	b.n	20000272 <GPIO2_IRQHandler>

20000274 <GPIO3_IRQHandler>:
20000274:	e7fe      	b.n	20000274 <GPIO3_IRQHandler>

20000276 <GPIO4_IRQHandler>:
20000276:	e7fe      	b.n	20000276 <GPIO4_IRQHandler>

20000278 <GPIO5_IRQHandler>:
20000278:	e7fe      	b.n	20000278 <GPIO5_IRQHandler>

2000027a <GPIO6_IRQHandler>:
2000027a:	e7fe      	b.n	2000027a <GPIO6_IRQHandler>

2000027c <GPIO7_IRQHandler>:
2000027c:	e7fe      	b.n	2000027c <GPIO7_IRQHandler>

2000027e <GPIO8_IRQHandler>:
2000027e:	e7fe      	b.n	2000027e <GPIO8_IRQHandler>

20000280 <GPIO9_IRQHandler>:
20000280:	e7fe      	b.n	20000280 <GPIO9_IRQHandler>

20000282 <GPIO10_IRQHandler>:
20000282:	e7fe      	b.n	20000282 <GPIO10_IRQHandler>

20000284 <GPIO11_IRQHandler>:
20000284:	e7fe      	b.n	20000284 <GPIO11_IRQHandler>

20000286 <GPIO12_IRQHandler>:
20000286:	e7fe      	b.n	20000286 <GPIO12_IRQHandler>

20000288 <GPIO13_IRQHandler>:
20000288:	e7fe      	b.n	20000288 <GPIO13_IRQHandler>

2000028a <GPIO14_IRQHandler>:
2000028a:	e7fe      	b.n	2000028a <GPIO14_IRQHandler>

2000028c <GPIO15_IRQHandler>:
2000028c:	e7fe      	b.n	2000028c <GPIO15_IRQHandler>

2000028e <GPIO16_IRQHandler>:
2000028e:	e7fe      	b.n	2000028e <GPIO16_IRQHandler>

20000290 <GPIO17_IRQHandler>:
20000290:	e7fe      	b.n	20000290 <GPIO17_IRQHandler>

20000292 <GPIO18_IRQHandler>:
20000292:	e7fe      	b.n	20000292 <GPIO18_IRQHandler>

20000294 <GPIO19_IRQHandler>:
20000294:	e7fe      	b.n	20000294 <GPIO19_IRQHandler>

20000296 <GPIO20_IRQHandler>:
20000296:	e7fe      	b.n	20000296 <GPIO20_IRQHandler>

20000298 <GPIO21_IRQHandler>:
20000298:	e7fe      	b.n	20000298 <GPIO21_IRQHandler>

2000029a <GPIO22_IRQHandler>:
2000029a:	e7fe      	b.n	2000029a <GPIO22_IRQHandler>

2000029c <GPIO23_IRQHandler>:
2000029c:	e7fe      	b.n	2000029c <GPIO23_IRQHandler>

2000029e <GPIO24_IRQHandler>:
2000029e:	e7fe      	b.n	2000029e <GPIO24_IRQHandler>

200002a0 <GPIO25_IRQHandler>:
200002a0:	e7fe      	b.n	200002a0 <GPIO25_IRQHandler>

200002a2 <GPIO26_IRQHandler>:
200002a2:	e7fe      	b.n	200002a2 <GPIO26_IRQHandler>

200002a4 <GPIO27_IRQHandler>:
200002a4:	e7fe      	b.n	200002a4 <GPIO27_IRQHandler>

200002a6 <GPIO28_IRQHandler>:
200002a6:	e7fe      	b.n	200002a6 <GPIO28_IRQHandler>

200002a8 <GPIO29_IRQHandler>:
200002a8:	e7fe      	b.n	200002a8 <GPIO29_IRQHandler>

200002aa <GPIO30_IRQHandler>:
200002aa:	e7fe      	b.n	200002aa <GPIO30_IRQHandler>

200002ac <GPIO31_IRQHandler>:
200002ac:	e7fe      	b.n	200002ac <GPIO31_IRQHandler>

200002ae <mscc_post_hw_cfg_init>:
200002ae:	4770      	bx	lr
200002b0:	200028f1 	.word	0x200028f1
200002b4:	00000000 	.word	0x00000000
200002b8:	20000000 	.word	0x20000000
200002bc:	20000000 	.word	0x20000000
200002c0:	20003240 	.word	0x20003240
200002c4:	20003240 	.word	0x20003240
200002c8:	20003240 	.word	0x20003240
200002cc:	2000335c 	.word	0x2000335c
200002d0:	00000000 	.word	0x00000000
200002d4:	2000335c 	.word	0x2000335c
200002d8:	20004c18 	.word	0x20004c18
200002dc:	20002e59 	.word	0x20002e59
200002e0:	20000321 	.word	0x20000321
	...

200002f0 <__do_global_dtors_aux>:
200002f0:	f243 335c 	movw	r3, #13148	; 0x335c
200002f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200002f8:	781a      	ldrb	r2, [r3, #0]
200002fa:	b90a      	cbnz	r2, 20000300 <__do_global_dtors_aux+0x10>
200002fc:	2001      	movs	r0, #1
200002fe:	7018      	strb	r0, [r3, #0]
20000300:	4770      	bx	lr
20000302:	bf00      	nop

20000304 <frame_dummy>:
20000304:	f243 2040 	movw	r0, #12864	; 0x3240
20000308:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000030c:	b508      	push	{r3, lr}
2000030e:	6803      	ldr	r3, [r0, #0]
20000310:	b12b      	cbz	r3, 2000031e <frame_dummy+0x1a>
20000312:	f240 0300 	movw	r3, #0
20000316:	f2c0 0300 	movt	r3, #0
2000031a:	b103      	cbz	r3, 2000031e <frame_dummy+0x1a>
2000031c:	4798      	blx	r3
2000031e:	bd08      	pop	{r3, pc}

20000320 <main>:

/***************************************************************************//**
 * main function.
 */
int main()
{
20000320:	b580      	push	{r7, lr}
20000322:	b084      	sub	sp, #16
20000324:	af00      	add	r7, sp, #0
    volatile uint32_t errors = 0;
20000326:	f04f 0300 	mov.w	r3, #0
2000032a:	607b      	str	r3, [r7, #4]
    uint32_t address = 0;
2000032c:	f04f 0300 	mov.w	r3, #0
20000330:	60bb      	str	r3, [r7, #8]
    uint16_t loop_count;
    uint8_t manufacturer_id = 0;
20000332:	f04f 0300 	mov.w	r3, #0
20000336:	70fb      	strb	r3, [r7, #3]
    uint8_t device_id = 0;
20000338:	f04f 0300 	mov.w	r3, #0
2000033c:	70bb      	strb	r3, [r7, #2]
    static uint8_t g_flash_wr_buf[BUFFER_A_SIZE];
    static uint8_t g_flash_rd_buf[BUFFER_A_SIZE];

    
    /* Disable Watchdog */
    SYSREG->WDOG_CR = 0x00000000;
2000033e:	f248 0300 	movw	r3, #32768	; 0x8000
20000342:	f2c4 0303 	movt	r3, #16387	; 0x4003
20000346:	f04f 0200 	mov.w	r2, #0
2000034a:	66da      	str	r2, [r3, #108]	; 0x6c

    /*--------------------------------------------------------------------------
     * Initialize the write and read Buffers
    */
    for(loop_count = 0; loop_count < (BUFFER_A_SIZE/2); loop_count++)
2000034c:	f04f 0300 	mov.w	r3, #0
20000350:	81fb      	strh	r3, [r7, #14]
20000352:	e016      	b.n	20000382 <main+0x62>
    {
        g_flash_wr_buf[loop_count] = 0x44 + loop_count;
20000354:	89fa      	ldrh	r2, [r7, #14]
20000356:	89fb      	ldrh	r3, [r7, #14]
20000358:	b2db      	uxtb	r3, r3
2000035a:	f103 0344 	add.w	r3, r3, #68	; 0x44
2000035e:	b2d9      	uxtb	r1, r3
20000360:	f243 3360 	movw	r3, #13152	; 0x3360
20000364:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000368:	5499      	strb	r1, [r3, r2]
        g_flash_rd_buf[loop_count] = 0x00;
2000036a:	89fa      	ldrh	r2, [r7, #14]
2000036c:	f643 7318 	movw	r3, #16152	; 0x3f18
20000370:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000374:	f04f 0100 	mov.w	r1, #0
20000378:	5499      	strb	r1, [r3, r2]
    SYSREG->WDOG_CR = 0x00000000;

    /*--------------------------------------------------------------------------
     * Initialize the write and read Buffers
    */
    for(loop_count = 0; loop_count < (BUFFER_A_SIZE/2); loop_count++)
2000037a:	89fb      	ldrh	r3, [r7, #14]
2000037c:	f103 0301 	add.w	r3, r3, #1
20000380:	81fb      	strh	r3, [r7, #14]
20000382:	89fa      	ldrh	r2, [r7, #14]
20000384:	f240 53db 	movw	r3, #1499	; 0x5db
20000388:	429a      	cmp	r2, r3
2000038a:	d9e3      	bls.n	20000354 <main+0x34>
    {
        g_flash_wr_buf[loop_count] = 0x44 + loop_count;
        g_flash_rd_buf[loop_count] = 0x00;
    }
    for(loop_count = (BUFFER_A_SIZE/2); loop_count < BUFFER_A_SIZE; loop_count++)
2000038c:	f240 53dc 	movw	r3, #1500	; 0x5dc
20000390:	81fb      	strh	r3, [r7, #14]
20000392:	e013      	b.n	200003bc <main+0x9c>
    {
        g_flash_wr_buf[loop_count] = 0x33;
20000394:	89fa      	ldrh	r2, [r7, #14]
20000396:	f243 3360 	movw	r3, #13152	; 0x3360
2000039a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000039e:	f04f 0133 	mov.w	r1, #51	; 0x33
200003a2:	5499      	strb	r1, [r3, r2]
        g_flash_rd_buf[loop_count] = 0x00;
200003a4:	89fa      	ldrh	r2, [r7, #14]
200003a6:	f643 7318 	movw	r3, #16152	; 0x3f18
200003aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200003ae:	f04f 0100 	mov.w	r1, #0
200003b2:	5499      	strb	r1, [r3, r2]
    for(loop_count = 0; loop_count < (BUFFER_A_SIZE/2); loop_count++)
    {
        g_flash_wr_buf[loop_count] = 0x44 + loop_count;
        g_flash_rd_buf[loop_count] = 0x00;
    }
    for(loop_count = (BUFFER_A_SIZE/2); loop_count < BUFFER_A_SIZE; loop_count++)
200003b4:	89fb      	ldrh	r3, [r7, #14]
200003b6:	f103 0301 	add.w	r3, r3, #1
200003ba:	81fb      	strh	r3, [r7, #14]
200003bc:	89fa      	ldrh	r2, [r7, #14]
200003be:	f640 33b7 	movw	r3, #2999	; 0xbb7
200003c2:	429a      	cmp	r2, r3
200003c4:	d9e6      	bls.n	20000394 <main+0x74>
    }

    /*--------------------------------------------------------------------------
     * Flash Driver Initialization
    */
    FLASH_init();
200003c6:	f000 f8cf 	bl	20000568 <FLASH_init>

    FLASH_global_unprotect();
200003ca:	f000 f999 	bl	20000700 <FLASH_global_unprotect>

    FLASH_erase_4k_block(0);
200003ce:	f04f 0000 	mov.w	r0, #0
200003d2:	f000 fa1f 	bl	20000814 <FLASH_erase_4k_block>

    /*--------------------------------------------------------------------------
     * Check SPI Flash part manufacturer and device ID.
    */
    FLASH_read_device_id_REMS(&manufacturer_id, &device_id);
200003d6:	f107 0203 	add.w	r2, r7, #3
200003da:	f107 0302 	add.w	r3, r7, #2
200003de:	4610      	mov	r0, r2
200003e0:	4619      	mov	r1, r3
200003e2:	f000 f911 	bl	20000608 <FLASH_read_device_id_REMS>
    if ((manufacturer_id != SPSN_ID2_25FL128S_64KB_MANUFACTURER_ID) || (device_id != SPSN_ID2_25FL128S_64KB_DEVICE_ID))
200003e6:	78fb      	ldrb	r3, [r7, #3]
200003e8:	2b01      	cmp	r3, #1
200003ea:	d102      	bne.n	200003f2 <main+0xd2>
200003ec:	78bb      	ldrb	r3, [r7, #2]
200003ee:	2b4d      	cmp	r3, #77	; 0x4d
200003f0:	d003      	beq.n	200003fa <main+0xda>
    {
        ++errors;
200003f2:	687b      	ldr	r3, [r7, #4]
200003f4:	f103 0301 	add.w	r3, r3, #1
200003f8:	607b      	str	r3, [r7, #4]
    }

    FLASH_read_device_id(&manufacturer_id, &device_id);
200003fa:	f107 0203 	add.w	r2, r7, #3
200003fe:	f107 0302 	add.w	r3, r7, #2
20000402:	4610      	mov	r0, r2
20000404:	4619      	mov	r1, r3
20000406:	f000 f8c9 	bl	2000059c <FLASH_read_device_id>
        if ((manufacturer_id != SPSN_ID2_25FL128S_64KB_MANUFACTURER_ID) || (device_id != SPSN_ID2_25FL128S_64KB_DEVICE_ID))
2000040a:	78fb      	ldrb	r3, [r7, #3]
2000040c:	2b01      	cmp	r3, #1
2000040e:	d102      	bne.n	20000416 <main+0xf6>
20000410:	78bb      	ldrb	r3, [r7, #2]
20000412:	2b4d      	cmp	r3, #77	; 0x4d
20000414:	d003      	beq.n	2000041e <main+0xfe>
        {
            ++errors;
20000416:	687b      	ldr	r3, [r7, #4]
20000418:	f103 0301 	add.w	r3, r3, #1
2000041c:	607b      	str	r3, [r7, #4]
        }
    /*--------------------------------------------------------------------------
     * Write Data to Flash.
    */
    address = 200;
2000041e:	f04f 03c8 	mov.w	r3, #200	; 0xc8
20000422:	60bb      	str	r3, [r7, #8]
    FLASH_program(address, g_flash_wr_buf, sizeof(g_flash_wr_buf));
20000424:	68b8      	ldr	r0, [r7, #8]
20000426:	f243 3160 	movw	r1, #13152	; 0x3360
2000042a:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000042e:	f640 32b8 	movw	r2, #3000	; 0xbb8
20000432:	f000 fac1 	bl	200009b8 <FLASH_program>

    /*--------------------------------------------------------------------------
     * Read Data From Flash.
    */
    address = 200;
20000436:	f04f 03c8 	mov.w	r3, #200	; 0xc8
2000043a:	60bb      	str	r3, [r7, #8]
    FLASH_read(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));
2000043c:	68b8      	ldr	r0, [r7, #8]
2000043e:	f643 7118 	movw	r1, #16152	; 0x3f18
20000442:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000446:	f640 32b8 	movw	r2, #3000	; 0xbb8
2000044a:	f000 f91b 	bl	20000684 <FLASH_read>

    while(1)
    {
        ;
    }
2000044e:	e7fe      	b.n	2000044e <main+0x12e>

20000450 <NVIC_init>:

/***************************************************************************//**
 * 
 */
void NVIC_init( void )
{
20000450:	b480      	push	{r7}
20000452:	af00      	add	r7, sp, #0
     * Hardware Abstraction Layer. The use of the Actel HAL NVIC control
     * functions is obsolete on SmartFusion2 devices.
     *
     * Simply remove the call to NVIC_init() from your application code.
     */
    ASSERT(0);
20000454:	be00      	bkpt	0x0000
}
20000456:	46bd      	mov	sp, r7
20000458:	bc80      	pop	{r7}
2000045a:	4770      	bx	lr

2000045c <NVIC_set_handler>:
void NVIC_set_handler
(
    uint32_t interrupt_number,
    hal_nvic_irq_handler_t handler
)
{
2000045c:	b480      	push	{r7}
2000045e:	b083      	sub	sp, #12
20000460:	af00      	add	r7, sp, #0
20000462:	6078      	str	r0, [r7, #4]
20000464:	6039      	str	r1, [r7, #0]
     *      - void FabricIrq15_IRQHandler(void)
     * The function to implement depends on which MSS_INT_F2M[n] signal is used
     * in your Libero design to connect the interrupt signal of the peripheral
     * generating the interrupt.
     */
    ASSERT(0);
20000466:	be00      	bkpt	0x0000
}
20000468:	f107 070c 	add.w	r7, r7, #12
2000046c:	46bd      	mov	sp, r7
2000046e:	bc80      	pop	{r7}
20000470:	4770      	bx	lr
20000472:	bf00      	nop

20000474 <NVIC_set_priority>:
void NVIC_set_priority
(
    uint32_t interrupt_number,
    uint8_t priority_level
)
{
20000474:	b480      	push	{r7}
20000476:	b083      	sub	sp, #12
20000478:	af00      	add	r7, sp, #0
2000047a:	6078      	str	r0, [r7, #4]
2000047c:	460b      	mov	r3, r1
2000047e:	70fb      	strb	r3, [r7, #3]
     *      - FabricIrq12_IRQn
     *      - FabricIrq13_IRQn
     *      - FabricIrq14_IRQn
     *      - FabricIrq15_IRQn
     */
    ASSERT(0);
20000480:	be00      	bkpt	0x0000
}
20000482:	f107 070c 	add.w	r7, r7, #12
20000486:	46bd      	mov	sp, r7
20000488:	bc80      	pop	{r7}
2000048a:	4770      	bx	lr

2000048c <NVIC_enable_interrupt>:

/***************************************************************************//**
 * 
 */
void NVIC_enable_interrupt( uint32_t interrupt_number )
{
2000048c:	b480      	push	{r7}
2000048e:	b083      	sub	sp, #12
20000490:	af00      	add	r7, sp, #0
20000492:	6078      	str	r0, [r7, #4]
     *      - FabricIrq12_IRQn
     *      - FabricIrq13_IRQn
     *      - FabricIrq14_IRQn
     *      - FabricIrq15_IRQn
     */
    ASSERT(0);
20000494:	be00      	bkpt	0x0000
}
20000496:	f107 070c 	add.w	r7, r7, #12
2000049a:	46bd      	mov	sp, r7
2000049c:	bc80      	pop	{r7}
2000049e:	4770      	bx	lr

200004a0 <NVIC_disable_interrupt>:

/***************************************************************************//**
 * 
 */
void NVIC_disable_interrupt( uint32_t interrupt_number )
{
200004a0:	b480      	push	{r7}
200004a2:	b083      	sub	sp, #12
200004a4:	af00      	add	r7, sp, #0
200004a6:	6078      	str	r0, [r7, #4]
     *      - FabricIrq12_IRQn
     *      - FabricIrq13_IRQn
     *      - FabricIrq14_IRQn
     *      - FabricIrq15_IRQn
     */
    ASSERT(0);
200004a8:	be00      	bkpt	0x0000
}
200004aa:	f107 070c 	add.w	r7, r7, #12
200004ae:	46bd      	mov	sp, r7
200004b0:	bc80      	pop	{r7}
200004b2:	4770      	bx	lr

200004b4 <NVIC_clear_interrupt>:

/***************************************************************************//**
 * 
 */
void NVIC_clear_interrupt( uint32_t interrupt_number )
{
200004b4:	b480      	push	{r7}
200004b6:	b083      	sub	sp, #12
200004b8:	af00      	add	r7, sp, #0
200004ba:	6078      	str	r0, [r7, #4]
     *      - FabricIrq12_IRQn
     *      - FabricIrq13_IRQn
     *      - FabricIrq14_IRQn
     *      - FabricIrq15_IRQn
     */
    ASSERT(0);
200004bc:	be00      	bkpt	0x0000
}
200004be:	f107 070c 	add.w	r7, r7, #12
200004c2:	46bd      	mov	sp, r7
200004c4:	bc80      	pop	{r7}
200004c6:	4770      	bx	lr

200004c8 <HAL_disable_interrupts>:
200004c8:	f3ef 8010 	mrs	r0, PRIMASK
200004cc:	b672      	cpsid	i
200004ce:	4770      	bx	lr

200004d0 <HAL_restore_interrupts>:
200004d0:	f380 8810 	msr	PRIMASK, r0
200004d4:	4770      	bx	lr

200004d6 <HW_set_32bit_reg>:
200004d6:	6001      	str	r1, [r0, #0]
200004d8:	4770      	bx	lr

200004da <HW_get_32bit_reg>:
200004da:	6800      	ldr	r0, [r0, #0]
200004dc:	4770      	bx	lr

200004de <HW_set_32bit_reg_field>:
200004de:	b50e      	push	{r1, r2, r3, lr}
200004e0:	fa03 f301 	lsl.w	r3, r3, r1
200004e4:	ea03 0302 	and.w	r3, r3, r2
200004e8:	6801      	ldr	r1, [r0, #0]
200004ea:	ea6f 0202 	mvn.w	r2, r2
200004ee:	ea01 0102 	and.w	r1, r1, r2
200004f2:	ea41 0103 	orr.w	r1, r1, r3
200004f6:	6001      	str	r1, [r0, #0]
200004f8:	bd0e      	pop	{r1, r2, r3, pc}

200004fa <HW_get_32bit_reg_field>:
200004fa:	6800      	ldr	r0, [r0, #0]
200004fc:	ea00 0002 	and.w	r0, r0, r2
20000500:	fa20 f001 	lsr.w	r0, r0, r1
20000504:	4770      	bx	lr

20000506 <HW_set_16bit_reg>:
20000506:	8001      	strh	r1, [r0, #0]
20000508:	4770      	bx	lr

2000050a <HW_get_16bit_reg>:
2000050a:	8800      	ldrh	r0, [r0, #0]
2000050c:	4770      	bx	lr

2000050e <HW_set_16bit_reg_field>:
2000050e:	b50e      	push	{r1, r2, r3, lr}
20000510:	fa03 f301 	lsl.w	r3, r3, r1
20000514:	ea03 0302 	and.w	r3, r3, r2
20000518:	8801      	ldrh	r1, [r0, #0]
2000051a:	ea6f 0202 	mvn.w	r2, r2
2000051e:	ea01 0102 	and.w	r1, r1, r2
20000522:	ea41 0103 	orr.w	r1, r1, r3
20000526:	8001      	strh	r1, [r0, #0]
20000528:	bd0e      	pop	{r1, r2, r3, pc}

2000052a <HW_get_16bit_reg_field>:
2000052a:	8800      	ldrh	r0, [r0, #0]
2000052c:	ea00 0002 	and.w	r0, r0, r2
20000530:	fa20 f001 	lsr.w	r0, r0, r1
20000534:	4770      	bx	lr

20000536 <HW_set_8bit_reg>:
20000536:	7001      	strb	r1, [r0, #0]
20000538:	4770      	bx	lr

2000053a <HW_get_8bit_reg>:
2000053a:	7800      	ldrb	r0, [r0, #0]
2000053c:	4770      	bx	lr

2000053e <HW_set_8bit_reg_field>:
2000053e:	b50e      	push	{r1, r2, r3, lr}
20000540:	fa03 f301 	lsl.w	r3, r3, r1
20000544:	ea03 0302 	and.w	r3, r3, r2
20000548:	7801      	ldrb	r1, [r0, #0]
2000054a:	ea6f 0202 	mvn.w	r2, r2
2000054e:	ea01 0102 	and.w	r1, r1, r2
20000552:	ea41 0103 	orr.w	r1, r1, r3
20000556:	7001      	strb	r1, [r0, #0]
20000558:	bd0e      	pop	{r1, r2, r3, pc}

2000055a <HW_get_8bit_reg_field>:
2000055a:	7800      	ldrb	r0, [r0, #0]
2000055c:	ea00 0002 	and.w	r0, r0, r2
20000560:	fa20 f001 	lsr.w	r0, r0, r1
20000564:	4770      	bx	lr
	...

20000568 <FLASH_init>:

/*******************************************************************************
 *
 */
void FLASH_init( void )
{
20000568:	b580      	push	{r7, lr}
2000056a:	b082      	sub	sp, #8
2000056c:	af02      	add	r7, sp, #8
    /*--------------------------------------------------------------------------
     * Configure SPI.
     */
    MSS_SPI_init( &g_mss_spi0 );
2000056e:	f644 3094 	movw	r0, #19348	; 0x4b94
20000572:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000576:	f000 fb41 	bl	20000bfc <MSS_SPI_init>
    
    MSS_SPI_configure_master_mode
2000057a:	f04f 0308 	mov.w	r3, #8
2000057e:	9300      	str	r3, [sp, #0]
20000580:	f644 3094 	movw	r0, #19348	; 0x4b94
20000584:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000588:	f04f 0100 	mov.w	r1, #0
2000058c:	f04f 7240 	mov.w	r2, #50331648	; 0x3000000
20000590:	f04f 0308 	mov.w	r3, #8
20000594:	f000 fce4 	bl	20000f60 <MSS_SPI_configure_master_mode>
            PDMA_TO_SPI_1,
            PDMA_LOW_PRIORITY | PDMA_BYTE_TRANSFER | PDMA_INC_SRC_ONE_BYTE,
            PDMA_DEFAULT_WRITE_ADJ
        );
*/
}
20000598:	46bd      	mov	sp, r7
2000059a:	bd80      	pop	{r7, pc}

2000059c <FLASH_read_device_id>:
 void FLASH_read_device_id
(
    uint8_t * manufacturer_id,
    uint8_t * device_id
)
{
2000059c:	b580      	push	{r7, lr}
2000059e:	b088      	sub	sp, #32
200005a0:	af02      	add	r7, sp, #8
200005a2:	6078      	str	r0, [r7, #4]
200005a4:	6039      	str	r1, [r7, #0]
	uint8_t cmd[4];
    uint8_t read_device_id_cmd = DEVICE_ID_READ;
200005a6:	f06f 0360 	mvn.w	r3, #96	; 0x60
200005aa:	75fb      	strb	r3, [r7, #23]
    uint8_t read_buffer[3];
    
    cmd[0] = DEVICE_ID_READ;
200005ac:	f06f 0360 	mvn.w	r3, #96	; 0x60
200005b0:	743b      	strb	r3, [r7, #16]


    MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
200005b2:	f644 3094 	movw	r0, #19348	; 0x4b94
200005b6:	f2c2 0000 	movt	r0, #8192	; 0x2000
200005ba:	f04f 0100 	mov.w	r1, #0
200005be:	f000 fd77 	bl	200010b0 <MSS_SPI_set_slave_select>
    
    /* Spansion Read ID cod command ahs only 1 Byte command word, returns 3 byte Data */
    MSS_SPI_transfer_block( &g_mss_spi0, &cmd, 1, read_buffer, sizeof(read_buffer) );
200005c2:	f107 0210 	add.w	r2, r7, #16
200005c6:	f107 030c 	add.w	r3, r7, #12
200005ca:	f04f 0103 	mov.w	r1, #3
200005ce:	9100      	str	r1, [sp, #0]
200005d0:	f644 3094 	movw	r0, #19348	; 0x4b94
200005d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200005d8:	4611      	mov	r1, r2
200005da:	f04f 0201 	mov.w	r2, #1
200005de:	f000 fe93 	bl	20001308 <MSS_SPI_transfer_block>

    MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
200005e2:	f644 3094 	movw	r0, #19348	; 0x4b94
200005e6:	f2c2 0000 	movt	r0, #8192	; 0x2000
200005ea:	f04f 0100 	mov.w	r1, #0
200005ee:	f000 fde3 	bl	200011b8 <MSS_SPI_clear_slave_select>

    *manufacturer_id = read_buffer[0];
200005f2:	7b3a      	ldrb	r2, [r7, #12]
200005f4:	687b      	ldr	r3, [r7, #4]
200005f6:	701a      	strb	r2, [r3, #0]
    *device_id       = read_buffer[1];
200005f8:	7b7a      	ldrb	r2, [r7, #13]
200005fa:	683b      	ldr	r3, [r7, #0]
200005fc:	701a      	strb	r2, [r3, #0]
}
200005fe:	f107 0718 	add.w	r7, r7, #24
20000602:	46bd      	mov	sp, r7
20000604:	bd80      	pop	{r7, pc}
20000606:	bf00      	nop

20000608 <FLASH_read_device_id_REMS>:
  void FLASH_read_device_id_REMS
 (
     uint8_t * manufacturer_id,
     uint8_t * device_id
 )
 {
20000608:	b580      	push	{r7, lr}
2000060a:	b088      	sub	sp, #32
2000060c:	af02      	add	r7, sp, #8
2000060e:	6078      	str	r0, [r7, #4]
20000610:	6039      	str	r1, [r7, #0]
 	uint8_t cmd[4];
     uint8_t read_device_id_cmd = 90;
20000612:	f04f 035a 	mov.w	r3, #90	; 0x5a
20000616:	75fb      	strb	r3, [r7, #23]
     uint8_t read_buffer[2];

     cmd[0] = DEVICE_ID_READ;
20000618:	f06f 0360 	mvn.w	r3, #96	; 0x60
2000061c:	743b      	strb	r3, [r7, #16]
     cmd[1] = 0x00;
2000061e:	f04f 0300 	mov.w	r3, #0
20000622:	747b      	strb	r3, [r7, #17]
     cmd[2] = 0x00;
20000624:	f04f 0300 	mov.w	r3, #0
20000628:	74bb      	strb	r3, [r7, #18]
     cmd[3] = 0x00;
2000062a:	f04f 0300 	mov.w	r3, #0
2000062e:	74fb      	strb	r3, [r7, #19]




     MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
20000630:	f644 3094 	movw	r0, #19348	; 0x4b94
20000634:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000638:	f04f 0100 	mov.w	r1, #0
2000063c:	f000 fd38 	bl	200010b0 <MSS_SPI_set_slave_select>

     /* Spansion Read ID cod command ahs only 1 Byte command word, returns 3 byte Data */
     MSS_SPI_transfer_block( &g_mss_spi0, &cmd, 4, read_buffer, sizeof(read_buffer) );
20000640:	f107 0210 	add.w	r2, r7, #16
20000644:	f107 030c 	add.w	r3, r7, #12
20000648:	f04f 0102 	mov.w	r1, #2
2000064c:	9100      	str	r1, [sp, #0]
2000064e:	f644 3094 	movw	r0, #19348	; 0x4b94
20000652:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000656:	4611      	mov	r1, r2
20000658:	f04f 0204 	mov.w	r2, #4
2000065c:	f000 fe54 	bl	20001308 <MSS_SPI_transfer_block>

     MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
20000660:	f644 3094 	movw	r0, #19348	; 0x4b94
20000664:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000668:	f04f 0100 	mov.w	r1, #0
2000066c:	f000 fda4 	bl	200011b8 <MSS_SPI_clear_slave_select>

     *manufacturer_id = read_buffer[0];
20000670:	7b3a      	ldrb	r2, [r7, #12]
20000672:	687b      	ldr	r3, [r7, #4]
20000674:	701a      	strb	r2, [r3, #0]
     *device_id       = read_buffer[1];
20000676:	7b7a      	ldrb	r2, [r7, #13]
20000678:	683b      	ldr	r3, [r7, #0]
2000067a:	701a      	strb	r2, [r3, #0]
 }
2000067c:	f107 0718 	add.w	r7, r7, #24
20000680:	46bd      	mov	sp, r7
20000682:	bd80      	pop	{r7, pc}

20000684 <FLASH_read>:
(
    uint32_t address,
    uint8_t * rx_buffer,
    size_t size_in_bytes
)
{
20000684:	b580      	push	{r7, lr}
20000686:	b088      	sub	sp, #32
20000688:	af02      	add	r7, sp, #8
2000068a:	60f8      	str	r0, [r7, #12]
2000068c:	60b9      	str	r1, [r7, #8]
2000068e:	607a      	str	r2, [r7, #4]
    uint8_t cmd_buffer[4];
    

    /* Spansion Read array command :   {cmd, addr24,addr16,addr8 } = total 4 bytes */
    cmd_buffer[0] = READ_ARRAY_OPCODE;
20000690:	f04f 0303 	mov.w	r3, #3
20000694:	753b      	strb	r3, [r7, #20]
    cmd_buffer[1] = (uint8_t)((address >> 16) & 0xFF);
20000696:	68fb      	ldr	r3, [r7, #12]
20000698:	ea4f 4313 	mov.w	r3, r3, lsr #16
2000069c:	b2db      	uxtb	r3, r3
2000069e:	757b      	strb	r3, [r7, #21]
    cmd_buffer[2] = (uint8_t)((address >> 8) & 0xFF);;
200006a0:	68fb      	ldr	r3, [r7, #12]
200006a2:	ea4f 2313 	mov.w	r3, r3, lsr #8
200006a6:	b2db      	uxtb	r3, r3
200006a8:	75bb      	strb	r3, [r7, #22]
    cmd_buffer[3] = (uint8_t)(address & 0xFF);
200006aa:	68fb      	ldr	r3, [r7, #12]
200006ac:	b2db      	uxtb	r3, r3
200006ae:	75fb      	strb	r3, [r7, #23]

    MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
200006b0:	f644 3094 	movw	r0, #19348	; 0x4b94
200006b4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200006b8:	f04f 0100 	mov.w	r1, #0
200006bc:	f000 fcf8 	bl	200010b0 <MSS_SPI_set_slave_select>
    wait_ready();
200006c0:	f000 fa22 	bl	20000b08 <wait_ready>
    MSS_SPI_transfer_block( &g_mss_spi0, cmd_buffer, 4, rx_buffer, size_in_bytes );
200006c4:	687b      	ldr	r3, [r7, #4]
200006c6:	b29a      	uxth	r2, r3
200006c8:	f107 0314 	add.w	r3, r7, #20
200006cc:	9200      	str	r2, [sp, #0]
200006ce:	f644 3094 	movw	r0, #19348	; 0x4b94
200006d2:	f2c2 0000 	movt	r0, #8192	; 0x2000
200006d6:	4619      	mov	r1, r3
200006d8:	f04f 0204 	mov.w	r2, #4
200006dc:	68bb      	ldr	r3, [r7, #8]
200006de:	f000 fe13 	bl	20001308 <MSS_SPI_transfer_block>
    wait_ready();
200006e2:	f000 fa11 	bl	20000b08 <wait_ready>
    MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
200006e6:	f644 3094 	movw	r0, #19348	; 0x4b94
200006ea:	f2c2 0000 	movt	r0, #8192	; 0x2000
200006ee:	f04f 0100 	mov.w	r1, #0
200006f2:	f000 fd61 	bl	200011b8 <MSS_SPI_clear_slave_select>
}
200006f6:	f107 0718 	add.w	r7, r7, #24
200006fa:	46bd      	mov	sp, r7
200006fc:	bd80      	pop	{r7, pc}
200006fe:	bf00      	nop

20000700 <FLASH_global_unprotect>:

/*******************************************************************************
 *
 */
void FLASH_global_unprotect( void )
{
20000700:	b580      	push	{r7, lr}
20000702:	b084      	sub	sp, #16
20000704:	af02      	add	r7, sp, #8
    uint8_t cmd_buffer[2];
    /* Send Write Enable command */
    cmd_buffer[0] = WRITE_ENABLE_CMD;
20000706:	f04f 0306 	mov.w	r3, #6
2000070a:	713b      	strb	r3, [r7, #4]

    MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
2000070c:	f644 3094 	movw	r0, #19348	; 0x4b94
20000710:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000714:	f04f 0100 	mov.w	r1, #0
20000718:	f000 fcca 	bl	200010b0 <MSS_SPI_set_slave_select>
    wait_ready();
2000071c:	f000 f9f4 	bl	20000b08 <wait_ready>
    MSS_SPI_transfer_block( &g_mss_spi0, cmd_buffer, 1, 0, 0 );
20000720:	f107 0304 	add.w	r3, r7, #4
20000724:	f04f 0200 	mov.w	r2, #0
20000728:	9200      	str	r2, [sp, #0]
2000072a:	f644 3094 	movw	r0, #19348	; 0x4b94
2000072e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000732:	4619      	mov	r1, r3
20000734:	f04f 0201 	mov.w	r2, #1
20000738:	f04f 0300 	mov.w	r3, #0
2000073c:	f000 fde4 	bl	20001308 <MSS_SPI_transfer_block>
    

    cmd_buffer[0] = WRITE_STATUS1_OPCODE;
20000740:	f04f 0301 	mov.w	r3, #1
20000744:	713b      	strb	r3, [r7, #4]
    cmd_buffer[1] = 0;
20000746:	f04f 0300 	mov.w	r3, #0
2000074a:	717b      	strb	r3, [r7, #5]
    
    wait_ready();
2000074c:	f000 f9dc 	bl	20000b08 <wait_ready>
    MSS_SPI_transfer_block( &g_mss_spi0, cmd_buffer, 2, 0, 0 );
20000750:	f107 0304 	add.w	r3, r7, #4
20000754:	f04f 0200 	mov.w	r2, #0
20000758:	9200      	str	r2, [sp, #0]
2000075a:	f644 3094 	movw	r0, #19348	; 0x4b94
2000075e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000762:	4619      	mov	r1, r3
20000764:	f04f 0202 	mov.w	r2, #2
20000768:	f04f 0300 	mov.w	r3, #0
2000076c:	f000 fdcc 	bl	20001308 <MSS_SPI_transfer_block>
    wait_ready();
20000770:	f000 f9ca 	bl	20000b08 <wait_ready>
    MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
20000774:	f644 3094 	movw	r0, #19348	; 0x4b94
20000778:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000077c:	f04f 0100 	mov.w	r1, #0
20000780:	f000 fd1a 	bl	200011b8 <MSS_SPI_clear_slave_select>
}
20000784:	f107 0708 	add.w	r7, r7, #8
20000788:	46bd      	mov	sp, r7
2000078a:	bd80      	pop	{r7, pc}

2000078c <FLASH_chip_erase>:

/*******************************************************************************
 *
 */
void FLASH_chip_erase( void )
{
2000078c:	b580      	push	{r7, lr}
2000078e:	b084      	sub	sp, #16
20000790:	af02      	add	r7, sp, #8
    uint8_t cmd_buffer;
    /* Send Write Enable command */
    cmd_buffer = WRITE_ENABLE_CMD;
20000792:	f04f 0306 	mov.w	r3, #6
20000796:	71fb      	strb	r3, [r7, #7]

    MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
20000798:	f644 3094 	movw	r0, #19348	; 0x4b94
2000079c:	f2c2 0000 	movt	r0, #8192	; 0x2000
200007a0:	f04f 0100 	mov.w	r1, #0
200007a4:	f000 fc84 	bl	200010b0 <MSS_SPI_set_slave_select>
    wait_ready();
200007a8:	f000 f9ae 	bl	20000b08 <wait_ready>
    MSS_SPI_transfer_block( &g_mss_spi0, &cmd_buffer, 1, 0, 0 );
200007ac:	f107 0307 	add.w	r3, r7, #7
200007b0:	f04f 0200 	mov.w	r2, #0
200007b4:	9200      	str	r2, [sp, #0]
200007b6:	f644 3094 	movw	r0, #19348	; 0x4b94
200007ba:	f2c2 0000 	movt	r0, #8192	; 0x2000
200007be:	4619      	mov	r1, r3
200007c0:	f04f 0201 	mov.w	r2, #1
200007c4:	f04f 0300 	mov.w	r3, #0
200007c8:	f000 fd9e 	bl	20001308 <MSS_SPI_transfer_block>
    
    /* Send Chip Erase command */
    cmd_buffer = CHIP_ERASE_OPCODE;
200007cc:	f06f 0338 	mvn.w	r3, #56	; 0x38
200007d0:	71fb      	strb	r3, [r7, #7]
    
    wait_ready();
200007d2:	f000 f999 	bl	20000b08 <wait_ready>
    MSS_SPI_transfer_block( &g_mss_spi0, &cmd_buffer, 1, 0, 0 );
200007d6:	f107 0307 	add.w	r3, r7, #7
200007da:	f04f 0200 	mov.w	r2, #0
200007de:	9200      	str	r2, [sp, #0]
200007e0:	f644 3094 	movw	r0, #19348	; 0x4b94
200007e4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200007e8:	4619      	mov	r1, r3
200007ea:	f04f 0201 	mov.w	r2, #1
200007ee:	f04f 0300 	mov.w	r3, #0
200007f2:	f000 fd89 	bl	20001308 <MSS_SPI_transfer_block>
    wait_ready();
200007f6:	f000 f987 	bl	20000b08 <wait_ready>
    MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
200007fa:	f644 3094 	movw	r0, #19348	; 0x4b94
200007fe:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000802:	f04f 0100 	mov.w	r1, #0
20000806:	f000 fcd7 	bl	200011b8 <MSS_SPI_clear_slave_select>
}
2000080a:	f107 0708 	add.w	r7, r7, #8
2000080e:	46bd      	mov	sp, r7
20000810:	bd80      	pop	{r7, pc}
20000812:	bf00      	nop

20000814 <FLASH_erase_4k_block>:
 */
void FLASH_erase_4k_block
(
    uint32_t address
)
{
20000814:	b580      	push	{r7, lr}
20000816:	b086      	sub	sp, #24
20000818:	af02      	add	r7, sp, #8
2000081a:	6078      	str	r0, [r7, #4]
    uint8_t cmd_buffer[4];
    /* Send Write Enable command */
    cmd_buffer[0] = WRITE_ENABLE_CMD;
2000081c:	f04f 0306 	mov.w	r3, #6
20000820:	733b      	strb	r3, [r7, #12]

    MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
20000822:	f644 3094 	movw	r0, #19348	; 0x4b94
20000826:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000082a:	f04f 0100 	mov.w	r1, #0
2000082e:	f000 fc3f 	bl	200010b0 <MSS_SPI_set_slave_select>
    wait_ready();
20000832:	f000 f969 	bl	20000b08 <wait_ready>
    MSS_SPI_transfer_block( &g_mss_spi0, cmd_buffer, 1, 0, 0 );
20000836:	f107 030c 	add.w	r3, r7, #12
2000083a:	f04f 0200 	mov.w	r2, #0
2000083e:	9200      	str	r2, [sp, #0]
20000840:	f644 3094 	movw	r0, #19348	; 0x4b94
20000844:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000848:	4619      	mov	r1, r3
2000084a:	f04f 0201 	mov.w	r2, #1
2000084e:	f04f 0300 	mov.w	r3, #0
20000852:	f000 fd59 	bl	20001308 <MSS_SPI_transfer_block>
    
    /* Send Chip Erase command */
    cmd_buffer[0] = ERASE_4K_BLOCK_OPCODE;
20000856:	f06f 0327 	mvn.w	r3, #39	; 0x27
2000085a:	733b      	strb	r3, [r7, #12]
    cmd_buffer[1] = (address >> 16) & 0xFF;
2000085c:	687b      	ldr	r3, [r7, #4]
2000085e:	ea4f 4313 	mov.w	r3, r3, lsr #16
20000862:	b2db      	uxtb	r3, r3
20000864:	737b      	strb	r3, [r7, #13]
    cmd_buffer[2] = (address >> 8 ) & 0xFF;
20000866:	687b      	ldr	r3, [r7, #4]
20000868:	ea4f 2313 	mov.w	r3, r3, lsr #8
2000086c:	b2db      	uxtb	r3, r3
2000086e:	73bb      	strb	r3, [r7, #14]
    cmd_buffer[3] = address & 0xFF;
20000870:	687b      	ldr	r3, [r7, #4]
20000872:	b2db      	uxtb	r3, r3
20000874:	73fb      	strb	r3, [r7, #15]
    
    wait_ready();
20000876:	f000 f947 	bl	20000b08 <wait_ready>
    MSS_SPI_transfer_block( &g_mss_spi0, cmd_buffer, sizeof(cmd_buffer), 0, 0 );
2000087a:	f107 030c 	add.w	r3, r7, #12
2000087e:	f04f 0200 	mov.w	r2, #0
20000882:	9200      	str	r2, [sp, #0]
20000884:	f644 3094 	movw	r0, #19348	; 0x4b94
20000888:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000088c:	4619      	mov	r1, r3
2000088e:	f04f 0204 	mov.w	r2, #4
20000892:	f04f 0300 	mov.w	r3, #0
20000896:	f000 fd37 	bl	20001308 <MSS_SPI_transfer_block>
    wait_ready();
2000089a:	f000 f935 	bl	20000b08 <wait_ready>
    MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
2000089e:	f644 3094 	movw	r0, #19348	; 0x4b94
200008a2:	f2c2 0000 	movt	r0, #8192	; 0x2000
200008a6:	f04f 0100 	mov.w	r1, #0
200008aa:	f000 fc85 	bl	200011b8 <MSS_SPI_clear_slave_select>
}
200008ae:	f107 0710 	add.w	r7, r7, #16
200008b2:	46bd      	mov	sp, r7
200008b4:	bd80      	pop	{r7, pc}
200008b6:	bf00      	nop

200008b8 <write_cmd_data>:
    const uint8_t * cmd_buffer,
    uint16_t cmd_byte_size,
    uint8_t * data_buffer,
    uint16_t data_byte_size
)
{
200008b8:	b580      	push	{r7, lr}
200008ba:	f5ad 7d08 	sub.w	sp, sp, #544	; 0x220
200008be:	af02      	add	r7, sp, #8
200008c0:	f107 0c0c 	add.w	ip, r7, #12
200008c4:	f8cc 0000 	str.w	r0, [ip]
200008c8:	f107 0008 	add.w	r0, r7, #8
200008cc:	6001      	str	r1, [r0, #0]
200008ce:	4639      	mov	r1, r7
200008d0:	600b      	str	r3, [r1, #0]
200008d2:	f107 0308 	add.w	r3, r7, #8
200008d6:	f1a3 0302 	sub.w	r3, r3, #2
200008da:	801a      	strh	r2, [r3, #0]
    MSS_SPI_enable( this_spi );
#else

    uint8_t tx_buffer[516];
    uint16_t transfer_size;
    uint16_t idx = 0;
200008dc:	f04f 0300 	mov.w	r3, #0
200008e0:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
    
    transfer_size = cmd_byte_size + data_byte_size;
200008e4:	f107 0308 	add.w	r3, r7, #8
200008e8:	f1a3 0302 	sub.w	r3, r3, #2
200008ec:	881a      	ldrh	r2, [r3, #0]
200008ee:	f8b7 3220 	ldrh.w	r3, [r7, #544]	; 0x220
200008f2:	4413      	add	r3, r2
200008f4:	f8a7 3214 	strh.w	r3, [r7, #532]	; 0x214
    
    for(idx = 0; idx < cmd_byte_size; ++idx)
200008f8:	f04f 0300 	mov.w	r3, #0
200008fc:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
20000900:	e011      	b.n	20000926 <write_cmd_data+0x6e>
    {
        tx_buffer[idx] = cmd_buffer[idx];
20000902:	f8b7 3216 	ldrh.w	r3, [r7, #534]	; 0x216
20000906:	f8b7 1216 	ldrh.w	r1, [r7, #534]	; 0x216
2000090a:	f107 0208 	add.w	r2, r7, #8
2000090e:	6812      	ldr	r2, [r2, #0]
20000910:	440a      	add	r2, r1
20000912:	7811      	ldrb	r1, [r2, #0]
20000914:	f107 0210 	add.w	r2, r7, #16
20000918:	54d1      	strb	r1, [r2, r3]
    uint16_t transfer_size;
    uint16_t idx = 0;
    
    transfer_size = cmd_byte_size + data_byte_size;
    
    for(idx = 0; idx < cmd_byte_size; ++idx)
2000091a:	f8b7 3216 	ldrh.w	r3, [r7, #534]	; 0x216
2000091e:	f103 0301 	add.w	r3, r3, #1
20000922:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
20000926:	f107 0308 	add.w	r3, r7, #8
2000092a:	f1a3 0302 	sub.w	r3, r3, #2
2000092e:	f8b7 2216 	ldrh.w	r2, [r7, #534]	; 0x216
20000932:	881b      	ldrh	r3, [r3, #0]
20000934:	429a      	cmp	r2, r3
20000936:	d3e4      	bcc.n	20000902 <write_cmd_data+0x4a>
    {
        tx_buffer[idx] = cmd_buffer[idx];
    }

    for(idx = 0; idx < data_byte_size; ++idx)
20000938:	f04f 0300 	mov.w	r3, #0
2000093c:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
20000940:	e016      	b.n	20000970 <write_cmd_data+0xb8>
    {
        tx_buffer[cmd_byte_size + idx] = data_buffer[idx];
20000942:	f107 0308 	add.w	r3, r7, #8
20000946:	f1a3 0302 	sub.w	r3, r3, #2
2000094a:	881a      	ldrh	r2, [r3, #0]
2000094c:	f8b7 3216 	ldrh.w	r3, [r7, #534]	; 0x216
20000950:	4413      	add	r3, r2
20000952:	f8b7 1216 	ldrh.w	r1, [r7, #534]	; 0x216
20000956:	463a      	mov	r2, r7
20000958:	6812      	ldr	r2, [r2, #0]
2000095a:	440a      	add	r2, r1
2000095c:	7811      	ldrb	r1, [r2, #0]
2000095e:	f107 0210 	add.w	r2, r7, #16
20000962:	54d1      	strb	r1, [r2, r3]
    for(idx = 0; idx < cmd_byte_size; ++idx)
    {
        tx_buffer[idx] = cmd_buffer[idx];
    }

    for(idx = 0; idx < data_byte_size; ++idx)
20000964:	f8b7 3216 	ldrh.w	r3, [r7, #534]	; 0x216
20000968:	f103 0301 	add.w	r3, r3, #1
2000096c:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
20000970:	f8b7 2216 	ldrh.w	r2, [r7, #534]	; 0x216
20000974:	f8b7 3220 	ldrh.w	r3, [r7, #544]	; 0x220
20000978:	429a      	cmp	r2, r3
2000097a:	d3e2      	bcc.n	20000942 <write_cmd_data+0x8a>
    {
        tx_buffer[cmd_byte_size + idx] = data_buffer[idx];
    }
    
    MSS_SPI_transfer_block( &g_mss_spi0, tx_buffer, transfer_size, 0, 0 );
2000097c:	f107 0210 	add.w	r2, r7, #16
20000980:	f8b7 3214 	ldrh.w	r3, [r7, #532]	; 0x214
20000984:	f04f 0100 	mov.w	r1, #0
20000988:	9100      	str	r1, [sp, #0]
2000098a:	f644 3094 	movw	r0, #19348	; 0x4b94
2000098e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000992:	4611      	mov	r1, r2
20000994:	461a      	mov	r2, r3
20000996:	f04f 0300 	mov.w	r3, #0
2000099a:	f000 fcb5 	bl	20001308 <MSS_SPI_transfer_block>
    
#endif    
    while ( !MSS_SPI_tx_done(this_spi) )
2000099e:	f107 030c 	add.w	r3, r7, #12
200009a2:	6818      	ldr	r0, [r3, #0]
200009a4:	f001 f8da 	bl	20001b5c <MSS_SPI_tx_done>
200009a8:	4603      	mov	r3, r0
200009aa:	2b00      	cmp	r3, #0
200009ac:	d0f7      	beq.n	2000099e <write_cmd_data+0xe6>
    {
        ;
    }
}
200009ae:	f507 7706 	add.w	r7, r7, #536	; 0x218
200009b2:	46bd      	mov	sp, r7
200009b4:	bd80      	pop	{r7, pc}
200009b6:	bf00      	nop

200009b8 <FLASH_program>:
(
    uint32_t address,
    uint8_t * write_buffer,
    size_t size_in_bytes
)
{
200009b8:	b580      	push	{r7, lr}
200009ba:	b08c      	sub	sp, #48	; 0x30
200009bc:	af02      	add	r7, sp, #8
200009be:	60f8      	str	r0, [r7, #12]
200009c0:	60b9      	str	r1, [r7, #8]
200009c2:	607a      	str	r2, [r7, #4]
    
    uint32_t in_buffer_idx;
    uint32_t nb_bytes_to_write;
    uint32_t target_addr;

    MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
200009c4:	f644 3094 	movw	r0, #19348	; 0x4b94
200009c8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200009cc:	f04f 0100 	mov.w	r1, #0
200009d0:	f000 fb6e 	bl	200010b0 <MSS_SPI_set_slave_select>
    

    /**/
    in_buffer_idx = 0;
200009d4:	f04f 0300 	mov.w	r3, #0
200009d8:	61bb      	str	r3, [r7, #24]
    nb_bytes_to_write = size_in_bytes;
200009da:	687b      	ldr	r3, [r7, #4]
200009dc:	61fb      	str	r3, [r7, #28]
    target_addr = address;
200009de:	68fb      	ldr	r3, [r7, #12]
200009e0:	623b      	str	r3, [r7, #32]
    
    while ( in_buffer_idx < size_in_bytes )
200009e2:	e050      	b.n	20000a86 <FLASH_program+0xce>
    {
        uint32_t size_left;
        nb_bytes_to_write = 0x100 - (target_addr & 0xFF);   /* adjust max possible size to page boundary. */
200009e4:	6a3b      	ldr	r3, [r7, #32]
200009e6:	f003 03ff 	and.w	r3, r3, #255	; 0xff
200009ea:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
200009ee:	61fb      	str	r3, [r7, #28]
        size_left = size_in_bytes - in_buffer_idx;
200009f0:	687a      	ldr	r2, [r7, #4]
200009f2:	69bb      	ldr	r3, [r7, #24]
200009f4:	ebc3 0302 	rsb	r3, r3, r2
200009f8:	627b      	str	r3, [r7, #36]	; 0x24
        if ( size_left < nb_bytes_to_write )
200009fa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
200009fc:	69fb      	ldr	r3, [r7, #28]
200009fe:	429a      	cmp	r2, r3
20000a00:	d201      	bcs.n	20000a06 <FLASH_program+0x4e>
        {
            nb_bytes_to_write = size_left;
20000a02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20000a04:	61fb      	str	r3, [r7, #28]
        }
        
        wait_ready();
20000a06:	f000 f87f 	bl	20000b08 <wait_ready>
        
        /* Send Write Enable command */
        cmd_buffer[0] = WRITE_ENABLE_CMD;
20000a0a:	f04f 0306 	mov.w	r3, #6
20000a0e:	753b      	strb	r3, [r7, #20]
        MSS_SPI_transfer_block( &g_mss_spi0, cmd_buffer, 1, 0, 0 );
20000a10:	f107 0314 	add.w	r3, r7, #20
20000a14:	f04f 0200 	mov.w	r2, #0
20000a18:	9200      	str	r2, [sp, #0]
20000a1a:	f644 3094 	movw	r0, #19348	; 0x4b94
20000a1e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000a22:	4619      	mov	r1, r3
20000a24:	f04f 0201 	mov.w	r2, #1
20000a28:	f04f 0300 	mov.w	r3, #0
20000a2c:	f000 fc6c 	bl	20001308 <MSS_SPI_transfer_block>
            
        /* Program page */
        wait_ready();
20000a30:	f000 f86a 	bl	20000b08 <wait_ready>
    
        cmd_buffer[0] = PROGRAM_PAGE_CMD;
20000a34:	f04f 0302 	mov.w	r3, #2
20000a38:	753b      	strb	r3, [r7, #20]
        cmd_buffer[1] = (target_addr >> 16) & 0xFF;
20000a3a:	6a3b      	ldr	r3, [r7, #32]
20000a3c:	ea4f 4313 	mov.w	r3, r3, lsr #16
20000a40:	b2db      	uxtb	r3, r3
20000a42:	757b      	strb	r3, [r7, #21]
        cmd_buffer[2] = (target_addr >> 8 ) & 0xFF;
20000a44:	6a3b      	ldr	r3, [r7, #32]
20000a46:	ea4f 2313 	mov.w	r3, r3, lsr #8
20000a4a:	b2db      	uxtb	r3, r3
20000a4c:	75bb      	strb	r3, [r7, #22]
        cmd_buffer[3] = target_addr & 0xFF;
20000a4e:	6a3b      	ldr	r3, [r7, #32]
20000a50:	b2db      	uxtb	r3, r3
20000a52:	75fb      	strb	r3, [r7, #23]
        
        write_cmd_data
20000a54:	68ba      	ldr	r2, [r7, #8]
20000a56:	69bb      	ldr	r3, [r7, #24]
20000a58:	4413      	add	r3, r2
20000a5a:	69fa      	ldr	r2, [r7, #28]
20000a5c:	b291      	uxth	r1, r2
20000a5e:	f107 0214 	add.w	r2, r7, #20
20000a62:	9100      	str	r1, [sp, #0]
20000a64:	f644 3094 	movw	r0, #19348	; 0x4b94
20000a68:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000a6c:	4611      	mov	r1, r2
20000a6e:	f04f 0204 	mov.w	r2, #4
20000a72:	f7ff ff21 	bl	200008b8 <write_cmd_data>
            sizeof(cmd_buffer),
            &write_buffer[in_buffer_idx],
            nb_bytes_to_write
          );
        
        target_addr += nb_bytes_to_write;
20000a76:	6a3a      	ldr	r2, [r7, #32]
20000a78:	69fb      	ldr	r3, [r7, #28]
20000a7a:	4413      	add	r3, r2
20000a7c:	623b      	str	r3, [r7, #32]
        in_buffer_idx += nb_bytes_to_write;
20000a7e:	69ba      	ldr	r2, [r7, #24]
20000a80:	69fb      	ldr	r3, [r7, #28]
20000a82:	4413      	add	r3, r2
20000a84:	61bb      	str	r3, [r7, #24]
    /**/
    in_buffer_idx = 0;
    nb_bytes_to_write = size_in_bytes;
    target_addr = address;
    
    while ( in_buffer_idx < size_in_bytes )
20000a86:	69ba      	ldr	r2, [r7, #24]
20000a88:	687b      	ldr	r3, [r7, #4]
20000a8a:	429a      	cmp	r2, r3
20000a8c:	d3aa      	bcc.n	200009e4 <FLASH_program+0x2c>
        target_addr += nb_bytes_to_write;
        in_buffer_idx += nb_bytes_to_write;
    }
    
    /* Send Write Disable command. */
    cmd_buffer[0] = WRITE_DISABLE_CMD;
20000a8e:	f04f 0304 	mov.w	r3, #4
20000a92:	753b      	strb	r3, [r7, #20]

    wait_ready();
20000a94:	f000 f838 	bl	20000b08 <wait_ready>

    MSS_SPI_transfer_block( &g_mss_spi0, cmd_buffer, 1, 0, 0 );
20000a98:	f107 0314 	add.w	r3, r7, #20
20000a9c:	f04f 0200 	mov.w	r2, #0
20000aa0:	9200      	str	r2, [sp, #0]
20000aa2:	f644 3094 	movw	r0, #19348	; 0x4b94
20000aa6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000aaa:	4619      	mov	r1, r3
20000aac:	f04f 0201 	mov.w	r2, #1
20000ab0:	f04f 0300 	mov.w	r3, #0
20000ab4:	f000 fc28 	bl	20001308 <MSS_SPI_transfer_block>
    MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
20000ab8:	f644 3094 	movw	r0, #19348	; 0x4b94
20000abc:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000ac0:	f04f 0100 	mov.w	r1, #0
20000ac4:	f000 fb78 	bl	200011b8 <MSS_SPI_clear_slave_select>
}
20000ac8:	f107 0728 	add.w	r7, r7, #40	; 0x28
20000acc:	46bd      	mov	sp, r7
20000ace:	bd80      	pop	{r7, pc}

20000ad0 <FLASH_get_status>:

/*******************************************************************************
 *
 */
uint8_t FLASH_get_status( void )
{
20000ad0:	b580      	push	{r7, lr}
20000ad2:	b084      	sub	sp, #16
20000ad4:	af02      	add	r7, sp, #8
    uint8_t status;
    uint8_t command = READ_STATUS;
20000ad6:	f04f 0305 	mov.w	r3, #5
20000ada:	71bb      	strb	r3, [r7, #6]
    
    MSS_SPI_transfer_block( &g_mss_spi0, &command, sizeof(uint8_t), &status, sizeof(status) );
20000adc:	f107 0206 	add.w	r2, r7, #6
20000ae0:	f107 0307 	add.w	r3, r7, #7
20000ae4:	f04f 0101 	mov.w	r1, #1
20000ae8:	9100      	str	r1, [sp, #0]
20000aea:	f644 3094 	movw	r0, #19348	; 0x4b94
20000aee:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000af2:	4611      	mov	r1, r2
20000af4:	f04f 0201 	mov.w	r2, #1
20000af8:	f000 fc06 	bl	20001308 <MSS_SPI_transfer_block>
    
    return status;
20000afc:	79fb      	ldrb	r3, [r7, #7]
}
20000afe:	4618      	mov	r0, r3
20000b00:	f107 0708 	add.w	r7, r7, #8
20000b04:	46bd      	mov	sp, r7
20000b06:	bd80      	pop	{r7, pc}

20000b08 <wait_ready>:

/*******************************************************************************
 *
 */
static void wait_ready( void )
{
20000b08:	b580      	push	{r7, lr}
20000b0a:	b084      	sub	sp, #16
20000b0c:	af02      	add	r7, sp, #8
    uint8_t ready_bit;
    uint8_t command = READ_STATUS;
20000b0e:	f04f 0305 	mov.w	r3, #5
20000b12:	71bb      	strb	r3, [r7, #6]
    
    do {
        MSS_SPI_transfer_block( &g_mss_spi0, &command, sizeof(command), &ready_bit, sizeof(ready_bit) );
20000b14:	f107 0206 	add.w	r2, r7, #6
20000b18:	f107 0307 	add.w	r3, r7, #7
20000b1c:	f04f 0101 	mov.w	r1, #1
20000b20:	9100      	str	r1, [sp, #0]
20000b22:	f644 3094 	movw	r0, #19348	; 0x4b94
20000b26:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000b2a:	4611      	mov	r1, r2
20000b2c:	f04f 0201 	mov.w	r2, #1
20000b30:	f000 fbea 	bl	20001308 <MSS_SPI_transfer_block>
        ready_bit = ready_bit & READY_BIT_MASK;
20000b34:	79fb      	ldrb	r3, [r7, #7]
20000b36:	f003 0301 	and.w	r3, r3, #1
20000b3a:	71fb      	strb	r3, [r7, #7]
    } while( ready_bit == 1 );
20000b3c:	79fb      	ldrb	r3, [r7, #7]
20000b3e:	2b01      	cmp	r3, #1
20000b40:	d0e8      	beq.n	20000b14 <wait_ready+0xc>
}
20000b42:	f107 0708 	add.w	r7, r7, #8
20000b46:	46bd      	mov	sp, r7
20000b48:	bd80      	pop	{r7, pc}
20000b4a:	bf00      	nop

20000b4c <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20000b4c:	b480      	push	{r7}
20000b4e:	b083      	sub	sp, #12
20000b50:	af00      	add	r7, sp, #0
20000b52:	4603      	mov	r3, r0
20000b54:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
20000b56:	f24e 1300 	movw	r3, #57600	; 0xe100
20000b5a:	f2ce 0300 	movt	r3, #57344	; 0xe000
20000b5e:	f997 2007 	ldrsb.w	r2, [r7, #7]
20000b62:	ea4f 1252 	mov.w	r2, r2, lsr #5
20000b66:	79f9      	ldrb	r1, [r7, #7]
20000b68:	f001 011f 	and.w	r1, r1, #31
20000b6c:	f04f 0001 	mov.w	r0, #1
20000b70:	fa00 f101 	lsl.w	r1, r0, r1
20000b74:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20000b78:	f107 070c 	add.w	r7, r7, #12
20000b7c:	46bd      	mov	sp, r7
20000b7e:	bc80      	pop	{r7}
20000b80:	4770      	bx	lr
20000b82:	bf00      	nop

20000b84 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
20000b84:	b480      	push	{r7}
20000b86:	b083      	sub	sp, #12
20000b88:	af00      	add	r7, sp, #0
20000b8a:	4603      	mov	r3, r0
20000b8c:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
20000b8e:	f24e 1300 	movw	r3, #57600	; 0xe100
20000b92:	f2ce 0300 	movt	r3, #57344	; 0xe000
20000b96:	f997 2007 	ldrsb.w	r2, [r7, #7]
20000b9a:	ea4f 1252 	mov.w	r2, r2, lsr #5
20000b9e:	79f9      	ldrb	r1, [r7, #7]
20000ba0:	f001 011f 	and.w	r1, r1, #31
20000ba4:	f04f 0001 	mov.w	r0, #1
20000ba8:	fa00 f101 	lsl.w	r1, r0, r1
20000bac:	f102 0220 	add.w	r2, r2, #32
20000bb0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20000bb4:	f107 070c 	add.w	r7, r7, #12
20000bb8:	46bd      	mov	sp, r7
20000bba:	bc80      	pop	{r7}
20000bbc:	4770      	bx	lr
20000bbe:	bf00      	nop

20000bc0 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
20000bc0:	b480      	push	{r7}
20000bc2:	b083      	sub	sp, #12
20000bc4:	af00      	add	r7, sp, #0
20000bc6:	4603      	mov	r3, r0
20000bc8:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
20000bca:	f24e 1300 	movw	r3, #57600	; 0xe100
20000bce:	f2ce 0300 	movt	r3, #57344	; 0xe000
20000bd2:	f997 2007 	ldrsb.w	r2, [r7, #7]
20000bd6:	ea4f 1252 	mov.w	r2, r2, lsr #5
20000bda:	79f9      	ldrb	r1, [r7, #7]
20000bdc:	f001 011f 	and.w	r1, r1, #31
20000be0:	f04f 0001 	mov.w	r0, #1
20000be4:	fa00 f101 	lsl.w	r1, r0, r1
20000be8:	f102 0260 	add.w	r2, r2, #96	; 0x60
20000bec:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20000bf0:	f107 070c 	add.w	r7, r7, #12
20000bf4:	46bd      	mov	sp, r7
20000bf6:	bc80      	pop	{r7}
20000bf8:	4770      	bx	lr
20000bfa:	bf00      	nop

20000bfc <MSS_SPI_init>:
 */
void MSS_SPI_init
(
    mss_spi_instance_t * this_spi
)
{
20000bfc:	b580      	push	{r7, lr}
20000bfe:	b084      	sub	sp, #16
20000c00:	af00      	add	r7, sp, #0
20000c02:	6078      	str	r0, [r7, #4]
    uint16_t slave;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20000c04:	687a      	ldr	r2, [r7, #4]
20000c06:	f644 3394 	movw	r3, #19348	; 0x4b94
20000c0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c0e:	429a      	cmp	r2, r3
20000c10:	d007      	beq.n	20000c22 <MSS_SPI_init+0x26>
20000c12:	687a      	ldr	r2, [r7, #4]
20000c14:	f644 3310 	movw	r3, #19216	; 0x4b10
20000c18:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c1c:	429a      	cmp	r2, r3
20000c1e:	d000      	beq.n	20000c22 <MSS_SPI_init+0x26>
20000c20:	be00      	bkpt	0x0000
     * Initialize SPI driver instance data. Relies on the majority
     * of data requiring 0 for initial state so we just need to fill
     * with 0s and finish off with a small number of non zero values.
     */
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20000c22:	687b      	ldr	r3, [r7, #4]
20000c24:	791b      	ldrb	r3, [r3, #4]
20000c26:	b25b      	sxtb	r3, r3
20000c28:	4618      	mov	r0, r3
20000c2a:	f7ff ffab 	bl	20000b84 <NVIC_DisableIRQ>

    memset(this_spi, 0, sizeof(mss_spi_instance_t));
20000c2e:	6878      	ldr	r0, [r7, #4]
20000c30:	f04f 0100 	mov.w	r1, #0
20000c34:	f04f 0284 	mov.w	r2, #132	; 0x84
20000c38:	f002 f9fe 	bl	20003038 <memset>
    
    this_spi->cmd_done = 1u;
20000c3c:	687b      	ldr	r3, [r7, #4]
20000c3e:	f04f 0201 	mov.w	r2, #1
20000c42:	625a      	str	r2, [r3, #36]	; 0x24

    for(slave = 0u; slave < (uint16_t)MSS_SPI_MAX_NB_OF_SLAVES; ++slave)
20000c44:	f04f 0300 	mov.w	r3, #0
20000c48:	81fb      	strh	r3, [r7, #14]
20000c4a:	e00d      	b.n	20000c68 <MSS_SPI_init+0x6c>
    {
        this_spi->slaves_cfg[slave].ctrl_reg = NOT_CONFIGURED;
20000c4c:	89fb      	ldrh	r3, [r7, #14]
20000c4e:	687a      	ldr	r2, [r7, #4]
20000c50:	f103 0306 	add.w	r3, r3, #6
20000c54:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20000c58:	4413      	add	r3, r2
20000c5a:	f04f 32ff 	mov.w	r2, #4294967295
20000c5e:	605a      	str	r2, [r3, #4]

    memset(this_spi, 0, sizeof(mss_spi_instance_t));
    
    this_spi->cmd_done = 1u;

    for(slave = 0u; slave < (uint16_t)MSS_SPI_MAX_NB_OF_SLAVES; ++slave)
20000c60:	89fb      	ldrh	r3, [r7, #14]
20000c62:	f103 0301 	add.w	r3, r3, #1
20000c66:	81fb      	strh	r3, [r7, #14]
20000c68:	89fb      	ldrh	r3, [r7, #14]
20000c6a:	2b07      	cmp	r3, #7
20000c6c:	d9ee      	bls.n	20000c4c <MSS_SPI_init+0x50>
    {
        this_spi->slaves_cfg[slave].ctrl_reg = NOT_CONFIGURED;
    }

    if(this_spi == &g_mss_spi0)
20000c6e:	687a      	ldr	r2, [r7, #4]
20000c70:	f644 3394 	movw	r3, #19348	; 0x4b94
20000c74:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c78:	429a      	cmp	r2, r3
20000c7a:	d126      	bne.n	20000cca <MSS_SPI_init+0xce>
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI0_BASE);
20000c7c:	687a      	ldr	r2, [r7, #4]
20000c7e:	f241 0300 	movw	r3, #4096	; 0x1000
20000c82:	f2c4 0300 	movt	r3, #16384	; 0x4000
20000c86:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI0_IRQn;
20000c88:	687b      	ldr	r3, [r7, #4]
20000c8a:	f04f 0202 	mov.w	r2, #2
20000c8e:	711a      	strb	r2, [r3, #4]

        /* reset SPI0 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI0_SOFTRESET_MASK;
20000c90:	f248 0300 	movw	r3, #32768	; 0x8000
20000c94:	f2c4 0303 	movt	r3, #16387	; 0x4003
20000c98:	f248 0200 	movw	r2, #32768	; 0x8000
20000c9c:	f2c4 0203 	movt	r2, #16387	; 0x4003
20000ca0:	6c92      	ldr	r2, [r2, #72]	; 0x48
20000ca2:	f442 7200 	orr.w	r2, r2, #512	; 0x200
20000ca6:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI0 interrupt */
        NVIC_ClearPendingIRQ(SPI0_IRQn);
20000ca8:	f04f 0002 	mov.w	r0, #2
20000cac:	f7ff ff88 	bl	20000bc0 <NVIC_ClearPendingIRQ>
        /* Take SPI0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI0_SOFTRESET_MASK;
20000cb0:	f248 0300 	movw	r3, #32768	; 0x8000
20000cb4:	f2c4 0303 	movt	r3, #16387	; 0x4003
20000cb8:	f248 0200 	movw	r2, #32768	; 0x8000
20000cbc:	f2c4 0203 	movt	r2, #16387	; 0x4003
20000cc0:	6c92      	ldr	r2, [r2, #72]	; 0x48
20000cc2:	f422 7200 	bic.w	r2, r2, #512	; 0x200
20000cc6:	649a      	str	r2, [r3, #72]	; 0x48
20000cc8:	e025      	b.n	20000d16 <MSS_SPI_init+0x11a>
    }
    else
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI1_BASE);
20000cca:	687a      	ldr	r2, [r7, #4]
20000ccc:	f241 0300 	movw	r3, #4096	; 0x1000
20000cd0:	f2c4 0301 	movt	r3, #16385	; 0x4001
20000cd4:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI1_IRQn;
20000cd6:	687b      	ldr	r3, [r7, #4]
20000cd8:	f04f 0203 	mov.w	r2, #3
20000cdc:	711a      	strb	r2, [r3, #4]
        
        /* reset SPI1 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI1_SOFTRESET_MASK;
20000cde:	f248 0300 	movw	r3, #32768	; 0x8000
20000ce2:	f2c4 0303 	movt	r3, #16387	; 0x4003
20000ce6:	f248 0200 	movw	r2, #32768	; 0x8000
20000cea:	f2c4 0203 	movt	r2, #16387	; 0x4003
20000cee:	6c92      	ldr	r2, [r2, #72]	; 0x48
20000cf0:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
20000cf4:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI1 interrupt */
        NVIC_ClearPendingIRQ(SPI1_IRQn);
20000cf6:	f04f 0003 	mov.w	r0, #3
20000cfa:	f7ff ff61 	bl	20000bc0 <NVIC_ClearPendingIRQ>
        /* Take SPI1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI1_SOFTRESET_MASK;
20000cfe:	f248 0300 	movw	r3, #32768	; 0x8000
20000d02:	f2c4 0303 	movt	r3, #16387	; 0x4003
20000d06:	f248 0200 	movw	r2, #32768	; 0x8000
20000d0a:	f2c4 0203 	movt	r2, #16387	; 0x4003
20000d0e:	6c92      	ldr	r2, [r2, #72]	; 0x48
20000d10:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
20000d14:	649a      	str	r2, [r3, #72]	; 0x48
    }
    
    /* De-assert reset bit. */
    this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
20000d16:	687b      	ldr	r3, [r7, #4]
20000d18:	681b      	ldr	r3, [r3, #0]
20000d1a:	687a      	ldr	r2, [r7, #4]
20000d1c:	6812      	ldr	r2, [r2, #0]
20000d1e:	6812      	ldr	r2, [r2, #0]
20000d20:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
20000d24:	601a      	str	r2, [r3, #0]
}
20000d26:	f107 0710 	add.w	r7, r7, #16
20000d2a:	46bd      	mov	sp, r7
20000d2c:	bd80      	pop	{r7, pc}
20000d2e:	bf00      	nop

20000d30 <recover_from_rx_overflow>:
 */
static void recover_from_rx_overflow
(
    mss_spi_instance_t * this_spi
)
{
20000d30:	b580      	push	{r7, lr}
20000d32:	b08a      	sub	sp, #40	; 0x28
20000d34:	af00      	add	r7, sp, #0
20000d36:	6078      	str	r0, [r7, #4]
    uint32_t slave_select;
    
    /*
     * Read current SPI hardware block configuration.
     */
    control_reg = this_spi->hw_reg->CONTROL;
20000d38:	687b      	ldr	r3, [r7, #4]
20000d3a:	681b      	ldr	r3, [r3, #0]
20000d3c:	681b      	ldr	r3, [r3, #0]
20000d3e:	60fb      	str	r3, [r7, #12]
    clk_gen = this_spi->hw_reg->CLK_GEN;
20000d40:	687b      	ldr	r3, [r7, #4]
20000d42:	681b      	ldr	r3, [r3, #0]
20000d44:	699b      	ldr	r3, [r3, #24]
20000d46:	613b      	str	r3, [r7, #16]
    frame_size = this_spi->hw_reg->TXRXDF_SIZE;
20000d48:	687b      	ldr	r3, [r7, #4]
20000d4a:	681b      	ldr	r3, [r3, #0]
20000d4c:	685b      	ldr	r3, [r3, #4]
20000d4e:	617b      	str	r3, [r7, #20]
    control2 = this_spi->hw_reg->CONTROL2;
20000d50:	687b      	ldr	r3, [r7, #4]
20000d52:	681b      	ldr	r3, [r3, #0]
20000d54:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20000d56:	61bb      	str	r3, [r7, #24]
    packet_size = this_spi->hw_reg->PKTSIZE;
20000d58:	687b      	ldr	r3, [r7, #4]
20000d5a:	681b      	ldr	r3, [r3, #0]
20000d5c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20000d5e:	61fb      	str	r3, [r7, #28]
    cmd_size = this_spi->hw_reg->CMDSIZE;
20000d60:	687b      	ldr	r3, [r7, #4]
20000d62:	681b      	ldr	r3, [r3, #0]
20000d64:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20000d66:	623b      	str	r3, [r7, #32]
    slave_select = this_spi->hw_reg->SLAVE_SELECT;
20000d68:	687b      	ldr	r3, [r7, #4]
20000d6a:	681b      	ldr	r3, [r3, #0]
20000d6c:	69db      	ldr	r3, [r3, #28]
20000d6e:	627b      	str	r3, [r7, #36]	; 0x24
     
    /*
     * Reset the SPI hardware block.
     */
    if(this_spi == &g_mss_spi0)
20000d70:	687a      	ldr	r2, [r7, #4]
20000d72:	f644 3394 	movw	r3, #19348	; 0x4b94
20000d76:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d7a:	429a      	cmp	r2, r3
20000d7c:	d12e      	bne.n	20000ddc <recover_from_rx_overflow+0xac>
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI0_BASE);
20000d7e:	687a      	ldr	r2, [r7, #4]
20000d80:	f241 0300 	movw	r3, #4096	; 0x1000
20000d84:	f2c4 0300 	movt	r3, #16384	; 0x4000
20000d88:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI0_IRQn;
20000d8a:	687b      	ldr	r3, [r7, #4]
20000d8c:	f04f 0202 	mov.w	r2, #2
20000d90:	711a      	strb	r2, [r3, #4]

        /* reset SPI0 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI0_SOFTRESET_MASK;
20000d92:	f248 0300 	movw	r3, #32768	; 0x8000
20000d96:	f2c4 0303 	movt	r3, #16387	; 0x4003
20000d9a:	f248 0200 	movw	r2, #32768	; 0x8000
20000d9e:	f2c4 0203 	movt	r2, #16387	; 0x4003
20000da2:	6c92      	ldr	r2, [r2, #72]	; 0x48
20000da4:	f442 7200 	orr.w	r2, r2, #512	; 0x200
20000da8:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI0 interrupt */
        NVIC_ClearPendingIRQ(SPI0_IRQn);
20000daa:	f04f 0002 	mov.w	r0, #2
20000dae:	f7ff ff07 	bl	20000bc0 <NVIC_ClearPendingIRQ>
        /* Take SPI0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI0_SOFTRESET_MASK;
20000db2:	f248 0300 	movw	r3, #32768	; 0x8000
20000db6:	f2c4 0303 	movt	r3, #16387	; 0x4003
20000dba:	f248 0200 	movw	r2, #32768	; 0x8000
20000dbe:	f2c4 0203 	movt	r2, #16387	; 0x4003
20000dc2:	6c92      	ldr	r2, [r2, #72]	; 0x48
20000dc4:	f422 7200 	bic.w	r2, r2, #512	; 0x200
20000dc8:	649a      	str	r2, [r3, #72]	; 0x48

        this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
20000dca:	687b      	ldr	r3, [r7, #4]
20000dcc:	681b      	ldr	r3, [r3, #0]
20000dce:	687a      	ldr	r2, [r7, #4]
20000dd0:	6812      	ldr	r2, [r2, #0]
20000dd2:	6812      	ldr	r2, [r2, #0]
20000dd4:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
20000dd8:	601a      	str	r2, [r3, #0]
20000dda:	e02d      	b.n	20000e38 <recover_from_rx_overflow+0x108>
    }
    else
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI1_BASE);
20000ddc:	687a      	ldr	r2, [r7, #4]
20000dde:	f241 0300 	movw	r3, #4096	; 0x1000
20000de2:	f2c4 0301 	movt	r3, #16385	; 0x4001
20000de6:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI1_IRQn;
20000de8:	687b      	ldr	r3, [r7, #4]
20000dea:	f04f 0203 	mov.w	r2, #3
20000dee:	711a      	strb	r2, [r3, #4]
        
        /* reset SPI1 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI1_SOFTRESET_MASK;
20000df0:	f248 0300 	movw	r3, #32768	; 0x8000
20000df4:	f2c4 0303 	movt	r3, #16387	; 0x4003
20000df8:	f248 0200 	movw	r2, #32768	; 0x8000
20000dfc:	f2c4 0203 	movt	r2, #16387	; 0x4003
20000e00:	6c92      	ldr	r2, [r2, #72]	; 0x48
20000e02:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
20000e06:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI1 interrupt */
        NVIC_ClearPendingIRQ(SPI1_IRQn);
20000e08:	f04f 0003 	mov.w	r0, #3
20000e0c:	f7ff fed8 	bl	20000bc0 <NVIC_ClearPendingIRQ>
        /* Take SPI1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI1_SOFTRESET_MASK;
20000e10:	f248 0300 	movw	r3, #32768	; 0x8000
20000e14:	f2c4 0303 	movt	r3, #16387	; 0x4003
20000e18:	f248 0200 	movw	r2, #32768	; 0x8000
20000e1c:	f2c4 0203 	movt	r2, #16387	; 0x4003
20000e20:	6c92      	ldr	r2, [r2, #72]	; 0x48
20000e22:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
20000e26:	649a      	str	r2, [r3, #72]	; 0x48
        
        this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
20000e28:	687b      	ldr	r3, [r7, #4]
20000e2a:	681b      	ldr	r3, [r3, #0]
20000e2c:	687a      	ldr	r2, [r7, #4]
20000e2e:	6812      	ldr	r2, [r2, #0]
20000e30:	6812      	ldr	r2, [r2, #0]
20000e32:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
20000e36:	601a      	str	r2, [r3, #0]
    }
    
    /*
     * Restore SPI hardware block configuration.
     */
    control_reg &= ~(uint32_t)CTRL_ENABLE_MASK;
20000e38:	68fb      	ldr	r3, [r7, #12]
20000e3a:	f023 0301 	bic.w	r3, r3, #1
20000e3e:	60fb      	str	r3, [r7, #12]
    this_spi->hw_reg->CONTROL = control_reg;
20000e40:	687b      	ldr	r3, [r7, #4]
20000e42:	681b      	ldr	r3, [r3, #0]
20000e44:	68fa      	ldr	r2, [r7, #12]
20000e46:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CLK_GEN = clk_gen;
20000e48:	687b      	ldr	r3, [r7, #4]
20000e4a:	681b      	ldr	r3, [r3, #0]
20000e4c:	693a      	ldr	r2, [r7, #16]
20000e4e:	619a      	str	r2, [r3, #24]
    this_spi->hw_reg->TXRXDF_SIZE = frame_size;
20000e50:	687b      	ldr	r3, [r7, #4]
20000e52:	681b      	ldr	r3, [r3, #0]
20000e54:	697a      	ldr	r2, [r7, #20]
20000e56:	605a      	str	r2, [r3, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
20000e58:	687b      	ldr	r3, [r7, #4]
20000e5a:	681b      	ldr	r3, [r3, #0]
20000e5c:	687a      	ldr	r2, [r7, #4]
20000e5e:	6812      	ldr	r2, [r2, #0]
20000e60:	6812      	ldr	r2, [r2, #0]
20000e62:	f042 0201 	orr.w	r2, r2, #1
20000e66:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL2 = control2;
20000e68:	687b      	ldr	r3, [r7, #4]
20000e6a:	681b      	ldr	r3, [r3, #0]
20000e6c:	69ba      	ldr	r2, [r7, #24]
20000e6e:	629a      	str	r2, [r3, #40]	; 0x28
    this_spi->hw_reg->PKTSIZE = packet_size;
20000e70:	687b      	ldr	r3, [r7, #4]
20000e72:	681b      	ldr	r3, [r3, #0]
20000e74:	69fa      	ldr	r2, [r7, #28]
20000e76:	631a      	str	r2, [r3, #48]	; 0x30
    this_spi->hw_reg->CMDSIZE = cmd_size;
20000e78:	687b      	ldr	r3, [r7, #4]
20000e7a:	681b      	ldr	r3, [r3, #0]
20000e7c:	6a3a      	ldr	r2, [r7, #32]
20000e7e:	635a      	str	r2, [r3, #52]	; 0x34
    this_spi->hw_reg->SLAVE_SELECT = slave_select;
20000e80:	687b      	ldr	r3, [r7, #4]
20000e82:	681b      	ldr	r3, [r3, #0]
20000e84:	6a7a      	ldr	r2, [r7, #36]	; 0x24
20000e86:	61da      	str	r2, [r3, #28]
}
20000e88:	f107 0728 	add.w	r7, r7, #40	; 0x28
20000e8c:	46bd      	mov	sp, r7
20000e8e:	bd80      	pop	{r7, pc}

20000e90 <MSS_SPI_configure_slave_mode>:
(
    mss_spi_instance_t * this_spi,
    mss_spi_protocol_mode_t protocol_mode,
    uint8_t frame_bit_length
)
{
20000e90:	b580      	push	{r7, lr}
20000e92:	b084      	sub	sp, #16
20000e94:	af00      	add	r7, sp, #0
20000e96:	60f8      	str	r0, [r7, #12]
20000e98:	60b9      	str	r1, [r7, #8]
20000e9a:	4613      	mov	r3, r2
20000e9c:	71fb      	strb	r3, [r7, #7]
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20000e9e:	68fa      	ldr	r2, [r7, #12]
20000ea0:	f644 3394 	movw	r3, #19348	; 0x4b94
20000ea4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ea8:	429a      	cmp	r2, r3
20000eaa:	d007      	beq.n	20000ebc <MSS_SPI_configure_slave_mode+0x2c>
20000eac:	68fa      	ldr	r2, [r7, #12]
20000eae:	f644 3310 	movw	r3, #19216	; 0x4b10
20000eb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000eb6:	429a      	cmp	r2, r3
20000eb8:	d000      	beq.n	20000ebc <MSS_SPI_configure_slave_mode+0x2c>
20000eba:	be00      	bkpt	0x0000
    ASSERT(frame_bit_length <= MAX_FRAME_LENGTH);
20000ebc:	79fb      	ldrb	r3, [r7, #7]
20000ebe:	2b20      	cmp	r3, #32
20000ec0:	d900      	bls.n	20000ec4 <MSS_SPI_configure_slave_mode+0x34>
20000ec2:	be00      	bkpt	0x0000
    
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20000ec4:	68fb      	ldr	r3, [r7, #12]
20000ec6:	791b      	ldrb	r3, [r3, #4]
20000ec8:	b25b      	sxtb	r3, r3
20000eca:	4618      	mov	r0, r3
20000ecc:	f7ff fe5a 	bl	20000b84 <NVIC_DisableIRQ>

    /* Don't yet know what slave transfer mode will be used */
    this_spi->slave_xfer_mode = MSS_SPI_SLAVE_XFER_NONE;
20000ed0:	68fb      	ldr	r3, [r7, #12]
20000ed2:	f04f 0200 	mov.w	r2, #0
20000ed6:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Set the mode. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_MASTER_MASK;
20000eda:	68fb      	ldr	r3, [r7, #12]
20000edc:	681b      	ldr	r3, [r3, #0]
20000ede:	68fa      	ldr	r2, [r7, #12]
20000ee0:	6812      	ldr	r2, [r2, #0]
20000ee2:	6812      	ldr	r2, [r2, #0]
20000ee4:	f022 0202 	bic.w	r2, r2, #2
20000ee8:	601a      	str	r2, [r3, #0]

    /* Set the protocol mode */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
20000eea:	68fb      	ldr	r3, [r7, #12]
20000eec:	681b      	ldr	r3, [r3, #0]
20000eee:	68fa      	ldr	r2, [r7, #12]
20000ef0:	6812      	ldr	r2, [r2, #0]
20000ef2:	6812      	ldr	r2, [r2, #0]
20000ef4:	f022 0201 	bic.w	r2, r2, #1
20000ef8:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~PROTOCOL_MODE_MASK) |
20000efa:	68fb      	ldr	r3, [r7, #12]
20000efc:	681a      	ldr	r2, [r3, #0]
20000efe:	68fb      	ldr	r3, [r7, #12]
20000f00:	681b      	ldr	r3, [r3, #0]
20000f02:	681b      	ldr	r3, [r3, #0]
20000f04:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
20000f08:	f023 030c 	bic.w	r3, r3, #12
                                (uint32_t)protocol_mode | BIGFIFO_MASK;
20000f0c:	68b9      	ldr	r1, [r7, #8]
20000f0e:	ea43 0301 	orr.w	r3, r3, r1
    /* Set the mode. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_MASTER_MASK;

    /* Set the protocol mode */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~PROTOCOL_MODE_MASK) |
20000f12:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
20000f16:	6013      	str	r3, [r2, #0]
                                (uint32_t)protocol_mode | BIGFIFO_MASK;
    
    /* Set number of data frames to 1 by default */
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK) |
20000f18:	68fb      	ldr	r3, [r7, #12]
20000f1a:	681a      	ldr	r2, [r3, #0]
20000f1c:	68fb      	ldr	r3, [r7, #12]
20000f1e:	681b      	ldr	r3, [r3, #0]
20000f20:	6819      	ldr	r1, [r3, #0]
20000f22:	f240 03ff 	movw	r3, #255	; 0xff
20000f26:	f6cf 7300 	movt	r3, #65280	; 0xff00
20000f2a:	ea01 0303 	and.w	r3, r1, r3
20000f2e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20000f32:	6013      	str	r3, [r2, #0]
                                ((uint32_t)1 << TXRXDFCOUNT_SHIFT);
    this_spi->hw_reg->TXRXDF_SIZE = frame_bit_length;
20000f34:	68fb      	ldr	r3, [r7, #12]
20000f36:	681b      	ldr	r3, [r3, #0]
20000f38:	79fa      	ldrb	r2, [r7, #7]
20000f3a:	605a      	str	r2, [r3, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
20000f3c:	68fb      	ldr	r3, [r7, #12]
20000f3e:	681b      	ldr	r3, [r3, #0]
20000f40:	68fa      	ldr	r2, [r7, #12]
20000f42:	6812      	ldr	r2, [r2, #0]
20000f44:	6812      	ldr	r2, [r2, #0]
20000f46:	f042 0201 	orr.w	r2, r2, #1
20000f4a:	601a      	str	r2, [r3, #0]
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
20000f4c:	68fb      	ldr	r3, [r7, #12]
20000f4e:	791b      	ldrb	r3, [r3, #4]
20000f50:	b25b      	sxtb	r3, r3
20000f52:	4618      	mov	r0, r3
20000f54:	f7ff fdfa 	bl	20000b4c <NVIC_EnableIRQ>
}
20000f58:	f107 0710 	add.w	r7, r7, #16
20000f5c:	46bd      	mov	sp, r7
20000f5e:	bd80      	pop	{r7, pc}

20000f60 <MSS_SPI_configure_master_mode>:
    mss_spi_slave_t         slave,
    mss_spi_protocol_mode_t protocol_mode,
    uint32_t                clk_div,
    uint8_t                 frame_bit_length
)
{
20000f60:	b580      	push	{r7, lr}
20000f62:	b086      	sub	sp, #24
20000f64:	af00      	add	r7, sp, #0
20000f66:	60f8      	str	r0, [r7, #12]
20000f68:	607a      	str	r2, [r7, #4]
20000f6a:	603b      	str	r3, [r7, #0]
20000f6c:	460b      	mov	r3, r1
20000f6e:	72fb      	strb	r3, [r7, #11]
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20000f70:	68fa      	ldr	r2, [r7, #12]
20000f72:	f644 3394 	movw	r3, #19348	; 0x4b94
20000f76:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f7a:	429a      	cmp	r2, r3
20000f7c:	d007      	beq.n	20000f8e <MSS_SPI_configure_master_mode+0x2e>
20000f7e:	68fa      	ldr	r2, [r7, #12]
20000f80:	f644 3310 	movw	r3, #19216	; 0x4b10
20000f84:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f88:	429a      	cmp	r2, r3
20000f8a:	d000      	beq.n	20000f8e <MSS_SPI_configure_master_mode+0x2e>
20000f8c:	be00      	bkpt	0x0000
    ASSERT(slave < MSS_SPI_MAX_NB_OF_SLAVES);
20000f8e:	7afb      	ldrb	r3, [r7, #11]
20000f90:	2b07      	cmp	r3, #7
20000f92:	d900      	bls.n	20000f96 <MSS_SPI_configure_master_mode+0x36>
20000f94:	be00      	bkpt	0x0000
    ASSERT(frame_bit_length <= MAX_FRAME_LENGTH);
20000f96:	f897 3020 	ldrb.w	r3, [r7, #32]
20000f9a:	2b20      	cmp	r3, #32
20000f9c:	d900      	bls.n	20000fa0 <MSS_SPI_configure_master_mode+0x40>
20000f9e:	be00      	bkpt	0x0000
     /* Check that the requested clock divider is within range and an even number. */
    ASSERT(clk_div >= 2u);
20000fa0:	683b      	ldr	r3, [r7, #0]
20000fa2:	2b01      	cmp	r3, #1
20000fa4:	d800      	bhi.n	20000fa8 <MSS_SPI_configure_master_mode+0x48>
20000fa6:	be00      	bkpt	0x0000
    ASSERT(clk_div <= 512u);
20000fa8:	683b      	ldr	r3, [r7, #0]
20000faa:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20000fae:	d900      	bls.n	20000fb2 <MSS_SPI_configure_master_mode+0x52>
20000fb0:	be00      	bkpt	0x0000
    ASSERT(0u == (clk_div & 0x00000001));
20000fb2:	683b      	ldr	r3, [r7, #0]
20000fb4:	f003 0301 	and.w	r3, r3, #1
20000fb8:	2b00      	cmp	r3, #0
20000fba:	d000      	beq.n	20000fbe <MSS_SPI_configure_master_mode+0x5e>
20000fbc:	be00      	bkpt	0x0000
   
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20000fbe:	68fb      	ldr	r3, [r7, #12]
20000fc0:	791b      	ldrb	r3, [r3, #4]
20000fc2:	b25b      	sxtb	r3, r3
20000fc4:	4618      	mov	r0, r3
20000fc6:	f7ff fddd 	bl	20000b84 <NVIC_DisableIRQ>

    /* Reset slave transfer mode to unknown to wipe slate clean */
    this_spi->slave_xfer_mode = MSS_SPI_SLAVE_XFER_NONE;
20000fca:	68fb      	ldr	r3, [r7, #12]
20000fcc:	f04f 0200 	mov.w	r2, #0
20000fd0:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Set the mode. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
20000fd4:	68fb      	ldr	r3, [r7, #12]
20000fd6:	681b      	ldr	r3, [r3, #0]
20000fd8:	68fa      	ldr	r2, [r7, #12]
20000fda:	6812      	ldr	r2, [r2, #0]
20000fdc:	6812      	ldr	r2, [r2, #0]
20000fde:	f022 0201 	bic.w	r2, r2, #1
20000fe2:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL |= CTRL_MASTER_MASK;
20000fe4:	68fb      	ldr	r3, [r7, #12]
20000fe6:	681b      	ldr	r3, [r3, #0]
20000fe8:	68fa      	ldr	r2, [r7, #12]
20000fea:	6812      	ldr	r2, [r2, #0]
20000fec:	6812      	ldr	r2, [r2, #0]
20000fee:	f042 0202 	orr.w	r2, r2, #2
20000ff2:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
20000ff4:	68fb      	ldr	r3, [r7, #12]
20000ff6:	681b      	ldr	r3, [r3, #0]
20000ff8:	68fa      	ldr	r2, [r7, #12]
20000ffa:	6812      	ldr	r2, [r2, #0]
20000ffc:	6812      	ldr	r2, [r2, #0]
20000ffe:	f042 0201 	orr.w	r2, r2, #1
20001002:	601a      	str	r2, [r3, #0]
    /*
     * Keep track of the required register configuration for this slave. These
     * values will be used by the MSS_SPI_set_slave_select() function to configure
     * the master to match the slave being selected.
     */
    if(slave < MSS_SPI_MAX_NB_OF_SLAVES)     
20001004:	7afb      	ldrb	r3, [r7, #11]
20001006:	2b07      	cmp	r3, #7
20001008:	d847      	bhi.n	2000109a <MSS_SPI_configure_master_mode+0x13a>
        * Setting the SPS bit ensures the slave select remains asserted even
        * if we don't keep the TX FIFO filled in block mode. We only do it for
        * Motorola modes and if you need the slave selected deselected between
        * frames in modes 0 or 2 then remove SPS_MASK from below.
        */
        if((MSS_SPI_MODE0 == protocol_mode) || (MSS_SPI_MODE1 == protocol_mode) ||
2000100a:	687b      	ldr	r3, [r7, #4]
2000100c:	2b00      	cmp	r3, #0
2000100e:	d00b      	beq.n	20001028 <MSS_SPI_configure_master_mode+0xc8>
20001010:	687b      	ldr	r3, [r7, #4]
20001012:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20001016:	d007      	beq.n	20001028 <MSS_SPI_configure_master_mode+0xc8>
20001018:	687b      	ldr	r3, [r7, #4]
2000101a:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000101e:	d003      	beq.n	20001028 <MSS_SPI_configure_master_mode+0xc8>
20001020:	687b      	ldr	r3, [r7, #4]
20001022:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
20001026:	d10f      	bne.n	20001048 <MSS_SPI_configure_master_mode+0xe8>
           (MSS_SPI_MODE2 == protocol_mode) || (MSS_SPI_MODE3 == protocol_mode))
        {
            this_spi->slaves_cfg[slave].ctrl_reg = MASTER_MODE_MASK | SPS_MASK |
20001028:	7afa      	ldrb	r2, [r7, #11]
2000102a:	6879      	ldr	r1, [r7, #4]
2000102c:	f240 1302 	movw	r3, #258	; 0x102
20001030:	f2c3 4300 	movt	r3, #13312	; 0x3400
20001034:	ea41 0303 	orr.w	r3, r1, r3
20001038:	68f9      	ldr	r1, [r7, #12]
2000103a:	f102 0206 	add.w	r2, r2, #6
2000103e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
20001042:	440a      	add	r2, r1
20001044:	6053      	str	r3, [r2, #4]
        * Setting the SPS bit ensures the slave select remains asserted even
        * if we don't keep the TX FIFO filled in block mode. We only do it for
        * Motorola modes and if you need the slave selected deselected between
        * frames in modes 0 or 2 then remove SPS_MASK from below.
        */
        if((MSS_SPI_MODE0 == protocol_mode) || (MSS_SPI_MODE1 == protocol_mode) ||
20001046:	e00e      	b.n	20001066 <MSS_SPI_configure_master_mode+0x106>
                                                   (uint32_t)protocol_mode | 
                                                   ((uint32_t)1 << TXRXDFCOUNT_SHIFT);
        }
        else
        {
            this_spi->slaves_cfg[slave].ctrl_reg = MASTER_MODE_MASK |
20001048:	7afa      	ldrb	r2, [r7, #11]
2000104a:	6879      	ldr	r1, [r7, #4]
2000104c:	f240 1302 	movw	r3, #258	; 0x102
20001050:	f2c3 0300 	movt	r3, #12288	; 0x3000
20001054:	ea41 0303 	orr.w	r3, r1, r3
20001058:	68f9      	ldr	r1, [r7, #12]
2000105a:	f102 0206 	add.w	r2, r2, #6
2000105e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
20001062:	440a      	add	r2, r1
20001064:	6053      	str	r3, [r2, #4]
                                                   BIGFIFO_MASK | CTRL_CLKMODE_MASK |
                                                   (uint32_t)protocol_mode | 
                                                   ((uint32_t)1 << TXRXDFCOUNT_SHIFT);
        }
        this_spi->slaves_cfg[slave].txrxdf_size_reg = frame_bit_length;
20001066:	7afb      	ldrb	r3, [r7, #11]
20001068:	68fa      	ldr	r2, [r7, #12]
2000106a:	f103 0306 	add.w	r3, r3, #6
2000106e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20001072:	4413      	add	r3, r2
20001074:	f897 2020 	ldrb.w	r2, [r7, #32]
20001078:	721a      	strb	r2, [r3, #8]

        clk_gen = (clk_div / 2u) - 1u;
2000107a:	683b      	ldr	r3, [r7, #0]
2000107c:	ea4f 0353 	mov.w	r3, r3, lsr #1
20001080:	f103 33ff 	add.w	r3, r3, #4294967295
20001084:	617b      	str	r3, [r7, #20]
        this_spi->slaves_cfg[slave].clk_gen = (uint8_t)clk_gen;
20001086:	7afb      	ldrb	r3, [r7, #11]
20001088:	697a      	ldr	r2, [r7, #20]
2000108a:	b2d2      	uxtb	r2, r2
2000108c:	68f9      	ldr	r1, [r7, #12]
2000108e:	f103 0306 	add.w	r3, r3, #6
20001092:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20001096:	440b      	add	r3, r1
20001098:	725a      	strb	r2, [r3, #9]
    }
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
2000109a:	68fb      	ldr	r3, [r7, #12]
2000109c:	791b      	ldrb	r3, [r3, #4]
2000109e:	b25b      	sxtb	r3, r3
200010a0:	4618      	mov	r0, r3
200010a2:	f7ff fd53 	bl	20000b4c <NVIC_EnableIRQ>
}
200010a6:	f107 0718 	add.w	r7, r7, #24
200010aa:	46bd      	mov	sp, r7
200010ac:	bd80      	pop	{r7, pc}
200010ae:	bf00      	nop

200010b0 <MSS_SPI_set_slave_select>:
void MSS_SPI_set_slave_select
(
    mss_spi_instance_t * this_spi,
    mss_spi_slave_t slave
)
{
200010b0:	b580      	push	{r7, lr}
200010b2:	b084      	sub	sp, #16
200010b4:	af00      	add	r7, sp, #0
200010b6:	6078      	str	r0, [r7, #4]
200010b8:	460b      	mov	r3, r1
200010ba:	70fb      	strb	r3, [r7, #3]
    uint32_t rx_overflow;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
200010bc:	687a      	ldr	r2, [r7, #4]
200010be:	f644 3394 	movw	r3, #19348	; 0x4b94
200010c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010c6:	429a      	cmp	r2, r3
200010c8:	d007      	beq.n	200010da <MSS_SPI_set_slave_select+0x2a>
200010ca:	687a      	ldr	r2, [r7, #4]
200010cc:	f644 3310 	movw	r3, #19216	; 0x4b10
200010d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010d4:	429a      	cmp	r2, r3
200010d6:	d000      	beq.n	200010da <MSS_SPI_set_slave_select+0x2a>
200010d8:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
200010da:	687b      	ldr	r3, [r7, #4]
200010dc:	681b      	ldr	r3, [r3, #0]
200010de:	681b      	ldr	r3, [r3, #0]
200010e0:	f003 0302 	and.w	r3, r3, #2
200010e4:	2b00      	cmp	r3, #0
200010e6:	d100      	bne.n	200010ea <MSS_SPI_set_slave_select+0x3a>
200010e8:	be00      	bkpt	0x0000
    
    ASSERT(this_spi->slaves_cfg[slave].ctrl_reg != NOT_CONFIGURED);
200010ea:	78fb      	ldrb	r3, [r7, #3]
200010ec:	687a      	ldr	r2, [r7, #4]
200010ee:	f103 0306 	add.w	r3, r3, #6
200010f2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
200010f6:	4413      	add	r3, r2
200010f8:	685b      	ldr	r3, [r3, #4]
200010fa:	f1b3 3fff 	cmp.w	r3, #4294967295
200010fe:	d100      	bne.n	20001102 <MSS_SPI_set_slave_select+0x52>
20001100:	be00      	bkpt	0x0000

    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20001102:	687b      	ldr	r3, [r7, #4]
20001104:	791b      	ldrb	r3, [r3, #4]
20001106:	b25b      	sxtb	r3, r3
20001108:	4618      	mov	r0, r3
2000110a:	f7ff fd3b 	bl	20000b84 <NVIC_DisableIRQ>

    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
2000110e:	687b      	ldr	r3, [r7, #4]
20001110:	681b      	ldr	r3, [r3, #0]
20001112:	689b      	ldr	r3, [r3, #8]
20001114:	f003 0304 	and.w	r3, r3, #4
20001118:	60fb      	str	r3, [r7, #12]
    if(rx_overflow)
2000111a:	68fb      	ldr	r3, [r7, #12]
2000111c:	2b00      	cmp	r3, #0
2000111e:	d002      	beq.n	20001126 <MSS_SPI_set_slave_select+0x76>
    {
         recover_from_rx_overflow(this_spi);
20001120:	6878      	ldr	r0, [r7, #4]
20001122:	f7ff fe05 	bl	20000d30 <recover_from_rx_overflow>
    }
    
    /* Set the clock rate. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
20001126:	687b      	ldr	r3, [r7, #4]
20001128:	681b      	ldr	r3, [r3, #0]
2000112a:	687a      	ldr	r2, [r7, #4]
2000112c:	6812      	ldr	r2, [r2, #0]
2000112e:	6812      	ldr	r2, [r2, #0]
20001130:	f022 0201 	bic.w	r2, r2, #1
20001134:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL = this_spi->slaves_cfg[slave].ctrl_reg;
20001136:	687b      	ldr	r3, [r7, #4]
20001138:	681a      	ldr	r2, [r3, #0]
2000113a:	78fb      	ldrb	r3, [r7, #3]
2000113c:	6879      	ldr	r1, [r7, #4]
2000113e:	f103 0306 	add.w	r3, r3, #6
20001142:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20001146:	440b      	add	r3, r1
20001148:	685b      	ldr	r3, [r3, #4]
2000114a:	6013      	str	r3, [r2, #0]
    this_spi->hw_reg->CLK_GEN = this_spi->slaves_cfg[slave].clk_gen;
2000114c:	687b      	ldr	r3, [r7, #4]
2000114e:	681a      	ldr	r2, [r3, #0]
20001150:	78fb      	ldrb	r3, [r7, #3]
20001152:	6879      	ldr	r1, [r7, #4]
20001154:	f103 0306 	add.w	r3, r3, #6
20001158:	ea4f 03c3 	mov.w	r3, r3, lsl #3
2000115c:	440b      	add	r3, r1
2000115e:	7a5b      	ldrb	r3, [r3, #9]
20001160:	6193      	str	r3, [r2, #24]
    this_spi->hw_reg->TXRXDF_SIZE = this_spi->slaves_cfg[slave].txrxdf_size_reg;
20001162:	687b      	ldr	r3, [r7, #4]
20001164:	681a      	ldr	r2, [r3, #0]
20001166:	78fb      	ldrb	r3, [r7, #3]
20001168:	6879      	ldr	r1, [r7, #4]
2000116a:	f103 0306 	add.w	r3, r3, #6
2000116e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20001172:	440b      	add	r3, r1
20001174:	7a1b      	ldrb	r3, [r3, #8]
20001176:	6053      	str	r3, [r2, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
20001178:	687b      	ldr	r3, [r7, #4]
2000117a:	681b      	ldr	r3, [r3, #0]
2000117c:	687a      	ldr	r2, [r7, #4]
2000117e:	6812      	ldr	r2, [r2, #0]
20001180:	6812      	ldr	r2, [r2, #0]
20001182:	f042 0201 	orr.w	r2, r2, #1
20001186:	601a      	str	r2, [r3, #0]
    
    /* Set slave select */
    this_spi->hw_reg->SLAVE_SELECT |= ((uint32_t)1 << (uint32_t)slave);
20001188:	687b      	ldr	r3, [r7, #4]
2000118a:	681b      	ldr	r3, [r3, #0]
2000118c:	687a      	ldr	r2, [r7, #4]
2000118e:	6812      	ldr	r2, [r2, #0]
20001190:	69d1      	ldr	r1, [r2, #28]
20001192:	78fa      	ldrb	r2, [r7, #3]
20001194:	f04f 0001 	mov.w	r0, #1
20001198:	fa00 f202 	lsl.w	r2, r0, r2
2000119c:	ea41 0202 	orr.w	r2, r1, r2
200011a0:	61da      	str	r2, [r3, #28]
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
200011a2:	687b      	ldr	r3, [r7, #4]
200011a4:	791b      	ldrb	r3, [r3, #4]
200011a6:	b25b      	sxtb	r3, r3
200011a8:	4618      	mov	r0, r3
200011aa:	f7ff fccf 	bl	20000b4c <NVIC_EnableIRQ>
}
200011ae:	f107 0710 	add.w	r7, r7, #16
200011b2:	46bd      	mov	sp, r7
200011b4:	bd80      	pop	{r7, pc}
200011b6:	bf00      	nop

200011b8 <MSS_SPI_clear_slave_select>:
void MSS_SPI_clear_slave_select
(
    mss_spi_instance_t * this_spi,
    mss_spi_slave_t slave
)
{
200011b8:	b580      	push	{r7, lr}
200011ba:	b084      	sub	sp, #16
200011bc:	af00      	add	r7, sp, #0
200011be:	6078      	str	r0, [r7, #4]
200011c0:	460b      	mov	r3, r1
200011c2:	70fb      	strb	r3, [r7, #3]
    uint32_t rx_overflow;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
200011c4:	687a      	ldr	r2, [r7, #4]
200011c6:	f644 3394 	movw	r3, #19348	; 0x4b94
200011ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
200011ce:	429a      	cmp	r2, r3
200011d0:	d007      	beq.n	200011e2 <MSS_SPI_clear_slave_select+0x2a>
200011d2:	687a      	ldr	r2, [r7, #4]
200011d4:	f644 3310 	movw	r3, #19216	; 0x4b10
200011d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200011dc:	429a      	cmp	r2, r3
200011de:	d000      	beq.n	200011e2 <MSS_SPI_clear_slave_select+0x2a>
200011e0:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
200011e2:	687b      	ldr	r3, [r7, #4]
200011e4:	681b      	ldr	r3, [r3, #0]
200011e6:	681b      	ldr	r3, [r3, #0]
200011e8:	f003 0302 	and.w	r3, r3, #2
200011ec:	2b00      	cmp	r3, #0
200011ee:	d100      	bne.n	200011f2 <MSS_SPI_clear_slave_select+0x3a>
200011f0:	be00      	bkpt	0x0000

    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
200011f2:	687b      	ldr	r3, [r7, #4]
200011f4:	791b      	ldrb	r3, [r3, #4]
200011f6:	b25b      	sxtb	r3, r3
200011f8:	4618      	mov	r0, r3
200011fa:	f7ff fcc3 	bl	20000b84 <NVIC_DisableIRQ>

    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
200011fe:	687b      	ldr	r3, [r7, #4]
20001200:	681b      	ldr	r3, [r3, #0]
20001202:	689b      	ldr	r3, [r3, #8]
20001204:	f003 0304 	and.w	r3, r3, #4
20001208:	60fb      	str	r3, [r7, #12]
    if(rx_overflow)
2000120a:	68fb      	ldr	r3, [r7, #12]
2000120c:	2b00      	cmp	r3, #0
2000120e:	d002      	beq.n	20001216 <MSS_SPI_clear_slave_select+0x5e>
    {
         recover_from_rx_overflow(this_spi);
20001210:	6878      	ldr	r0, [r7, #4]
20001212:	f7ff fd8d 	bl	20000d30 <recover_from_rx_overflow>
    }
    
    this_spi->hw_reg->SLAVE_SELECT &= ~((uint32_t)1 << (uint32_t)slave);
20001216:	687b      	ldr	r3, [r7, #4]
20001218:	681b      	ldr	r3, [r3, #0]
2000121a:	687a      	ldr	r2, [r7, #4]
2000121c:	6812      	ldr	r2, [r2, #0]
2000121e:	69d1      	ldr	r1, [r2, #28]
20001220:	78fa      	ldrb	r2, [r7, #3]
20001222:	f04f 0001 	mov.w	r0, #1
20001226:	fa00 f202 	lsl.w	r2, r0, r2
2000122a:	ea6f 0202 	mvn.w	r2, r2
2000122e:	ea01 0202 	and.w	r2, r1, r2
20001232:	61da      	str	r2, [r3, #28]
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
20001234:	687b      	ldr	r3, [r7, #4]
20001236:	791b      	ldrb	r3, [r3, #4]
20001238:	b25b      	sxtb	r3, r3
2000123a:	4618      	mov	r0, r3
2000123c:	f7ff fc86 	bl	20000b4c <NVIC_EnableIRQ>
}
20001240:	f107 0710 	add.w	r7, r7, #16
20001244:	46bd      	mov	sp, r7
20001246:	bd80      	pop	{r7, pc}

20001248 <MSS_SPI_transfer_frame>:
uint32_t MSS_SPI_transfer_frame
(
    mss_spi_instance_t * this_spi,
    uint32_t tx_bits
)
{
20001248:	b480      	push	{r7}
2000124a:	b085      	sub	sp, #20
2000124c:	af00      	add	r7, sp, #0
2000124e:	6078      	str	r0, [r7, #4]
20001250:	6039      	str	r1, [r7, #0]
    uint32_t rx_ready;
    uint32_t tx_done;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20001252:	687a      	ldr	r2, [r7, #4]
20001254:	f644 3394 	movw	r3, #19348	; 0x4b94
20001258:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000125c:	429a      	cmp	r2, r3
2000125e:	d007      	beq.n	20001270 <MSS_SPI_transfer_frame+0x28>
20001260:	687a      	ldr	r2, [r7, #4]
20001262:	f644 3310 	movw	r3, #19216	; 0x4b10
20001266:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000126a:	429a      	cmp	r2, r3
2000126c:	d000      	beq.n	20001270 <MSS_SPI_transfer_frame+0x28>
2000126e:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
20001270:	687b      	ldr	r3, [r7, #4]
20001272:	681b      	ldr	r3, [r3, #0]
20001274:	681b      	ldr	r3, [r3, #0]
20001276:	f003 0302 	and.w	r3, r3, #2
2000127a:	2b00      	cmp	r3, #0
2000127c:	d100      	bne.n	20001280 <MSS_SPI_transfer_frame+0x38>
2000127e:	be00      	bkpt	0x0000
    
    /* Ensure single frame transfer selected so interrupts work correctly */
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK)
20001280:	687b      	ldr	r3, [r7, #4]
20001282:	681a      	ldr	r2, [r3, #0]
20001284:	687b      	ldr	r3, [r7, #4]
20001286:	681b      	ldr	r3, [r3, #0]
20001288:	6819      	ldr	r1, [r3, #0]
2000128a:	f240 03ff 	movw	r3, #255	; 0xff
2000128e:	f6cf 7300 	movt	r3, #65280	; 0xff00
20001292:	ea01 0303 	and.w	r3, r1, r3
20001296:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2000129a:	6013      	str	r3, [r2, #0]
                                | ((uint32_t)1u << TXRXDFCOUNT_SHIFT);

    /* Flush the Tx and Rx FIFOs. */
    this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
2000129c:	687b      	ldr	r3, [r7, #4]
2000129e:	681b      	ldr	r3, [r3, #0]
200012a0:	687a      	ldr	r2, [r7, #4]
200012a2:	6812      	ldr	r2, [r2, #0]
200012a4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
200012a6:	f042 020c 	orr.w	r2, r2, #12
200012aa:	62da      	str	r2, [r3, #44]	; 0x2c
    
    /* Send frame. */
    this_spi->hw_reg->TX_DATA = tx_bits;
200012ac:	687b      	ldr	r3, [r7, #4]
200012ae:	681b      	ldr	r3, [r3, #0]
200012b0:	683a      	ldr	r2, [r7, #0]
200012b2:	615a      	str	r2, [r3, #20]
    
    /* Wait for frame Tx to complete. */
    tx_done = this_spi->hw_reg->STATUS & TX_DONE_MASK;
200012b4:	687b      	ldr	r3, [r7, #4]
200012b6:	681b      	ldr	r3, [r3, #0]
200012b8:	689b      	ldr	r3, [r3, #8]
200012ba:	f003 0301 	and.w	r3, r3, #1
200012be:	60fb      	str	r3, [r7, #12]
    while(0u == tx_done)
200012c0:	e005      	b.n	200012ce <MSS_SPI_transfer_frame+0x86>
    {
        tx_done = this_spi->hw_reg->STATUS & TX_DONE_MASK;
200012c2:	687b      	ldr	r3, [r7, #4]
200012c4:	681b      	ldr	r3, [r3, #0]
200012c6:	689b      	ldr	r3, [r3, #8]
200012c8:	f003 0301 	and.w	r3, r3, #1
200012cc:	60fb      	str	r3, [r7, #12]
    /* Send frame. */
    this_spi->hw_reg->TX_DATA = tx_bits;
    
    /* Wait for frame Tx to complete. */
    tx_done = this_spi->hw_reg->STATUS & TX_DONE_MASK;
    while(0u == tx_done)
200012ce:	68fb      	ldr	r3, [r7, #12]
200012d0:	2b00      	cmp	r3, #0
200012d2:	d0f6      	beq.n	200012c2 <MSS_SPI_transfer_frame+0x7a>
        tx_done = this_spi->hw_reg->STATUS & TX_DONE_MASK;
    }
    
    /* Read received frame. */
    /* Wait for Rx complete. */
    rx_ready = this_spi->hw_reg->STATUS & RX_DATA_READY_MASK;
200012d4:	687b      	ldr	r3, [r7, #4]
200012d6:	681b      	ldr	r3, [r3, #0]
200012d8:	689b      	ldr	r3, [r3, #8]
200012da:	f003 0302 	and.w	r3, r3, #2
200012de:	60bb      	str	r3, [r7, #8]
    while(0u == rx_ready)
200012e0:	e005      	b.n	200012ee <MSS_SPI_transfer_frame+0xa6>
    {
        rx_ready = this_spi->hw_reg->STATUS & RX_DATA_READY_MASK;
200012e2:	687b      	ldr	r3, [r7, #4]
200012e4:	681b      	ldr	r3, [r3, #0]
200012e6:	689b      	ldr	r3, [r3, #8]
200012e8:	f003 0302 	and.w	r3, r3, #2
200012ec:	60bb      	str	r3, [r7, #8]
    }
    
    /* Read received frame. */
    /* Wait for Rx complete. */
    rx_ready = this_spi->hw_reg->STATUS & RX_DATA_READY_MASK;
    while(0u == rx_ready)
200012ee:	68bb      	ldr	r3, [r7, #8]
200012f0:	2b00      	cmp	r3, #0
200012f2:	d0f6      	beq.n	200012e2 <MSS_SPI_transfer_frame+0x9a>
    {
        rx_ready = this_spi->hw_reg->STATUS & RX_DATA_READY_MASK;
    }
    /* Return Rx data. */
    return( this_spi->hw_reg->RX_DATA );
200012f4:	687b      	ldr	r3, [r7, #4]
200012f6:	681b      	ldr	r3, [r3, #0]
200012f8:	691b      	ldr	r3, [r3, #16]
}
200012fa:	4618      	mov	r0, r3
200012fc:	f107 0714 	add.w	r7, r7, #20
20001300:	46bd      	mov	sp, r7
20001302:	bc80      	pop	{r7}
20001304:	4770      	bx	lr
20001306:	bf00      	nop

20001308 <MSS_SPI_transfer_block>:
    const uint8_t * cmd_buffer,
    uint16_t cmd_byte_size,
    uint8_t * rd_buffer,
    uint16_t rd_byte_size
)
{
20001308:	b580      	push	{r7, lr}
2000130a:	b08e      	sub	sp, #56	; 0x38
2000130c:	af00      	add	r7, sp, #0
2000130e:	60f8      	str	r0, [r7, #12]
20001310:	60b9      	str	r1, [r7, #8]
20001312:	603b      	str	r3, [r7, #0]
20001314:	4613      	mov	r3, r2
20001316:	80fb      	strh	r3, [r7, #6]
    uint16_t transfer_idx = 0u;
20001318:	f04f 0300 	mov.w	r3, #0
2000131c:	837b      	strh	r3, [r7, #26]
    uint16_t tx_idx;
    uint16_t rx_idx;
    uint32_t frame_count;
    volatile uint32_t rx_raw;
    uint16_t transit = 0u;
2000131e:	f04f 0300 	mov.w	r3, #0
20001322:	84fb      	strh	r3, [r7, #38]	; 0x26
    uint32_t rx_overflow;
    uint32_t rx_fifo_empty;
    
    uint16_t transfer_size;     /* Total number of bytes transfered. */
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20001324:	68fa      	ldr	r2, [r7, #12]
20001326:	f644 3394 	movw	r3, #19348	; 0x4b94
2000132a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000132e:	429a      	cmp	r2, r3
20001330:	d007      	beq.n	20001342 <MSS_SPI_transfer_block+0x3a>
20001332:	68fa      	ldr	r2, [r7, #12]
20001334:	f644 3310 	movw	r3, #19216	; 0x4b10
20001338:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000133c:	429a      	cmp	r2, r3
2000133e:	d000      	beq.n	20001342 <MSS_SPI_transfer_block+0x3a>
20001340:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
20001342:	68fb      	ldr	r3, [r7, #12]
20001344:	681b      	ldr	r3, [r3, #0]
20001346:	681b      	ldr	r3, [r3, #0]
20001348:	f003 0302 	and.w	r3, r3, #2
2000134c:	2b00      	cmp	r3, #0
2000134e:	d100      	bne.n	20001352 <MSS_SPI_transfer_block+0x4a>
20001350:	be00      	bkpt	0x0000
    
    /* Compute number of bytes to transfer. */
    transfer_size = cmd_byte_size + rd_byte_size;
20001352:	88fa      	ldrh	r2, [r7, #6]
20001354:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
20001358:	4413      	add	r3, r2
2000135a:	86fb      	strh	r3, [r7, #54]	; 0x36
    
    /* Adjust to 1 byte transfer to cater for DMA transfers. */
    if(0u == transfer_size)
2000135c:	8efb      	ldrh	r3, [r7, #54]	; 0x36
2000135e:	2b00      	cmp	r3, #0
20001360:	d103      	bne.n	2000136a <MSS_SPI_transfer_block+0x62>
    {
        frame_count = 1u;
20001362:	f04f 0301 	mov.w	r3, #1
20001366:	623b      	str	r3, [r7, #32]
20001368:	e001      	b.n	2000136e <MSS_SPI_transfer_block+0x66>
    }
    else
    {
        frame_count = transfer_size;
2000136a:	8efb      	ldrh	r3, [r7, #54]	; 0x36
2000136c:	623b      	str	r3, [r7, #32]
    }

    /* Flush the Tx and Rx FIFOs. */
    this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
2000136e:	68fb      	ldr	r3, [r7, #12]
20001370:	681b      	ldr	r3, [r3, #0]
20001372:	68fa      	ldr	r2, [r7, #12]
20001374:	6812      	ldr	r2, [r2, #0]
20001376:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20001378:	f042 020c 	orr.w	r2, r2, #12
2000137c:	62da      	str	r2, [r3, #44]	; 0x2c
    
    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
2000137e:	68fb      	ldr	r3, [r7, #12]
20001380:	681b      	ldr	r3, [r3, #0]
20001382:	689b      	ldr	r3, [r3, #8]
20001384:	f003 0304 	and.w	r3, r3, #4
20001388:	62fb      	str	r3, [r7, #44]	; 0x2c
    if(rx_overflow)
2000138a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
2000138c:	2b00      	cmp	r3, #0
2000138e:	d002      	beq.n	20001396 <MSS_SPI_transfer_block+0x8e>
    {
         recover_from_rx_overflow(this_spi);
20001390:	68f8      	ldr	r0, [r7, #12]
20001392:	f7ff fccd 	bl	20000d30 <recover_from_rx_overflow>
    }
    
    /* Set frame size to 8 bits and the frame count to the transfer size. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
20001396:	68fb      	ldr	r3, [r7, #12]
20001398:	681b      	ldr	r3, [r3, #0]
2000139a:	68fa      	ldr	r2, [r7, #12]
2000139c:	6812      	ldr	r2, [r2, #0]
2000139e:	6812      	ldr	r2, [r2, #0]
200013a0:	f022 0201 	bic.w	r2, r2, #1
200013a4:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK) | ( (frame_count << TXRXDFCOUNT_SHIFT) & TXRXDFCOUNT_MASK);
200013a6:	68fb      	ldr	r3, [r7, #12]
200013a8:	6819      	ldr	r1, [r3, #0]
200013aa:	68fb      	ldr	r3, [r7, #12]
200013ac:	681b      	ldr	r3, [r3, #0]
200013ae:	681b      	ldr	r3, [r3, #0]
200013b0:	f240 02ff 	movw	r2, #255	; 0xff
200013b4:	f6cf 7200 	movt	r2, #65280	; 0xff00
200013b8:	ea03 0202 	and.w	r2, r3, r2
200013bc:	6a3b      	ldr	r3, [r7, #32]
200013be:	ea4f 2003 	mov.w	r0, r3, lsl #8
200013c2:	f64f 7300 	movw	r3, #65280	; 0xff00
200013c6:	f2c0 03ff 	movt	r3, #255	; 0xff
200013ca:	ea00 0303 	and.w	r3, r0, r3
200013ce:	ea42 0303 	orr.w	r3, r2, r3
200013d2:	600b      	str	r3, [r1, #0]
    this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
200013d4:	68fb      	ldr	r3, [r7, #12]
200013d6:	681b      	ldr	r3, [r3, #0]
200013d8:	f04f 0208 	mov.w	r2, #8
200013dc:	605a      	str	r2, [r3, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
200013de:	68fb      	ldr	r3, [r7, #12]
200013e0:	681b      	ldr	r3, [r3, #0]
200013e2:	68fa      	ldr	r2, [r7, #12]
200013e4:	6812      	ldr	r2, [r2, #0]
200013e6:	6812      	ldr	r2, [r2, #0]
200013e8:	f042 0201 	orr.w	r2, r2, #1
200013ec:	601a      	str	r2, [r3, #0]

    /* Flush the receive FIFO. */
    rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
200013ee:	68fb      	ldr	r3, [r7, #12]
200013f0:	681b      	ldr	r3, [r3, #0]
200013f2:	689b      	ldr	r3, [r3, #8]
200013f4:	f003 0340 	and.w	r3, r3, #64	; 0x40
200013f8:	633b      	str	r3, [r7, #48]	; 0x30
    while(0u == rx_fifo_empty)
200013fa:	e009      	b.n	20001410 <MSS_SPI_transfer_block+0x108>
    {
        rx_raw = this_spi->hw_reg->RX_DATA;
200013fc:	68fb      	ldr	r3, [r7, #12]
200013fe:	681b      	ldr	r3, [r3, #0]
20001400:	691b      	ldr	r3, [r3, #16]
20001402:	617b      	str	r3, [r7, #20]
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
20001404:	68fb      	ldr	r3, [r7, #12]
20001406:	681b      	ldr	r3, [r3, #0]
20001408:	689b      	ldr	r3, [r3, #8]
2000140a:	f003 0340 	and.w	r3, r3, #64	; 0x40
2000140e:	633b      	str	r3, [r7, #48]	; 0x30
    this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;

    /* Flush the receive FIFO. */
    rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
    while(0u == rx_fifo_empty)
20001410:	6b3b      	ldr	r3, [r7, #48]	; 0x30
20001412:	2b00      	cmp	r3, #0
20001414:	d0f2      	beq.n	200013fc <MSS_SPI_transfer_block+0xf4>
    {
        rx_raw = this_spi->hw_reg->RX_DATA;
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
    }
    
    tx_idx = 0u;
20001416:	f04f 0300 	mov.w	r3, #0
2000141a:	83bb      	strh	r3, [r7, #28]
    rx_idx = 0u;
2000141c:	f04f 0300 	mov.w	r3, #0
20001420:	83fb      	strh	r3, [r7, #30]
    if(tx_idx < cmd_byte_size)
20001422:	8bba      	ldrh	r2, [r7, #28]
20001424:	88fb      	ldrh	r3, [r7, #6]
20001426:	429a      	cmp	r2, r3
20001428:	d20f      	bcs.n	2000144a <MSS_SPI_transfer_block+0x142>
    {
        this_spi->hw_reg->TX_DATA = cmd_buffer[tx_idx];
2000142a:	68fb      	ldr	r3, [r7, #12]
2000142c:	681b      	ldr	r3, [r3, #0]
2000142e:	8bb9      	ldrh	r1, [r7, #28]
20001430:	68ba      	ldr	r2, [r7, #8]
20001432:	440a      	add	r2, r1
20001434:	7812      	ldrb	r2, [r2, #0]
20001436:	615a      	str	r2, [r3, #20]
        ++tx_idx;
20001438:	8bbb      	ldrh	r3, [r7, #28]
2000143a:	f103 0301 	add.w	r3, r3, #1
2000143e:	83bb      	strh	r3, [r7, #28]
        ++transit;
20001440:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
20001442:	f103 0301 	add.w	r3, r3, #1
20001446:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
20001448:	e06a      	b.n	20001520 <MSS_SPI_transfer_block+0x218>
        ++tx_idx;
        ++transit;
    }
    else
    {
        if(tx_idx < transfer_size)
2000144a:	8bba      	ldrh	r2, [r7, #28]
2000144c:	8efb      	ldrh	r3, [r7, #54]	; 0x36
2000144e:	429a      	cmp	r2, r3
20001450:	d266      	bcs.n	20001520 <MSS_SPI_transfer_block+0x218>
        {
            this_spi->hw_reg->TX_DATA = 0x00u;
20001452:	68fb      	ldr	r3, [r7, #12]
20001454:	681b      	ldr	r3, [r3, #0]
20001456:	f04f 0200 	mov.w	r2, #0
2000145a:	615a      	str	r2, [r3, #20]
            ++tx_idx;
2000145c:	8bbb      	ldrh	r3, [r7, #28]
2000145e:	f103 0301 	add.w	r3, r3, #1
20001462:	83bb      	strh	r3, [r7, #28]
            ++transit;
20001464:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
20001466:	f103 0301 	add.w	r3, r3, #1
2000146a:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
2000146c:	e058      	b.n	20001520 <MSS_SPI_transfer_block+0x218>
    {
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
2000146e:	68fb      	ldr	r3, [r7, #12]
20001470:	681b      	ldr	r3, [r3, #0]
20001472:	689b      	ldr	r3, [r3, #8]
20001474:	f003 0340 	and.w	r3, r3, #64	; 0x40
20001478:	633b      	str	r3, [r7, #48]	; 0x30
        if(0u == rx_fifo_empty)
2000147a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2000147c:	2b00      	cmp	r3, #0
2000147e:	d11e      	bne.n	200014be <MSS_SPI_transfer_block+0x1b6>
        {
            /* Process received byte. */
            rx_raw = this_spi->hw_reg->RX_DATA;
20001480:	68fb      	ldr	r3, [r7, #12]
20001482:	681b      	ldr	r3, [r3, #0]
20001484:	691b      	ldr	r3, [r3, #16]
20001486:	617b      	str	r3, [r7, #20]
            if(transfer_idx >= cmd_byte_size)
20001488:	8b7a      	ldrh	r2, [r7, #26]
2000148a:	88fb      	ldrh	r3, [r7, #6]
2000148c:	429a      	cmp	r2, r3
2000148e:	d30e      	bcc.n	200014ae <MSS_SPI_transfer_block+0x1a6>
            {
                if(rx_idx < rd_byte_size)
20001490:	8bfa      	ldrh	r2, [r7, #30]
20001492:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
20001496:	429a      	cmp	r2, r3
20001498:	d205      	bcs.n	200014a6 <MSS_SPI_transfer_block+0x19e>
                {
                    rd_buffer[rx_idx] = (uint8_t)rx_raw;   
2000149a:	8bfa      	ldrh	r2, [r7, #30]
2000149c:	683b      	ldr	r3, [r7, #0]
2000149e:	4413      	add	r3, r2
200014a0:	697a      	ldr	r2, [r7, #20]
200014a2:	b2d2      	uxtb	r2, r2
200014a4:	701a      	strb	r2, [r3, #0]
                }
                ++rx_idx;
200014a6:	8bfb      	ldrh	r3, [r7, #30]
200014a8:	f103 0301 	add.w	r3, r3, #1
200014ac:	83fb      	strh	r3, [r7, #30]
            }
            ++transfer_idx;
200014ae:	8b7b      	ldrh	r3, [r7, #26]
200014b0:	f103 0301 	add.w	r3, r3, #1
200014b4:	837b      	strh	r3, [r7, #26]
            --transit;
200014b6:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
200014b8:	f103 33ff 	add.w	r3, r3, #4294967295
200014bc:	84fb      	strh	r3, [r7, #38]	; 0x26
        }

        tx_fifo_full = this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK;
200014be:	68fb      	ldr	r3, [r7, #12]
200014c0:	681b      	ldr	r3, [r3, #0]
200014c2:	689b      	ldr	r3, [r3, #8]
200014c4:	f403 7380 	and.w	r3, r3, #256	; 0x100
200014c8:	62bb      	str	r3, [r7, #40]	; 0x28
        if(0u == tx_fifo_full)
200014ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
200014cc:	2b00      	cmp	r3, #0
200014ce:	d127      	bne.n	20001520 <MSS_SPI_transfer_block+0x218>
        {
            if(transit < RX_FIFO_SIZE)
200014d0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
200014d2:	2b03      	cmp	r3, #3
200014d4:	d824      	bhi.n	20001520 <MSS_SPI_transfer_block+0x218>
            {
                /* Send another byte. */
                if(tx_idx < cmd_byte_size)
200014d6:	8bba      	ldrh	r2, [r7, #28]
200014d8:	88fb      	ldrh	r3, [r7, #6]
200014da:	429a      	cmp	r2, r3
200014dc:	d20f      	bcs.n	200014fe <MSS_SPI_transfer_block+0x1f6>
                {
                    this_spi->hw_reg->TX_DATA = cmd_buffer[tx_idx];
200014de:	68fb      	ldr	r3, [r7, #12]
200014e0:	681b      	ldr	r3, [r3, #0]
200014e2:	8bb9      	ldrh	r1, [r7, #28]
200014e4:	68ba      	ldr	r2, [r7, #8]
200014e6:	440a      	add	r2, r1
200014e8:	7812      	ldrb	r2, [r2, #0]
200014ea:	615a      	str	r2, [r3, #20]
                    ++tx_idx;
200014ec:	8bbb      	ldrh	r3, [r7, #28]
200014ee:	f103 0301 	add.w	r3, r3, #1
200014f2:	83bb      	strh	r3, [r7, #28]
                    ++transit;
200014f4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
200014f6:	f103 0301 	add.w	r3, r3, #1
200014fa:	84fb      	strh	r3, [r7, #38]	; 0x26
200014fc:	e010      	b.n	20001520 <MSS_SPI_transfer_block+0x218>
                }
                else
                {
                    if(tx_idx < transfer_size)
200014fe:	8bba      	ldrh	r2, [r7, #28]
20001500:	8efb      	ldrh	r3, [r7, #54]	; 0x36
20001502:	429a      	cmp	r2, r3
20001504:	d20c      	bcs.n	20001520 <MSS_SPI_transfer_block+0x218>
                    {
                        this_spi->hw_reg->TX_DATA = 0x00u;
20001506:	68fb      	ldr	r3, [r7, #12]
20001508:	681b      	ldr	r3, [r3, #0]
2000150a:	f04f 0200 	mov.w	r2, #0
2000150e:	615a      	str	r2, [r3, #20]
                        ++tx_idx;
20001510:	8bbb      	ldrh	r3, [r7, #28]
20001512:	f103 0301 	add.w	r3, r3, #1
20001516:	83bb      	strh	r3, [r7, #28]
                        ++transit;
20001518:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
2000151a:	f103 0301 	add.w	r3, r3, #1
2000151e:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
20001520:	8b7a      	ldrh	r2, [r7, #26]
20001522:	8efb      	ldrh	r3, [r7, #54]	; 0x36
20001524:	429a      	cmp	r2, r3
20001526:	d3a2      	bcc.n	2000146e <MSS_SPI_transfer_block+0x166>
                    }
                }
            }
        }
    }
}
20001528:	f107 0738 	add.w	r7, r7, #56	; 0x38
2000152c:	46bd      	mov	sp, r7
2000152e:	bd80      	pop	{r7, pc}

20001530 <MSS_SPI_set_frame_rx_handler>:
void MSS_SPI_set_frame_rx_handler
(
    mss_spi_instance_t * this_spi,
    mss_spi_frame_rx_handler_t rx_handler
)
{
20001530:	b580      	push	{r7, lr}
20001532:	b084      	sub	sp, #16
20001534:	af00      	add	r7, sp, #0
20001536:	6078      	str	r0, [r7, #4]
20001538:	6039      	str	r1, [r7, #0]
    uint32_t tx_fifo_empty;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
2000153a:	687a      	ldr	r2, [r7, #4]
2000153c:	f644 3394 	movw	r3, #19348	; 0x4b94
20001540:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001544:	429a      	cmp	r2, r3
20001546:	d007      	beq.n	20001558 <MSS_SPI_set_frame_rx_handler+0x28>
20001548:	687a      	ldr	r2, [r7, #4]
2000154a:	f644 3310 	movw	r3, #19216	; 0x4b10
2000154e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001552:	429a      	cmp	r2, r3
20001554:	d000      	beq.n	20001558 <MSS_SPI_set_frame_rx_handler+0x28>
20001556:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI slave. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) != CTRL_MASTER_MASK);
20001558:	687b      	ldr	r3, [r7, #4]
2000155a:	681b      	ldr	r3, [r3, #0]
2000155c:	681b      	ldr	r3, [r3, #0]
2000155e:	f003 0302 	and.w	r3, r3, #2
20001562:	2b00      	cmp	r3, #0
20001564:	d000      	beq.n	20001568 <MSS_SPI_set_frame_rx_handler+0x38>
20001566:	be00      	bkpt	0x0000
    
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20001568:	687b      	ldr	r3, [r7, #4]
2000156a:	791b      	ldrb	r3, [r3, #4]
2000156c:	b25b      	sxtb	r3, r3
2000156e:	4618      	mov	r0, r3
20001570:	f7ff fb08 	bl	20000b84 <NVIC_DisableIRQ>

    /* Disable block Rx handlers as they are mutually exclusive. */
    this_spi->block_rx_handler = 0u;
20001574:	687b      	ldr	r3, [r7, #4]
20001576:	f04f 0200 	mov.w	r2, #0
2000157a:	67da      	str	r2, [r3, #124]	; 0x7c
    this_spi->cmd_handler = 0u;
2000157c:	687b      	ldr	r3, [r7, #4]
2000157e:	f04f 0200 	mov.w	r2, #0
20001582:	621a      	str	r2, [r3, #32]
    
    /* Keep a copy of the pointer to the rx handler function. */
    this_spi->frame_rx_handler = rx_handler;
20001584:	687b      	ldr	r3, [r7, #4]
20001586:	683a      	ldr	r2, [r7, #0]
20001588:	675a      	str	r2, [r3, #116]	; 0x74
    
    /* Make sure correct mode is selected */
    this_spi->slave_xfer_mode = MSS_SPI_SLAVE_XFER_FRAME;
2000158a:	687b      	ldr	r3, [r7, #4]
2000158c:	f04f 0202 	mov.w	r2, #2
20001590:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Automatically fill the TX FIFO with zeroes if no slave tx frame set.*/
    tx_fifo_empty = this_spi->hw_reg->STATUS & TX_FIFO_EMPTY_MASK;
20001594:	687b      	ldr	r3, [r7, #4]
20001596:	681b      	ldr	r3, [r3, #0]
20001598:	689b      	ldr	r3, [r3, #8]
2000159a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2000159e:	60fb      	str	r3, [r7, #12]
    if(tx_fifo_empty)
200015a0:	68fb      	ldr	r3, [r7, #12]
200015a2:	2b00      	cmp	r3, #0
200015a4:	d007      	beq.n	200015b6 <MSS_SPI_set_frame_rx_handler+0x86>
    {
        this_spi->hw_reg->COMMAND |= AUTOFILL_MASK;
200015a6:	687b      	ldr	r3, [r7, #4]
200015a8:	681b      	ldr	r3, [r3, #0]
200015aa:	687a      	ldr	r2, [r7, #4]
200015ac:	6812      	ldr	r2, [r2, #0]
200015ae:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
200015b0:	f042 0201 	orr.w	r2, r2, #1
200015b4:	62da      	str	r2, [r3, #44]	; 0x2c
    }
    
    /* Ensure single frame transfer selected so interrupts work correctly */
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK)
200015b6:	687b      	ldr	r3, [r7, #4]
200015b8:	681a      	ldr	r2, [r3, #0]
200015ba:	687b      	ldr	r3, [r7, #4]
200015bc:	681b      	ldr	r3, [r3, #0]
200015be:	6819      	ldr	r1, [r3, #0]
200015c0:	f240 03ff 	movw	r3, #255	; 0xff
200015c4:	f6cf 7300 	movt	r3, #65280	; 0xff00
200015c8:	ea01 0303 	and.w	r3, r1, r3
200015cc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
200015d0:	6013      	str	r3, [r2, #0]
                                | ((uint32_t)1u << TXRXDFCOUNT_SHIFT);

    /* Disable block specific interrupts */
    this_spi->hw_reg->CONTROL2 &= ~(uint32_t)C2_ENABLE_CMD_IRQ_MASK;
200015d2:	687b      	ldr	r3, [r7, #4]
200015d4:	681b      	ldr	r3, [r3, #0]
200015d6:	687a      	ldr	r2, [r7, #4]
200015d8:	6812      	ldr	r2, [r2, #0]
200015da:	6a92      	ldr	r2, [r2, #40]	; 0x28
200015dc:	f022 0210 	bic.w	r2, r2, #16
200015e0:	629a      	str	r2, [r3, #40]	; 0x28
    this_spi->hw_reg->CONTROL2 &= ~(uint32_t)C2_ENABLE_SSEND_IRQ_MASK;
200015e2:	687b      	ldr	r3, [r7, #4]
200015e4:	681b      	ldr	r3, [r3, #0]
200015e6:	687a      	ldr	r2, [r7, #4]
200015e8:	6812      	ldr	r2, [r2, #0]
200015ea:	6a92      	ldr	r2, [r2, #40]	; 0x28
200015ec:	f022 0220 	bic.w	r2, r2, #32
200015f0:	629a      	str	r2, [r3, #40]	; 0x28

    /* Clear down ints to avoid stale ints triggering when we enable them below */
    this_spi->hw_reg->INT_CLEAR = TXURUN_IRQ_MASK | RXOVFLOW_IRQ_MASK |
200015f2:	687b      	ldr	r3, [r7, #4]
200015f4:	681b      	ldr	r3, [r3, #0]
200015f6:	f04f 020e 	mov.w	r2, #14
200015fa:	60da      	str	r2, [r3, #12]
                                  RXDONE_IRQ_MASK;
    /*
     * Enable TX underrun and RX overflow interrupts to improve error
     * recovery and the Rx interrupt.
     */
    this_spi->hw_reg->CONTROL |= CTRL_URUN_IRQ_EN_MASK | CTRL_OVFLOW_IRQ_EN_MASK |
200015fc:	687b      	ldr	r3, [r7, #4]
200015fe:	681b      	ldr	r3, [r3, #0]
20001600:	687a      	ldr	r2, [r7, #4]
20001602:	6812      	ldr	r2, [r2, #0]
20001604:	6812      	ldr	r2, [r2, #0]
20001606:	f042 02d0 	orr.w	r2, r2, #208	; 0xd0
2000160a:	601a      	str	r2, [r3, #0]
                                 CTRL_RX_IRQ_EN_MASK;
    NVIC_EnableIRQ( this_spi->irqn );
2000160c:	687b      	ldr	r3, [r7, #4]
2000160e:	791b      	ldrb	r3, [r3, #4]
20001610:	b25b      	sxtb	r3, r3
20001612:	4618      	mov	r0, r3
20001614:	f7ff fa9a 	bl	20000b4c <NVIC_EnableIRQ>
}
20001618:	f107 0710 	add.w	r7, r7, #16
2000161c:	46bd      	mov	sp, r7
2000161e:	bd80      	pop	{r7, pc}

20001620 <MSS_SPI_set_slave_tx_frame>:
void MSS_SPI_set_slave_tx_frame
(
    mss_spi_instance_t * this_spi,
    uint32_t frame_value
)
{
20001620:	b580      	push	{r7, lr}
20001622:	b082      	sub	sp, #8
20001624:	af00      	add	r7, sp, #0
20001626:	6078      	str	r0, [r7, #4]
20001628:	6039      	str	r1, [r7, #0]
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
2000162a:	687a      	ldr	r2, [r7, #4]
2000162c:	f644 3394 	movw	r3, #19348	; 0x4b94
20001630:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001634:	429a      	cmp	r2, r3
20001636:	d007      	beq.n	20001648 <MSS_SPI_set_slave_tx_frame+0x28>
20001638:	687a      	ldr	r2, [r7, #4]
2000163a:	f644 3310 	movw	r3, #19216	; 0x4b10
2000163e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001642:	429a      	cmp	r2, r3
20001644:	d000      	beq.n	20001648 <MSS_SPI_set_slave_tx_frame+0x28>
20001646:	be00      	bkpt	0x0000

    /* This function is only intended to be used with an SPI slave. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) != CTRL_MASTER_MASK);
20001648:	687b      	ldr	r3, [r7, #4]
2000164a:	681b      	ldr	r3, [r3, #0]
2000164c:	681b      	ldr	r3, [r3, #0]
2000164e:	f003 0302 	and.w	r3, r3, #2
20001652:	2b00      	cmp	r3, #0
20001654:	d000      	beq.n	20001658 <MSS_SPI_set_slave_tx_frame+0x38>
20001656:	be00      	bkpt	0x0000
    
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20001658:	687b      	ldr	r3, [r7, #4]
2000165a:	791b      	ldrb	r3, [r3, #4]
2000165c:	b25b      	sxtb	r3, r3
2000165e:	4618      	mov	r0, r3
20001660:	f7ff fa90 	bl	20000b84 <NVIC_DisableIRQ>

    /* Make sure correct mode is selected */
    this_spi->slave_xfer_mode = MSS_SPI_SLAVE_XFER_FRAME;
20001664:	687b      	ldr	r3, [r7, #4]
20001666:	f04f 0202 	mov.w	r2, #2
2000166a:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Disable block Rx handlers as they are mutually exclusive. */
    this_spi->block_rx_handler = 0u;
2000166e:	687b      	ldr	r3, [r7, #4]
20001670:	f04f 0200 	mov.w	r2, #0
20001674:	67da      	str	r2, [r3, #124]	; 0x7c
    this_spi->cmd_handler = 0u;
20001676:	687b      	ldr	r3, [r7, #4]
20001678:	f04f 0200 	mov.w	r2, #0
2000167c:	621a      	str	r2, [r3, #32]

    /* Disable slave block tx buffer as it is mutually exclusive with frame
     * level handling. */    
    this_spi->slave_tx_buffer = 0u;
2000167e:	687b      	ldr	r3, [r7, #4]
20001680:	f04f 0200 	mov.w	r2, #0
20001684:	609a      	str	r2, [r3, #8]
    this_spi->slave_tx_size = 0u;
20001686:	687b      	ldr	r3, [r7, #4]
20001688:	f04f 0200 	mov.w	r2, #0
2000168c:	60da      	str	r2, [r3, #12]
    this_spi->slave_tx_idx = 0u;
2000168e:	687b      	ldr	r3, [r7, #4]
20001690:	f04f 0200 	mov.w	r2, #0
20001694:	611a      	str	r2, [r3, #16]
    
    /* Keep a copy of the slave tx frame value. */
    this_spi->slave_tx_frame = frame_value;
20001696:	687b      	ldr	r3, [r7, #4]
20001698:	683a      	ldr	r2, [r7, #0]
2000169a:	679a      	str	r2, [r3, #120]	; 0x78
    
    /* Disable automatic fill of the TX FIFO with zeroes.*/
    this_spi->hw_reg->COMMAND &= ~(uint32_t)AUTOFILL_MASK;
2000169c:	687b      	ldr	r3, [r7, #4]
2000169e:	681b      	ldr	r3, [r3, #0]
200016a0:	687a      	ldr	r2, [r7, #4]
200016a2:	6812      	ldr	r2, [r2, #0]
200016a4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
200016a6:	f022 0201 	bic.w	r2, r2, #1
200016aa:	62da      	str	r2, [r3, #44]	; 0x2c
    this_spi->hw_reg->COMMAND |= TX_FIFO_RESET_MASK;
200016ac:	687b      	ldr	r3, [r7, #4]
200016ae:	681b      	ldr	r3, [r3, #0]
200016b0:	687a      	ldr	r2, [r7, #4]
200016b2:	6812      	ldr	r2, [r2, #0]
200016b4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
200016b6:	f042 0208 	orr.w	r2, r2, #8
200016ba:	62da      	str	r2, [r3, #44]	; 0x2c
     *
     * IMPORTANT: Note this must be done before writing to the TX_DATA register
     * as it seems that doing these in the opposite order causes the receive
     * and transmit interrupts to be disabled.
     */
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK)
200016bc:	687b      	ldr	r3, [r7, #4]
200016be:	681a      	ldr	r2, [r3, #0]
200016c0:	687b      	ldr	r3, [r7, #4]
200016c2:	681b      	ldr	r3, [r3, #0]
200016c4:	6819      	ldr	r1, [r3, #0]
200016c6:	f240 03ff 	movw	r3, #255	; 0xff
200016ca:	f6cf 7300 	movt	r3, #65280	; 0xff00
200016ce:	ea01 0303 	and.w	r3, r1, r3
200016d2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
200016d6:	6013      	str	r3, [r2, #0]
                                | ((uint32_t)1u << TXRXDFCOUNT_SHIFT);

    /* Load frame into Tx data register. */
    this_spi->hw_reg->TX_DATA = this_spi->slave_tx_frame;
200016d8:	687b      	ldr	r3, [r7, #4]
200016da:	681b      	ldr	r3, [r3, #0]
200016dc:	687a      	ldr	r2, [r7, #4]
200016de:	6f92      	ldr	r2, [r2, #120]	; 0x78
200016e0:	615a      	str	r2, [r3, #20]

   /* Disable block specific interrupts */
    this_spi->hw_reg->CONTROL2 &= ~(uint32_t)C2_ENABLE_CMD_IRQ_MASK;
200016e2:	687b      	ldr	r3, [r7, #4]
200016e4:	681b      	ldr	r3, [r3, #0]
200016e6:	687a      	ldr	r2, [r7, #4]
200016e8:	6812      	ldr	r2, [r2, #0]
200016ea:	6a92      	ldr	r2, [r2, #40]	; 0x28
200016ec:	f022 0210 	bic.w	r2, r2, #16
200016f0:	629a      	str	r2, [r3, #40]	; 0x28
    this_spi->hw_reg->CONTROL2 &= ~(uint32_t)C2_ENABLE_SSEND_IRQ_MASK;
200016f2:	687b      	ldr	r3, [r7, #4]
200016f4:	681b      	ldr	r3, [r3, #0]
200016f6:	687a      	ldr	r2, [r7, #4]
200016f8:	6812      	ldr	r2, [r2, #0]
200016fa:	6a92      	ldr	r2, [r2, #40]	; 0x28
200016fc:	f022 0220 	bic.w	r2, r2, #32
20001700:	629a      	str	r2, [r3, #40]	; 0x28

    /* Clear down ints to avoid stale ints triggering when we enable them below */
    this_spi->hw_reg->INT_CLEAR = TXURUN_IRQ_MASK | RXOVFLOW_IRQ_MASK |
20001702:	687b      	ldr	r3, [r7, #4]
20001704:	681b      	ldr	r3, [r3, #0]
20001706:	f04f 020d 	mov.w	r2, #13
2000170a:	60da      	str	r2, [r3, #12]
     * time it has been sent.
     *
     * Enable TX underrun and RX overflow interrupts to improve error
     * recovery.
     */
    this_spi->hw_reg->CONTROL |= CTRL_TX_IRQ_EN_MASK | CTRL_URUN_IRQ_EN_MASK |
2000170c:	687b      	ldr	r3, [r7, #4]
2000170e:	681b      	ldr	r3, [r3, #0]
20001710:	687a      	ldr	r2, [r7, #4]
20001712:	6812      	ldr	r2, [r2, #0]
20001714:	6812      	ldr	r2, [r2, #0]
20001716:	f042 02e0 	orr.w	r2, r2, #224	; 0xe0
2000171a:	601a      	str	r2, [r3, #0]
                                 CTRL_OVFLOW_IRQ_EN_MASK;

    NVIC_EnableIRQ( this_spi->irqn );
2000171c:	687b      	ldr	r3, [r7, #4]
2000171e:	791b      	ldrb	r3, [r3, #4]
20001720:	b25b      	sxtb	r3, r3
20001722:	4618      	mov	r0, r3
20001724:	f7ff fa12 	bl	20000b4c <NVIC_EnableIRQ>
}
20001728:	f107 0708 	add.w	r7, r7, #8
2000172c:	46bd      	mov	sp, r7
2000172e:	bd80      	pop	{r7, pc}

20001730 <MSS_SPI_set_slave_block_buffers>:
    uint32_t tx_buff_size,
    uint8_t * rx_buffer,
    uint32_t rx_buff_size,
    mss_spi_block_rx_handler_t block_rx_handler
)
{
20001730:	b580      	push	{r7, lr}
20001732:	b088      	sub	sp, #32
20001734:	af00      	add	r7, sp, #0
20001736:	60f8      	str	r0, [r7, #12]
20001738:	60b9      	str	r1, [r7, #8]
2000173a:	607a      	str	r2, [r7, #4]
2000173c:	603b      	str	r3, [r7, #0]
    uint32_t frame_count;
    uint32_t done = 0u;
2000173e:	f04f 0300 	mov.w	r3, #0
20001742:	61fb      	str	r3, [r7, #28]
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20001744:	68fa      	ldr	r2, [r7, #12]
20001746:	f644 3394 	movw	r3, #19348	; 0x4b94
2000174a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000174e:	429a      	cmp	r2, r3
20001750:	d007      	beq.n	20001762 <MSS_SPI_set_slave_block_buffers+0x32>
20001752:	68fa      	ldr	r2, [r7, #12]
20001754:	f644 3310 	movw	r3, #19216	; 0x4b10
20001758:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000175c:	429a      	cmp	r2, r3
2000175e:	d000      	beq.n	20001762 <MSS_SPI_set_slave_block_buffers+0x32>
20001760:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI slave. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) != CTRL_MASTER_MASK);
20001762:	68fb      	ldr	r3, [r7, #12]
20001764:	681b      	ldr	r3, [r3, #0]
20001766:	681b      	ldr	r3, [r3, #0]
20001768:	f003 0302 	and.w	r3, r3, #2
2000176c:	2b00      	cmp	r3, #0
2000176e:	d000      	beq.n	20001772 <MSS_SPI_set_slave_block_buffers+0x42>
20001770:	be00      	bkpt	0x0000
    
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20001772:	68fb      	ldr	r3, [r7, #12]
20001774:	791b      	ldrb	r3, [r3, #4]
20001776:	b25b      	sxtb	r3, r3
20001778:	4618      	mov	r0, r3
2000177a:	f7ff fa03 	bl	20000b84 <NVIC_DisableIRQ>

    /* Make sure correct mode is selected */
    this_spi->slave_xfer_mode = MSS_SPI_SLAVE_XFER_BLOCK;
2000177e:	68fb      	ldr	r3, [r7, #12]
20001780:	f04f 0201 	mov.w	r2, #1
20001784:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Set cmd_done correctly to ensure 0 padding works. */
    if(0u == this_spi->cmd_handler)
20001788:	68fb      	ldr	r3, [r7, #12]
2000178a:	6a1b      	ldr	r3, [r3, #32]
2000178c:	2b00      	cmp	r3, #0
2000178e:	d104      	bne.n	2000179a <MSS_SPI_set_slave_block_buffers+0x6a>
    {
        this_spi->cmd_done = 1u;
20001790:	68fb      	ldr	r3, [r7, #12]
20001792:	f04f 0201 	mov.w	r2, #1
20001796:	625a      	str	r2, [r3, #36]	; 0x24
20001798:	e003      	b.n	200017a2 <MSS_SPI_set_slave_block_buffers+0x72>
    }
    else
    {
        this_spi->cmd_done = 0u;
2000179a:	68fb      	ldr	r3, [r7, #12]
2000179c:	f04f 0200 	mov.w	r2, #0
200017a0:	625a      	str	r2, [r3, #36]	; 0x24
    }

    /* Disable Rx frame handler as it is mutually exclusive with block rx handler. */
    this_spi->frame_rx_handler = 0u;
200017a2:	68fb      	ldr	r3, [r7, #12]
200017a4:	f04f 0200 	mov.w	r2, #0
200017a8:	675a      	str	r2, [r3, #116]	; 0x74
    
    /* Keep a copy of the pointer to the block rx handler function. */
    this_spi->block_rx_handler = block_rx_handler;
200017aa:	68fb      	ldr	r3, [r7, #12]
200017ac:	6afa      	ldr	r2, [r7, #44]	; 0x2c
200017ae:	67da      	str	r2, [r3, #124]	; 0x7c
    
    this_spi->slave_rx_buffer = rx_buffer;
200017b0:	68fb      	ldr	r3, [r7, #12]
200017b2:	683a      	ldr	r2, [r7, #0]
200017b4:	629a      	str	r2, [r3, #40]	; 0x28
    this_spi->slave_rx_size = rx_buff_size;
200017b6:	68fb      	ldr	r3, [r7, #12]
200017b8:	6aba      	ldr	r2, [r7, #40]	; 0x28
200017ba:	62da      	str	r2, [r3, #44]	; 0x2c
    this_spi->slave_rx_idx = 0u;
200017bc:	68fb      	ldr	r3, [r7, #12]
200017be:	f04f 0200 	mov.w	r2, #0
200017c2:	631a      	str	r2, [r3, #48]	; 0x30
    
    /* Initialise the transmit state data. */
    this_spi->slave_tx_buffer = tx_buffer;
200017c4:	68fb      	ldr	r3, [r7, #12]
200017c6:	68ba      	ldr	r2, [r7, #8]
200017c8:	609a      	str	r2, [r3, #8]
    this_spi->slave_tx_size = tx_buff_size;
200017ca:	68fb      	ldr	r3, [r7, #12]
200017cc:	687a      	ldr	r2, [r7, #4]
200017ce:	60da      	str	r2, [r3, #12]
    this_spi->slave_tx_idx = 0u;
200017d0:	68fb      	ldr	r3, [r7, #12]
200017d2:	f04f 0200 	mov.w	r2, #0
200017d6:	611a      	str	r2, [r3, #16]

    /* Flush the Tx and Rx FIFOs. Please note this does not have any effect on A2F200. */
    this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
200017d8:	68fb      	ldr	r3, [r7, #12]
200017da:	681b      	ldr	r3, [r3, #0]
200017dc:	68fa      	ldr	r2, [r7, #12]
200017de:	6812      	ldr	r2, [r2, #0]
200017e0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
200017e2:	f042 020c 	orr.w	r2, r2, #12
200017e6:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Recover from receive overflow if needs be */
    if(0u != (this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK))
200017e8:	68fb      	ldr	r3, [r7, #12]
200017ea:	681b      	ldr	r3, [r3, #0]
200017ec:	689b      	ldr	r3, [r3, #8]
200017ee:	f003 0304 	and.w	r3, r3, #4
200017f2:	2b00      	cmp	r3, #0
200017f4:	d00a      	beq.n	2000180c <MSS_SPI_set_slave_block_buffers+0xdc>
    {
         recover_from_rx_overflow(this_spi);
200017f6:	68f8      	ldr	r0, [r7, #12]
200017f8:	f7ff fa9a 	bl	20000d30 <recover_from_rx_overflow>
    }

    /* Flush Rx FIFO in case we are executing on A2F200. */
    while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
200017fc:	e007      	b.n	2000180e <MSS_SPI_set_slave_block_buffers+0xde>
    {
        volatile uint32_t dummy;
        dummy = this_spi->hw_reg->RX_DATA;
200017fe:	68fb      	ldr	r3, [r7, #12]
20001800:	681b      	ldr	r3, [r3, #0]
20001802:	691b      	ldr	r3, [r3, #16]
20001804:	617b      	str	r3, [r7, #20]
        dummy = dummy;  /* Prevent Lint warning. */
20001806:	697b      	ldr	r3, [r7, #20]
20001808:	617b      	str	r3, [r7, #20]
2000180a:	e000      	b.n	2000180e <MSS_SPI_set_slave_block_buffers+0xde>
    {
         recover_from_rx_overflow(this_spi);
    }

    /* Flush Rx FIFO in case we are executing on A2F200. */
    while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
2000180c:	bf00      	nop
2000180e:	68fb      	ldr	r3, [r7, #12]
20001810:	681b      	ldr	r3, [r3, #0]
20001812:	689b      	ldr	r3, [r3, #8]
20001814:	f003 0340 	and.w	r3, r3, #64	; 0x40
20001818:	2b00      	cmp	r3, #0
2000181a:	d0f0      	beq.n	200017fe <MSS_SPI_set_slave_block_buffers+0xce>
        dummy = this_spi->hw_reg->RX_DATA;
        dummy = dummy;  /* Prevent Lint warning. */
    }

    /* Use the frame counter to control how often receive interrupts are generated. */
    frame_count = RX_IRQ_THRESHOLD;
2000181c:	f04f 0310 	mov.w	r3, #16
20001820:	61bb      	str	r3, [r7, #24]
    
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
20001822:	68fb      	ldr	r3, [r7, #12]
20001824:	681b      	ldr	r3, [r3, #0]
20001826:	68fa      	ldr	r2, [r7, #12]
20001828:	6812      	ldr	r2, [r2, #0]
2000182a:	6812      	ldr	r2, [r2, #0]
2000182c:	f022 0201 	bic.w	r2, r2, #1
20001830:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK) |
20001832:	68fb      	ldr	r3, [r7, #12]
20001834:	681a      	ldr	r2, [r3, #0]
20001836:	68fb      	ldr	r3, [r7, #12]
20001838:	681b      	ldr	r3, [r3, #0]
2000183a:	6819      	ldr	r1, [r3, #0]
2000183c:	f240 03ff 	movw	r3, #255	; 0xff
20001840:	f6cf 7300 	movt	r3, #65280	; 0xff00
20001844:	ea01 0303 	and.w	r3, r1, r3
                                (frame_count << TXRXDFCOUNT_SHIFT);
20001848:	69b9      	ldr	r1, [r7, #24]
2000184a:	ea4f 2101 	mov.w	r1, r1, lsl #8

    /* Use the frame counter to control how often receive interrupts are generated. */
    frame_count = RX_IRQ_THRESHOLD;
    
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK) |
2000184e:	ea43 0301 	orr.w	r3, r3, r1
20001852:	6013      	str	r3, [r2, #0]
                                (frame_count << TXRXDFCOUNT_SHIFT);
    this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
20001854:	68fb      	ldr	r3, [r7, #12]
20001856:	681b      	ldr	r3, [r3, #0]
20001858:	f04f 0208 	mov.w	r2, #8
2000185c:	605a      	str	r2, [r3, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
2000185e:	68fb      	ldr	r3, [r7, #12]
20001860:	681b      	ldr	r3, [r3, #0]
20001862:	68fa      	ldr	r2, [r7, #12]
20001864:	6812      	ldr	r2, [r2, #0]
20001866:	6812      	ldr	r2, [r2, #0]
20001868:	f042 0201 	orr.w	r2, r2, #1
2000186c:	601a      	str	r2, [r3, #0]
    
    /* Load the transmit FIFO. */
    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) && (0u == done))
2000186e:	e022      	b.n	200018b6 <MSS_SPI_set_slave_block_buffers+0x186>
    {
        if(this_spi->slave_tx_idx < this_spi->slave_tx_size)
20001870:	68fb      	ldr	r3, [r7, #12]
20001872:	691a      	ldr	r2, [r3, #16]
20001874:	68fb      	ldr	r3, [r7, #12]
20001876:	68db      	ldr	r3, [r3, #12]
20001878:	429a      	cmp	r2, r3
2000187a:	d209      	bcs.n	20001890 <MSS_SPI_set_slave_block_buffers+0x160>
        {
            this_spi->hw_reg->TX_DATA = this_spi->slave_tx_buffer[this_spi->slave_tx_idx];
2000187c:	68fb      	ldr	r3, [r7, #12]
2000187e:	681b      	ldr	r3, [r3, #0]
20001880:	68fa      	ldr	r2, [r7, #12]
20001882:	6891      	ldr	r1, [r2, #8]
20001884:	68fa      	ldr	r2, [r7, #12]
20001886:	6912      	ldr	r2, [r2, #16]
20001888:	440a      	add	r2, r1
2000188a:	7812      	ldrb	r2, [r2, #0]
2000188c:	615a      	str	r2, [r3, #20]
2000188e:	e00c      	b.n	200018aa <MSS_SPI_set_slave_block_buffers+0x17a>
        }
        else if(0u != this_spi->cmd_done)
20001890:	68fb      	ldr	r3, [r7, #12]
20001892:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20001894:	2b00      	cmp	r3, #0
20001896:	d005      	beq.n	200018a4 <MSS_SPI_set_slave_block_buffers+0x174>
        {
            /* Fill with 0s if no need to insert command response */
            this_spi->hw_reg->TX_DATA = 0x00u;
20001898:	68fb      	ldr	r3, [r7, #12]
2000189a:	681b      	ldr	r3, [r3, #0]
2000189c:	f04f 0200 	mov.w	r2, #0
200018a0:	615a      	str	r2, [r3, #20]
200018a2:	e002      	b.n	200018aa <MSS_SPI_set_slave_block_buffers+0x17a>
        }
        else
        {
            /* Exit loop early as command response needs to be inserted next */
            done = 1u;
200018a4:	f04f 0301 	mov.w	r3, #1
200018a8:	61fb      	str	r3, [r7, #28]
        }
        ++this_spi->slave_tx_idx;
200018aa:	68fb      	ldr	r3, [r7, #12]
200018ac:	691b      	ldr	r3, [r3, #16]
200018ae:	f103 0201 	add.w	r2, r3, #1
200018b2:	68fb      	ldr	r3, [r7, #12]
200018b4:	611a      	str	r2, [r3, #16]
                                (frame_count << TXRXDFCOUNT_SHIFT);
    this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
    
    /* Load the transmit FIFO. */
    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) && (0u == done))
200018b6:	68fb      	ldr	r3, [r7, #12]
200018b8:	681b      	ldr	r3, [r3, #0]
200018ba:	689b      	ldr	r3, [r3, #8]
200018bc:	f403 7380 	and.w	r3, r3, #256	; 0x100
200018c0:	2b00      	cmp	r3, #0
200018c2:	d102      	bne.n	200018ca <MSS_SPI_set_slave_block_buffers+0x19a>
200018c4:	69fb      	ldr	r3, [r7, #28]
200018c6:	2b00      	cmp	r3, #0
200018c8:	d0d2      	beq.n	20001870 <MSS_SPI_set_slave_block_buffers+0x140>
            done = 1u;
        }
        ++this_spi->slave_tx_idx;
    }

    if(tx_buff_size > 0u)
200018ca:	687b      	ldr	r3, [r7, #4]
200018cc:	2b00      	cmp	r3, #0
200018ce:	d015      	beq.n	200018fc <MSS_SPI_set_slave_block_buffers+0x1cc>
    {
        /* Clear and enable TX interrupt. Also disable autofill */
        this_spi->hw_reg->COMMAND &= ~(uint32_t)AUTOFILL_MASK;
200018d0:	68fb      	ldr	r3, [r7, #12]
200018d2:	681b      	ldr	r3, [r3, #0]
200018d4:	68fa      	ldr	r2, [r7, #12]
200018d6:	6812      	ldr	r2, [r2, #0]
200018d8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
200018da:	f022 0201 	bic.w	r2, r2, #1
200018de:	62da      	str	r2, [r3, #44]	; 0x2c
        this_spi->hw_reg->INT_CLEAR = TXDONE_IRQ_MASK;
200018e0:	68fb      	ldr	r3, [r7, #12]
200018e2:	681b      	ldr	r3, [r3, #0]
200018e4:	f04f 0201 	mov.w	r2, #1
200018e8:	60da      	str	r2, [r3, #12]
        this_spi->hw_reg->CONTROL |= CTRL_TX_IRQ_EN_MASK;
200018ea:	68fb      	ldr	r3, [r7, #12]
200018ec:	681b      	ldr	r3, [r3, #0]
200018ee:	68fa      	ldr	r2, [r7, #12]
200018f0:	6812      	ldr	r2, [r2, #0]
200018f2:	6812      	ldr	r2, [r2, #0]
200018f4:	f042 0220 	orr.w	r2, r2, #32
200018f8:	601a      	str	r2, [r3, #0]
200018fa:	e007      	b.n	2000190c <MSS_SPI_set_slave_block_buffers+0x1dc>
    }
    else
    {
        this_spi->hw_reg->COMMAND |= AUTOFILL_MASK;
200018fc:	68fb      	ldr	r3, [r7, #12]
200018fe:	681b      	ldr	r3, [r3, #0]
20001900:	68fa      	ldr	r2, [r7, #12]
20001902:	6812      	ldr	r2, [r2, #0]
20001904:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20001906:	f042 0201 	orr.w	r2, r2, #1
2000190a:	62da      	str	r2, [r3, #44]	; 0x2c
    }
    
    /* Ensure command interrupt disabled if no handler */
    if(0u == this_spi->cmd_handler)
2000190c:	68fb      	ldr	r3, [r7, #12]
2000190e:	6a1b      	ldr	r3, [r3, #32]
20001910:	2b00      	cmp	r3, #0
20001912:	d107      	bne.n	20001924 <MSS_SPI_set_slave_block_buffers+0x1f4>
    {
        this_spi->hw_reg->CONTROL2 &= ~(uint32_t)C2_ENABLE_CMD_IRQ_MASK;
20001914:	68fb      	ldr	r3, [r7, #12]
20001916:	681b      	ldr	r3, [r3, #0]
20001918:	68fa      	ldr	r2, [r7, #12]
2000191a:	6812      	ldr	r2, [r2, #0]
2000191c:	6a92      	ldr	r2, [r2, #40]	; 0x28
2000191e:	f022 0210 	bic.w	r2, r2, #16
20001922:	629a      	str	r2, [r3, #40]	; 0x28
     * the next transaction.
     *
     * Make sure to clear any pending ssend ints otherwise we will trigger
     * an immediate interrupt.
     */
    this_spi->hw_reg->INT_CLEAR = SSEND_IRQ_MASK;
20001924:	68fb      	ldr	r3, [r7, #12]
20001926:	681b      	ldr	r3, [r3, #0]
20001928:	f04f 0220 	mov.w	r2, #32
2000192c:	60da      	str	r2, [r3, #12]
    this_spi->hw_reg->CONTROL2 |= C2_ENABLE_SSEND_IRQ_MASK;
2000192e:	68fb      	ldr	r3, [r7, #12]
20001930:	681b      	ldr	r3, [r3, #0]
20001932:	68fa      	ldr	r2, [r7, #12]
20001934:	6812      	ldr	r2, [r2, #0]
20001936:	6a92      	ldr	r2, [r2, #40]	; 0x28
20001938:	f042 0220 	orr.w	r2, r2, #32
2000193c:	629a      	str	r2, [r3, #40]	; 0x28
    
    /* Clear down ints to avoid stale ints triggering when we enable them below */
    this_spi->hw_reg->INT_CLEAR = TXURUN_IRQ_MASK | RXOVFLOW_IRQ_MASK |
2000193e:	68fb      	ldr	r3, [r7, #12]
20001940:	681b      	ldr	r3, [r3, #0]
20001942:	f04f 020e 	mov.w	r2, #14
20001946:	60da      	str	r2, [r3, #12]
                                  RXDONE_IRQ_MASK;
    /*
     * Enable TX underrun and RX overflow interrupts to improve error
     * recovery and enable Rx interrupt.
     */
    this_spi->hw_reg->CONTROL |= CTRL_RX_IRQ_EN_MASK | CTRL_URUN_IRQ_EN_MASK |
20001948:	68fb      	ldr	r3, [r7, #12]
2000194a:	681b      	ldr	r3, [r3, #0]
2000194c:	68fa      	ldr	r2, [r7, #12]
2000194e:	6812      	ldr	r2, [r2, #0]
20001950:	6812      	ldr	r2, [r2, #0]
20001952:	f042 02d0 	orr.w	r2, r2, #208	; 0xd0
20001956:	601a      	str	r2, [r3, #0]
                                 CTRL_OVFLOW_IRQ_EN_MASK;

    NVIC_EnableIRQ(this_spi->irqn);
20001958:	68fb      	ldr	r3, [r7, #12]
2000195a:	791b      	ldrb	r3, [r3, #4]
2000195c:	b25b      	sxtb	r3, r3
2000195e:	4618      	mov	r0, r3
20001960:	f7ff f8f4 	bl	20000b4c <NVIC_EnableIRQ>
}
20001964:	f107 0720 	add.w	r7, r7, #32
20001968:	46bd      	mov	sp, r7
2000196a:	bd80      	pop	{r7, pc}

2000196c <MSS_SPI_set_cmd_handler>:
(
    mss_spi_instance_t * this_spi,
    mss_spi_block_rx_handler_t cmd_handler,
    uint32_t cmd_size
)
{
2000196c:	b580      	push	{r7, lr}
2000196e:	b084      	sub	sp, #16
20001970:	af00      	add	r7, sp, #0
20001972:	60f8      	str	r0, [r7, #12]
20001974:	60b9      	str	r1, [r7, #8]
20001976:	607a      	str	r2, [r7, #4]
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20001978:	68fb      	ldr	r3, [r7, #12]
2000197a:	791b      	ldrb	r3, [r3, #4]
2000197c:	b25b      	sxtb	r3, r3
2000197e:	4618      	mov	r0, r3
20001980:	f7ff f900 	bl	20000b84 <NVIC_DisableIRQ>

    /* Make sure response state is cleared down */
    this_spi->resp_tx_buffer   = 0u;
20001984:	68fb      	ldr	r3, [r7, #12]
20001986:	f04f 0200 	mov.w	r2, #0
2000198a:	615a      	str	r2, [r3, #20]
    this_spi->resp_buff_size   = 0u;
2000198c:	68fb      	ldr	r3, [r7, #12]
2000198e:	f04f 0200 	mov.w	r2, #0
20001992:	619a      	str	r2, [r3, #24]
    this_spi->resp_buff_tx_idx = 0u;
20001994:	68fb      	ldr	r3, [r7, #12]
20001996:	f04f 0200 	mov.w	r2, #0
2000199a:	61da      	str	r2, [r3, #28]
    
    if(0u == cmd_handler)
2000199c:	68bb      	ldr	r3, [r7, #8]
2000199e:	2b00      	cmp	r3, #0
200019a0:	d115      	bne.n	200019ce <MSS_SPI_set_cmd_handler+0x62>
    {
        /*
         * Set this flag so zero padding is enabled
         */
        this_spi->cmd_done = 1u;
200019a2:	68fb      	ldr	r3, [r7, #12]
200019a4:	f04f 0201 	mov.w	r2, #1
200019a8:	625a      	str	r2, [r3, #36]	; 0x24
        /*
         * Ensure command interrupt disabled if no handler 
         * and handler pointer is wiped clean.
         */
        this_spi->cmd_handler = 0u;
200019aa:	68fb      	ldr	r3, [r7, #12]
200019ac:	f04f 0200 	mov.w	r2, #0
200019b0:	621a      	str	r2, [r3, #32]
        this_spi->hw_reg->CMDSIZE = 0u;
200019b2:	68fb      	ldr	r3, [r7, #12]
200019b4:	681b      	ldr	r3, [r3, #0]
200019b6:	f04f 0200 	mov.w	r2, #0
200019ba:	635a      	str	r2, [r3, #52]	; 0x34
        this_spi->hw_reg->CONTROL2 &= ~(uint32_t)C2_ENABLE_CMD_IRQ_MASK;
200019bc:	68fb      	ldr	r3, [r7, #12]
200019be:	681b      	ldr	r3, [r3, #0]
200019c0:	68fa      	ldr	r2, [r7, #12]
200019c2:	6812      	ldr	r2, [r2, #0]
200019c4:	6a92      	ldr	r2, [r2, #40]	; 0x28
200019c6:	f022 0210 	bic.w	r2, r2, #16
200019ca:	629a      	str	r2, [r3, #40]	; 0x28
200019cc:	e026      	b.n	20001a1c <MSS_SPI_set_cmd_handler+0xb0>
    {
        /*
         * Clear this flag so zero padding is disabled until command response
         * has been taken care of.
         */
        this_spi->cmd_done = 0u;
200019ce:	68fb      	ldr	r3, [r7, #12]
200019d0:	f04f 0200 	mov.w	r2, #0
200019d4:	625a      	str	r2, [r3, #36]	; 0x24

        this_spi->cmd_handler = cmd_handler;
200019d6:	68fb      	ldr	r3, [r7, #12]
200019d8:	68ba      	ldr	r2, [r7, #8]
200019da:	621a      	str	r2, [r3, #32]
        this_spi->hw_reg->CMDSIZE = cmd_size;
200019dc:	68fb      	ldr	r3, [r7, #12]
200019de:	681b      	ldr	r3, [r3, #0]
200019e0:	687a      	ldr	r2, [r7, #4]
200019e2:	635a      	str	r2, [r3, #52]	; 0x34
        /* Flush the Tx FIFO. Please note this does not have any effect on A2F200. */
        this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
200019e4:	68fb      	ldr	r3, [r7, #12]
200019e6:	681b      	ldr	r3, [r3, #0]
200019e8:	68fa      	ldr	r2, [r7, #12]
200019ea:	6812      	ldr	r2, [r2, #0]
200019ec:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
200019ee:	f042 020c 	orr.w	r2, r2, #12
200019f2:	62da      	str	r2, [r3, #44]	; 0x2c
        /*
         * Reload TX FIFO as MSS_SPI_set_slave_block_buffers() may have zero filled
         * the FIFO if command handler was not in place when it was called and so 
         * the first frame sent could be wrong.
         */
        this_spi->slave_tx_idx    = 0u;
200019f4:	68fb      	ldr	r3, [r7, #12]
200019f6:	f04f 0200 	mov.w	r2, #0
200019fa:	611a      	str	r2, [r3, #16]
        fill_slave_tx_fifo(this_spi);
200019fc:	68f8      	ldr	r0, [r7, #12]
200019fe:	f000 f8bf 	bl	20001b80 <fill_slave_tx_fifo>
        /*
         * Make sure to clear any pending command ints otherwise we will trigger
         * an immediate interrupt.
         */
        this_spi->hw_reg->INT_CLEAR = CMD_IRQ_MASK;
20001a02:	68fb      	ldr	r3, [r7, #12]
20001a04:	681b      	ldr	r3, [r3, #0]
20001a06:	f04f 0210 	mov.w	r2, #16
20001a0a:	60da      	str	r2, [r3, #12]
        this_spi->hw_reg->CONTROL2 |= C2_ENABLE_CMD_IRQ_MASK;
20001a0c:	68fb      	ldr	r3, [r7, #12]
20001a0e:	681b      	ldr	r3, [r3, #0]
20001a10:	68fa      	ldr	r2, [r7, #12]
20001a12:	6812      	ldr	r2, [r2, #0]
20001a14:	6a92      	ldr	r2, [r2, #40]	; 0x28
20001a16:	f042 0210 	orr.w	r2, r2, #16
20001a1a:	629a      	str	r2, [r3, #40]	; 0x28
    }
    
    NVIC_EnableIRQ(this_spi->irqn); /* Safe to allow interrupts again */
20001a1c:	68fb      	ldr	r3, [r7, #12]
20001a1e:	791b      	ldrb	r3, [r3, #4]
20001a20:	b25b      	sxtb	r3, r3
20001a22:	4618      	mov	r0, r3
20001a24:	f7ff f892 	bl	20000b4c <NVIC_EnableIRQ>
}
20001a28:	f107 0710 	add.w	r7, r7, #16
20001a2c:	46bd      	mov	sp, r7
20001a2e:	bd80      	pop	{r7, pc}

20001a30 <MSS_SPI_set_cmd_response>:
(
    mss_spi_instance_t * this_spi,
    const uint8_t * resp_tx_buffer,
    uint32_t resp_buff_size
)
{
20001a30:	b580      	push	{r7, lr}
20001a32:	b084      	sub	sp, #16
20001a34:	af00      	add	r7, sp, #0
20001a36:	60f8      	str	r0, [r7, #12]
20001a38:	60b9      	str	r1, [r7, #8]
20001a3a:	607a      	str	r2, [r7, #4]
    this_spi->resp_tx_buffer = resp_tx_buffer;
20001a3c:	68fb      	ldr	r3, [r7, #12]
20001a3e:	68ba      	ldr	r2, [r7, #8]
20001a40:	615a      	str	r2, [r3, #20]
    this_spi->resp_buff_size = resp_buff_size;
20001a42:	68fb      	ldr	r3, [r7, #12]
20001a44:	687a      	ldr	r2, [r7, #4]
20001a46:	619a      	str	r2, [r3, #24]
    this_spi->resp_buff_tx_idx = 0u;
20001a48:	68fb      	ldr	r3, [r7, #12]
20001a4a:	f04f 0200 	mov.w	r2, #0
20001a4e:	61da      	str	r2, [r3, #28]
    /* Note that we have provided response and start getting it into the FIFO */
    this_spi->cmd_done = 1u;
20001a50:	68fb      	ldr	r3, [r7, #12]
20001a52:	f04f 0201 	mov.w	r2, #1
20001a56:	625a      	str	r2, [r3, #36]	; 0x24
    fill_slave_tx_fifo(this_spi);
20001a58:	68f8      	ldr	r0, [r7, #12]
20001a5a:	f000 f891 	bl	20001b80 <fill_slave_tx_fifo>
}
20001a5e:	f107 0710 	add.w	r7, r7, #16
20001a62:	46bd      	mov	sp, r7
20001a64:	bd80      	pop	{r7, pc}
20001a66:	bf00      	nop

20001a68 <MSS_SPI_enable>:
 */
void MSS_SPI_enable
(
    mss_spi_instance_t * this_spi
)
{
20001a68:	b580      	push	{r7, lr}
20001a6a:	b082      	sub	sp, #8
20001a6c:	af00      	add	r7, sp, #0
20001a6e:	6078      	str	r0, [r7, #4]
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20001a70:	687b      	ldr	r3, [r7, #4]
20001a72:	791b      	ldrb	r3, [r3, #4]
20001a74:	b25b      	sxtb	r3, r3
20001a76:	4618      	mov	r0, r3
20001a78:	f7ff f884 	bl	20000b84 <NVIC_DisableIRQ>

    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
20001a7c:	687b      	ldr	r3, [r7, #4]
20001a7e:	681b      	ldr	r3, [r3, #0]
20001a80:	687a      	ldr	r2, [r7, #4]
20001a82:	6812      	ldr	r2, [r2, #0]
20001a84:	6812      	ldr	r2, [r2, #0]
20001a86:	f042 0201 	orr.w	r2, r2, #1
20001a8a:	601a      	str	r2, [r3, #0]
    
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
20001a8c:	687b      	ldr	r3, [r7, #4]
20001a8e:	791b      	ldrb	r3, [r3, #4]
20001a90:	b25b      	sxtb	r3, r3
20001a92:	4618      	mov	r0, r3
20001a94:	f7ff f85a 	bl	20000b4c <NVIC_EnableIRQ>
}
20001a98:	f107 0708 	add.w	r7, r7, #8
20001a9c:	46bd      	mov	sp, r7
20001a9e:	bd80      	pop	{r7, pc}

20001aa0 <MSS_SPI_disable>:
 */
void MSS_SPI_disable
(
    mss_spi_instance_t * this_spi
)
{
20001aa0:	b580      	push	{r7, lr}
20001aa2:	b082      	sub	sp, #8
20001aa4:	af00      	add	r7, sp, #0
20001aa6:	6078      	str	r0, [r7, #4]
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20001aa8:	687b      	ldr	r3, [r7, #4]
20001aaa:	791b      	ldrb	r3, [r3, #4]
20001aac:	b25b      	sxtb	r3, r3
20001aae:	4618      	mov	r0, r3
20001ab0:	f7ff f868 	bl	20000b84 <NVIC_DisableIRQ>

    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
20001ab4:	687b      	ldr	r3, [r7, #4]
20001ab6:	681b      	ldr	r3, [r3, #0]
20001ab8:	687a      	ldr	r2, [r7, #4]
20001aba:	6812      	ldr	r2, [r2, #0]
20001abc:	6812      	ldr	r2, [r2, #0]
20001abe:	f022 0201 	bic.w	r2, r2, #1
20001ac2:	601a      	str	r2, [r3, #0]

    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
20001ac4:	687b      	ldr	r3, [r7, #4]
20001ac6:	791b      	ldrb	r3, [r3, #4]
20001ac8:	b25b      	sxtb	r3, r3
20001aca:	4618      	mov	r0, r3
20001acc:	f7ff f83e 	bl	20000b4c <NVIC_EnableIRQ>
}
20001ad0:	f107 0708 	add.w	r7, r7, #8
20001ad4:	46bd      	mov	sp, r7
20001ad6:	bd80      	pop	{r7, pc}

20001ad8 <MSS_SPI_set_transfer_byte_count>:
void MSS_SPI_set_transfer_byte_count
(
    mss_spi_instance_t * this_spi,
    uint16_t byte_count
)
{
20001ad8:	b580      	push	{r7, lr}
20001ada:	b082      	sub	sp, #8
20001adc:	af00      	add	r7, sp, #0
20001ade:	6078      	str	r0, [r7, #4]
20001ae0:	460b      	mov	r3, r1
20001ae2:	807b      	strh	r3, [r7, #2]
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20001ae4:	687b      	ldr	r3, [r7, #4]
20001ae6:	791b      	ldrb	r3, [r3, #4]
20001ae8:	b25b      	sxtb	r3, r3
20001aea:	4618      	mov	r0, r3
20001aec:	f7ff f84a 	bl	20000b84 <NVIC_DisableIRQ>

    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK)
20001af0:	687b      	ldr	r3, [r7, #4]
20001af2:	6819      	ldr	r1, [r3, #0]
20001af4:	687b      	ldr	r3, [r7, #4]
20001af6:	681b      	ldr	r3, [r3, #0]
20001af8:	681b      	ldr	r3, [r3, #0]
20001afa:	f240 02ff 	movw	r2, #255	; 0xff
20001afe:	f6cf 7200 	movt	r2, #65280	; 0xff00
20001b02:	ea03 0202 	and.w	r2, r3, r2
                                | (((uint32_t)byte_count << TXRXDFCOUNT_SHIFT) & TXRXDFCOUNT_MASK);
20001b06:	887b      	ldrh	r3, [r7, #2]
20001b08:	ea4f 2003 	mov.w	r0, r3, lsl #8
20001b0c:	f64f 7300 	movw	r3, #65280	; 0xff00
20001b10:	f2c0 03ff 	movt	r3, #255	; 0xff
20001b14:	ea00 0303 	and.w	r3, r0, r3
)
{
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );

    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK)
20001b18:	ea42 0303 	orr.w	r3, r2, r3
20001b1c:	600b      	str	r3, [r1, #0]
                                | (((uint32_t)byte_count << TXRXDFCOUNT_SHIFT) & TXRXDFCOUNT_MASK);
                                
    /* This value can only be updated when the MSS SPI is disabled */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
20001b1e:	687b      	ldr	r3, [r7, #4]
20001b20:	681b      	ldr	r3, [r3, #0]
20001b22:	687a      	ldr	r2, [r7, #4]
20001b24:	6812      	ldr	r2, [r2, #0]
20001b26:	6812      	ldr	r2, [r2, #0]
20001b28:	f022 0201 	bic.w	r2, r2, #1
20001b2c:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
20001b2e:	687b      	ldr	r3, [r7, #4]
20001b30:	681b      	ldr	r3, [r3, #0]
20001b32:	f04f 0208 	mov.w	r2, #8
20001b36:	605a      	str	r2, [r3, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
20001b38:	687b      	ldr	r3, [r7, #4]
20001b3a:	681b      	ldr	r3, [r3, #0]
20001b3c:	687a      	ldr	r2, [r7, #4]
20001b3e:	6812      	ldr	r2, [r2, #0]
20001b40:	6812      	ldr	r2, [r2, #0]
20001b42:	f042 0201 	orr.w	r2, r2, #1
20001b46:	601a      	str	r2, [r3, #0]
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
20001b48:	687b      	ldr	r3, [r7, #4]
20001b4a:	791b      	ldrb	r3, [r3, #4]
20001b4c:	b25b      	sxtb	r3, r3
20001b4e:	4618      	mov	r0, r3
20001b50:	f7fe fffc 	bl	20000b4c <NVIC_EnableIRQ>
}
20001b54:	f107 0708 	add.w	r7, r7, #8
20001b58:	46bd      	mov	sp, r7
20001b5a:	bd80      	pop	{r7, pc}

20001b5c <MSS_SPI_tx_done>:
 */
uint32_t MSS_SPI_tx_done
(
    mss_spi_instance_t * this_spi
)
{
20001b5c:	b480      	push	{r7}
20001b5e:	b085      	sub	sp, #20
20001b60:	af00      	add	r7, sp, #0
20001b62:	6078      	str	r0, [r7, #4]
    uint32_t tx_done;
    
    tx_done = this_spi->hw_reg->STATUS & TX_DONE_MASK;
20001b64:	687b      	ldr	r3, [r7, #4]
20001b66:	681b      	ldr	r3, [r3, #0]
20001b68:	689b      	ldr	r3, [r3, #8]
20001b6a:	f003 0301 	and.w	r3, r3, #1
20001b6e:	60fb      	str	r3, [r7, #12]
    
    return tx_done;
20001b70:	68fb      	ldr	r3, [r7, #12]
}
20001b72:	4618      	mov	r0, r3
20001b74:	f107 0714 	add.w	r7, r7, #20
20001b78:	46bd      	mov	sp, r7
20001b7a:	bc80      	pop	{r7}
20001b7c:	4770      	bx	lr
20001b7e:	bf00      	nop

20001b80 <fill_slave_tx_fifo>:
 */
static void fill_slave_tx_fifo
(
    mss_spi_instance_t * this_spi
)
{
20001b80:	b480      	push	{r7}
20001b82:	b085      	sub	sp, #20
20001b84:	af00      	add	r7, sp, #0
20001b86:	6078      	str	r0, [r7, #4]
    uint32_t guard = 0u;
20001b88:	f04f 0300 	mov.w	r3, #0
20001b8c:	60fb      	str	r3, [r7, #12]

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
20001b8e:	e00e      	b.n	20001bae <fill_slave_tx_fifo+0x2e>
          (this_spi->slave_tx_idx < this_spi->slave_tx_size))
    {
        /* Sending from primary slave transmit buffer */
        this_spi->hw_reg->TX_DATA = this_spi->slave_tx_buffer[this_spi->slave_tx_idx];
20001b90:	687b      	ldr	r3, [r7, #4]
20001b92:	681b      	ldr	r3, [r3, #0]
20001b94:	687a      	ldr	r2, [r7, #4]
20001b96:	6891      	ldr	r1, [r2, #8]
20001b98:	687a      	ldr	r2, [r7, #4]
20001b9a:	6912      	ldr	r2, [r2, #16]
20001b9c:	440a      	add	r2, r1
20001b9e:	7812      	ldrb	r2, [r2, #0]
20001ba0:	615a      	str	r2, [r3, #20]
        ++this_spi->slave_tx_idx;
20001ba2:	687b      	ldr	r3, [r7, #4]
20001ba4:	691b      	ldr	r3, [r3, #16]
20001ba6:	f103 0201 	add.w	r2, r3, #1
20001baa:	687b      	ldr	r3, [r7, #4]
20001bac:	611a      	str	r2, [r3, #16]
    mss_spi_instance_t * this_spi
)
{
    uint32_t guard = 0u;

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
20001bae:	687b      	ldr	r3, [r7, #4]
20001bb0:	681b      	ldr	r3, [r3, #0]
20001bb2:	689b      	ldr	r3, [r3, #8]
20001bb4:	f403 7380 	and.w	r3, r3, #256	; 0x100
20001bb8:	2b00      	cmp	r3, #0
20001bba:	d105      	bne.n	20001bc8 <fill_slave_tx_fifo+0x48>
          (this_spi->slave_tx_idx < this_spi->slave_tx_size))
20001bbc:	687b      	ldr	r3, [r7, #4]
20001bbe:	691a      	ldr	r2, [r3, #16]
20001bc0:	687b      	ldr	r3, [r7, #4]
20001bc2:	68db      	ldr	r3, [r3, #12]
    mss_spi_instance_t * this_spi
)
{
    uint32_t guard = 0u;

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
20001bc4:	429a      	cmp	r2, r3
20001bc6:	d3e3      	bcc.n	20001b90 <fill_slave_tx_fifo+0x10>
        /* Sending from primary slave transmit buffer */
        this_spi->hw_reg->TX_DATA = this_spi->slave_tx_buffer[this_spi->slave_tx_idx];
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
20001bc8:	687b      	ldr	r3, [r7, #4]
20001bca:	691a      	ldr	r2, [r3, #16]
20001bcc:	687b      	ldr	r3, [r7, #4]
20001bce:	68db      	ldr	r3, [r3, #12]
20001bd0:	429a      	cmp	r2, r3
20001bd2:	d31c      	bcc.n	20001c0e <fill_slave_tx_fifo+0x8e>
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
20001bd4:	e00e      	b.n	20001bf4 <fill_slave_tx_fifo+0x74>
              (this_spi->resp_buff_tx_idx < this_spi->resp_buff_size))
        {
            /* Sending from command response buffer */
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
20001bd6:	687b      	ldr	r3, [r7, #4]
20001bd8:	681b      	ldr	r3, [r3, #0]
20001bda:	687a      	ldr	r2, [r7, #4]
20001bdc:	6951      	ldr	r1, [r2, #20]
20001bde:	687a      	ldr	r2, [r7, #4]
20001be0:	69d2      	ldr	r2, [r2, #28]
20001be2:	440a      	add	r2, r1
20001be4:	7812      	ldrb	r2, [r2, #0]
20001be6:	615a      	str	r2, [r3, #20]
            ++this_spi->resp_buff_tx_idx;
20001be8:	687b      	ldr	r3, [r7, #4]
20001bea:	69db      	ldr	r3, [r3, #28]
20001bec:	f103 0201 	add.w	r2, r3, #1
20001bf0:	687b      	ldr	r3, [r7, #4]
20001bf2:	61da      	str	r2, [r3, #28]
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
20001bf4:	687b      	ldr	r3, [r7, #4]
20001bf6:	681b      	ldr	r3, [r3, #0]
20001bf8:	689b      	ldr	r3, [r3, #8]
20001bfa:	f403 7380 	and.w	r3, r3, #256	; 0x100
20001bfe:	2b00      	cmp	r3, #0
20001c00:	d105      	bne.n	20001c0e <fill_slave_tx_fifo+0x8e>
              (this_spi->resp_buff_tx_idx < this_spi->resp_buff_size))
20001c02:	687b      	ldr	r3, [r7, #4]
20001c04:	69da      	ldr	r2, [r3, #28]
20001c06:	687b      	ldr	r3, [r7, #4]
20001c08:	699b      	ldr	r3, [r3, #24]
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
20001c0a:	429a      	cmp	r2, r3
20001c0c:	d3e3      	bcc.n	20001bd6 <fill_slave_tx_fifo+0x56>
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
            ++this_spi->resp_buff_tx_idx;
        }
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
20001c0e:	687b      	ldr	r3, [r7, #4]
20001c10:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20001c12:	2b00      	cmp	r3, #0
20001c14:	d01f      	beq.n	20001c56 <fill_slave_tx_fifo+0xd6>
20001c16:	687b      	ldr	r3, [r7, #4]
20001c18:	691a      	ldr	r2, [r3, #16]
20001c1a:	687b      	ldr	r3, [r7, #4]
20001c1c:	68db      	ldr	r3, [r3, #12]
20001c1e:	429a      	cmp	r2, r3
20001c20:	d319      	bcc.n	20001c56 <fill_slave_tx_fifo+0xd6>
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
20001c22:	687b      	ldr	r3, [r7, #4]
20001c24:	69da      	ldr	r2, [r3, #28]
20001c26:	687b      	ldr	r3, [r7, #4]
20001c28:	699b      	ldr	r3, [r3, #24]
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
            ++this_spi->resp_buff_tx_idx;
        }
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
20001c2a:	429a      	cmp	r2, r3
20001c2c:	d313      	bcc.n	20001c56 <fill_slave_tx_fifo+0xd6>
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
20001c2e:	e008      	b.n	20001c42 <fill_slave_tx_fifo+0xc2>
              (guard < BIG_FIFO_SIZE))
        {
            /* Nothing left so pad with 0s for consistency */
            this_spi->hw_reg->TX_DATA = 0x00u;
20001c30:	687b      	ldr	r3, [r7, #4]
20001c32:	681b      	ldr	r3, [r3, #0]
20001c34:	f04f 0200 	mov.w	r2, #0
20001c38:	615a      	str	r2, [r3, #20]
             * We use the guard count to cover the unlikely event that we are
             * never seeing the TX FIFO full because the data is being pulled
             * out as fast as we can stuff it in. In this event we never spend
             * more than a full FIFOs worth of time spinning here.
             */
            guard++;
20001c3a:	68fb      	ldr	r3, [r7, #12]
20001c3c:	f103 0301 	add.w	r3, r3, #1
20001c40:	60fb      	str	r3, [r7, #12]
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
20001c42:	687b      	ldr	r3, [r7, #4]
20001c44:	681b      	ldr	r3, [r3, #0]
20001c46:	689b      	ldr	r3, [r3, #8]
20001c48:	f403 7380 	and.w	r3, r3, #256	; 0x100
20001c4c:	2b00      	cmp	r3, #0
20001c4e:	d102      	bne.n	20001c56 <fill_slave_tx_fifo+0xd6>
20001c50:	68fb      	ldr	r3, [r7, #12]
20001c52:	2b1f      	cmp	r3, #31
20001c54:	d9ec      	bls.n	20001c30 <fill_slave_tx_fifo+0xb0>
             */
            guard++;
        }
    }

}
20001c56:	f107 0714 	add.w	r7, r7, #20
20001c5a:	46bd      	mov	sp, r7
20001c5c:	bc80      	pop	{r7}
20001c5e:	4770      	bx	lr

20001c60 <read_slave_rx_fifo>:
 */
static void read_slave_rx_fifo
(
    mss_spi_instance_t * this_spi
)
{
20001c60:	b580      	push	{r7, lr}
20001c62:	b084      	sub	sp, #16
20001c64:	af00      	add	r7, sp, #0
20001c66:	6078      	str	r0, [r7, #4]
    volatile uint32_t rx_frame;
    
    if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
20001c68:	687b      	ldr	r3, [r7, #4]
20001c6a:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20001c6e:	2b02      	cmp	r3, #2
20001c70:	d115      	bne.n	20001c9e <read_slave_rx_fifo+0x3e>
    {
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
20001c72:	e00c      	b.n	20001c8e <read_slave_rx_fifo+0x2e>
        {
            /* Single frame handling mode. */
            rx_frame = this_spi->hw_reg->RX_DATA;
20001c74:	687b      	ldr	r3, [r7, #4]
20001c76:	681b      	ldr	r3, [r3, #0]
20001c78:	691b      	ldr	r3, [r3, #16]
20001c7a:	60fb      	str	r3, [r7, #12]
            if(0u != this_spi->frame_rx_handler)
20001c7c:	687b      	ldr	r3, [r7, #4]
20001c7e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20001c80:	2b00      	cmp	r3, #0
20001c82:	d004      	beq.n	20001c8e <read_slave_rx_fifo+0x2e>
            {
                this_spi->frame_rx_handler( rx_frame );
20001c84:	687b      	ldr	r3, [r7, #4]
20001c86:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20001c88:	68fa      	ldr	r2, [r7, #12]
20001c8a:	4610      	mov	r0, r2
20001c8c:	4798      	blx	r3
{
    volatile uint32_t rx_frame;
    
    if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
    {
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
20001c8e:	687b      	ldr	r3, [r7, #4]
20001c90:	681b      	ldr	r3, [r3, #0]
20001c92:	689b      	ldr	r3, [r3, #8]
20001c94:	f003 0340 	and.w	r3, r3, #64	; 0x40
20001c98:	2b00      	cmp	r3, #0
20001c9a:	d0eb      	beq.n	20001c74 <read_slave_rx_fifo+0x14>
20001c9c:	e032      	b.n	20001d04 <read_slave_rx_fifo+0xa4>
            {
                this_spi->frame_rx_handler( rx_frame );
            }
        }
    }
    else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
20001c9e:	687b      	ldr	r3, [r7, #4]
20001ca0:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20001ca4:	2b01      	cmp	r3, #1
20001ca6:	d125      	bne.n	20001cf4 <read_slave_rx_fifo+0x94>
    {
        /* Block handling mode. */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
20001ca8:	e017      	b.n	20001cda <read_slave_rx_fifo+0x7a>
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
20001caa:	687b      	ldr	r3, [r7, #4]
20001cac:	681b      	ldr	r3, [r3, #0]
20001cae:	691b      	ldr	r3, [r3, #16]
20001cb0:	60fb      	str	r3, [r7, #12]
            if(this_spi->slave_rx_idx < this_spi->slave_rx_size)
20001cb2:	687b      	ldr	r3, [r7, #4]
20001cb4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
20001cb6:	687b      	ldr	r3, [r7, #4]
20001cb8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20001cba:	429a      	cmp	r2, r3
20001cbc:	d207      	bcs.n	20001cce <read_slave_rx_fifo+0x6e>
            {
                this_spi->slave_rx_buffer[this_spi->slave_rx_idx] = (uint8_t)rx_frame;
20001cbe:	687b      	ldr	r3, [r7, #4]
20001cc0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
20001cc2:	687b      	ldr	r3, [r7, #4]
20001cc4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001cc6:	4413      	add	r3, r2
20001cc8:	68fa      	ldr	r2, [r7, #12]
20001cca:	b2d2      	uxtb	r2, r2
20001ccc:	701a      	strb	r2, [r3, #0]
            }

            ++this_spi->slave_rx_idx;
20001cce:	687b      	ldr	r3, [r7, #4]
20001cd0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001cd2:	f103 0201 	add.w	r2, r3, #1
20001cd6:	687b      	ldr	r3, [r7, #4]
20001cd8:	631a      	str	r2, [r3, #48]	; 0x30
        }
    }
    else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
    {
        /* Block handling mode. */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
20001cda:	687b      	ldr	r3, [r7, #4]
20001cdc:	681b      	ldr	r3, [r3, #0]
20001cde:	689b      	ldr	r3, [r3, #8]
20001ce0:	f003 0340 	and.w	r3, r3, #64	; 0x40
20001ce4:	2b00      	cmp	r3, #0
20001ce6:	d0e0      	beq.n	20001caa <read_slave_rx_fifo+0x4a>
20001ce8:	e00c      	b.n	20001d04 <read_slave_rx_fifo+0xa4>
    else
    {
        /* Should not happen... Just purge FIFO */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
20001cea:	687b      	ldr	r3, [r7, #4]
20001cec:	681b      	ldr	r3, [r3, #0]
20001cee:	691b      	ldr	r3, [r3, #16]
20001cf0:	60fb      	str	r3, [r7, #12]
20001cf2:	e000      	b.n	20001cf6 <read_slave_rx_fifo+0x96>
        }
    }
    else
    {
        /* Should not happen... Just purge FIFO */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
20001cf4:	bf00      	nop
20001cf6:	687b      	ldr	r3, [r7, #4]
20001cf8:	681b      	ldr	r3, [r3, #0]
20001cfa:	689b      	ldr	r3, [r3, #8]
20001cfc:	f003 0340 	and.w	r3, r3, #64	; 0x40
20001d00:	2b00      	cmp	r3, #0
20001d02:	d0f2      	beq.n	20001cea <read_slave_rx_fifo+0x8a>
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
        }
    }
}
20001d04:	f107 0710 	add.w	r7, r7, #16
20001d08:	46bd      	mov	sp, r7
20001d0a:	bd80      	pop	{r7, pc}

20001d0c <mss_spi_isr>:
 */
static void mss_spi_isr
(
    mss_spi_instance_t * this_spi
)
{    
20001d0c:	b580      	push	{r7, lr}
20001d0e:	b086      	sub	sp, #24
20001d10:	af00      	add	r7, sp, #0
20001d12:	6078      	str	r0, [r7, #4]
    volatile uint32_t rx_frame;
    __I  uint32_t *this_mis = &this_spi->hw_reg->MIS;
20001d14:	687b      	ldr	r3, [r7, #4]
20001d16:	681b      	ldr	r3, [r3, #0]
20001d18:	f103 0320 	add.w	r3, r3, #32
20001d1c:	613b      	str	r3, [r7, #16]

    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20001d1e:	687a      	ldr	r2, [r7, #4]
20001d20:	f644 3394 	movw	r3, #19348	; 0x4b94
20001d24:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001d28:	429a      	cmp	r2, r3
20001d2a:	d007      	beq.n	20001d3c <mss_spi_isr+0x30>
20001d2c:	687a      	ldr	r2, [r7, #4]
20001d2e:	f644 3310 	movw	r3, #19216	; 0x4b10
20001d32:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001d36:	429a      	cmp	r2, r3
20001d38:	d000      	beq.n	20001d3c <mss_spi_isr+0x30>
20001d3a:	be00      	bkpt	0x0000
  
    if(0u != (*this_mis & RXDONE_IRQ_MASK))
20001d3c:	693b      	ldr	r3, [r7, #16]
20001d3e:	681b      	ldr	r3, [r3, #0]
20001d40:	f003 0302 	and.w	r3, r3, #2
20001d44:	2b00      	cmp	r3, #0
20001d46:	d052      	beq.n	20001dee <mss_spi_isr+0xe2>
    {
        if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
20001d48:	687b      	ldr	r3, [r7, #4]
20001d4a:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20001d4e:	2b02      	cmp	r3, #2
20001d50:	d115      	bne.n	20001d7e <mss_spi_isr+0x72>
        {
            /* Single frame handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
20001d52:	e00c      	b.n	20001d6e <mss_spi_isr+0x62>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
20001d54:	687b      	ldr	r3, [r7, #4]
20001d56:	681b      	ldr	r3, [r3, #0]
20001d58:	691b      	ldr	r3, [r3, #16]
20001d5a:	60fb      	str	r3, [r7, #12]
                if(0u != this_spi->frame_rx_handler)
20001d5c:	687b      	ldr	r3, [r7, #4]
20001d5e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20001d60:	2b00      	cmp	r3, #0
20001d62:	d004      	beq.n	20001d6e <mss_spi_isr+0x62>
                {
                    this_spi->frame_rx_handler( rx_frame );
20001d64:	687b      	ldr	r3, [r7, #4]
20001d66:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20001d68:	68fa      	ldr	r2, [r7, #12]
20001d6a:	4610      	mov	r0, r2
20001d6c:	4798      	blx	r3
    if(0u != (*this_mis & RXDONE_IRQ_MASK))
    {
        if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
        {
            /* Single frame handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
20001d6e:	687b      	ldr	r3, [r7, #4]
20001d70:	681b      	ldr	r3, [r3, #0]
20001d72:	689b      	ldr	r3, [r3, #8]
20001d74:	f003 0340 	and.w	r3, r3, #64	; 0x40
20001d78:	2b00      	cmp	r3, #0
20001d7a:	d0eb      	beq.n	20001d54 <mss_spi_isr+0x48>
20001d7c:	e032      	b.n	20001de4 <mss_spi_isr+0xd8>
                {
                    this_spi->frame_rx_handler( rx_frame );
                }
            }
        }
        else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
20001d7e:	687b      	ldr	r3, [r7, #4]
20001d80:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20001d84:	2b01      	cmp	r3, #1
20001d86:	d125      	bne.n	20001dd4 <mss_spi_isr+0xc8>
        {
            /* Block handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
20001d88:	e017      	b.n	20001dba <mss_spi_isr+0xae>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;                /* Read from FIFO irrespective */
20001d8a:	687b      	ldr	r3, [r7, #4]
20001d8c:	681b      	ldr	r3, [r3, #0]
20001d8e:	691b      	ldr	r3, [r3, #16]
20001d90:	60fb      	str	r3, [r7, #12]
                if(this_spi->slave_rx_idx < this_spi->slave_rx_size) /* Write to array if required */
20001d92:	687b      	ldr	r3, [r7, #4]
20001d94:	6b1a      	ldr	r2, [r3, #48]	; 0x30
20001d96:	687b      	ldr	r3, [r7, #4]
20001d98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20001d9a:	429a      	cmp	r2, r3
20001d9c:	d207      	bcs.n	20001dae <mss_spi_isr+0xa2>
                {
                    this_spi->slave_rx_buffer[this_spi->slave_rx_idx] = (uint8_t)rx_frame;
20001d9e:	687b      	ldr	r3, [r7, #4]
20001da0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
20001da2:	687b      	ldr	r3, [r7, #4]
20001da4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001da6:	4413      	add	r3, r2
20001da8:	68fa      	ldr	r2, [r7, #12]
20001daa:	b2d2      	uxtb	r2, r2
20001dac:	701a      	strb	r2, [r3, #0]
                }

                ++this_spi->slave_rx_idx;            
20001dae:	687b      	ldr	r3, [r7, #4]
20001db0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001db2:	f103 0201 	add.w	r2, r3, #1
20001db6:	687b      	ldr	r3, [r7, #4]
20001db8:	631a      	str	r2, [r3, #48]	; 0x30
            }
        }
        else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
        {
            /* Block handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
20001dba:	687b      	ldr	r3, [r7, #4]
20001dbc:	681b      	ldr	r3, [r3, #0]
20001dbe:	689b      	ldr	r3, [r3, #8]
20001dc0:	f003 0340 	and.w	r3, r3, #64	; 0x40
20001dc4:	2b00      	cmp	r3, #0
20001dc6:	d0e0      	beq.n	20001d8a <mss_spi_isr+0x7e>
20001dc8:	e00c      	b.n	20001de4 <mss_spi_isr+0xd8>
        else
        {
            /* No slave handling in place so just purge FIFO */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
20001dca:	687b      	ldr	r3, [r7, #4]
20001dcc:	681b      	ldr	r3, [r3, #0]
20001dce:	691b      	ldr	r3, [r3, #16]
20001dd0:	60fb      	str	r3, [r7, #12]
20001dd2:	e000      	b.n	20001dd6 <mss_spi_isr+0xca>
            }
        }
        else
        {
            /* No slave handling in place so just purge FIFO */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
20001dd4:	bf00      	nop
20001dd6:	687b      	ldr	r3, [r7, #4]
20001dd8:	681b      	ldr	r3, [r3, #0]
20001dda:	689b      	ldr	r3, [r3, #8]
20001ddc:	f003 0340 	and.w	r3, r3, #64	; 0x40
20001de0:	2b00      	cmp	r3, #0
20001de2:	d0f2      	beq.n	20001dca <mss_spi_isr+0xbe>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
            }
        }

        this_spi->hw_reg->INT_CLEAR = RXDONE_IRQ_MASK;
20001de4:	687b      	ldr	r3, [r7, #4]
20001de6:	681b      	ldr	r3, [r3, #0]
20001de8:	f04f 0202 	mov.w	r2, #2
20001dec:	60da      	str	r2, [r3, #12]
    }

   /* Handle transmit. */
    if(0u != (*this_mis & TXDONE_IRQ_MASK))
20001dee:	693b      	ldr	r3, [r7, #16]
20001df0:	681b      	ldr	r3, [r3, #0]
20001df2:	f003 0301 	and.w	r3, r3, #1
20001df6:	b2db      	uxtb	r3, r3
20001df8:	2b00      	cmp	r3, #0
20001dfa:	d012      	beq.n	20001e22 <mss_spi_isr+0x116>
    {
        if( MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode )
20001dfc:	687b      	ldr	r3, [r7, #4]
20001dfe:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20001e02:	2b02      	cmp	r3, #2
20001e04:	d105      	bne.n	20001e12 <mss_spi_isr+0x106>
        {
           /* Reload slave tx frame into Tx data register. */
            this_spi->hw_reg->TX_DATA = this_spi->slave_tx_frame;
20001e06:	687b      	ldr	r3, [r7, #4]
20001e08:	681b      	ldr	r3, [r3, #0]
20001e0a:	687a      	ldr	r2, [r7, #4]
20001e0c:	6f92      	ldr	r2, [r2, #120]	; 0x78
20001e0e:	615a      	str	r2, [r3, #20]
20001e10:	e002      	b.n	20001e18 <mss_spi_isr+0x10c>
        }
        else /* Must be block mode so load FIFO to the max */
        {
            fill_slave_tx_fifo(this_spi);
20001e12:	6878      	ldr	r0, [r7, #4]
20001e14:	f7ff feb4 	bl	20001b80 <fill_slave_tx_fifo>
        }

        this_spi->hw_reg->INT_CLEAR = TXDONE_IRQ_MASK;
20001e18:	687b      	ldr	r3, [r7, #4]
20001e1a:	681b      	ldr	r3, [r3, #0]
20001e1c:	f04f 0201 	mov.w	r2, #1
20001e20:	60da      	str	r2, [r3, #12]
    }
    
    /* Handle command interrupt. */
    if(0u != (*this_mis & CMD_IRQ_MASK))
20001e22:	693b      	ldr	r3, [r7, #16]
20001e24:	681b      	ldr	r3, [r3, #0]
20001e26:	f003 0310 	and.w	r3, r3, #16
20001e2a:	2b00      	cmp	r3, #0
20001e2c:	d023      	beq.n	20001e76 <mss_spi_isr+0x16a>
    {
        read_slave_rx_fifo(this_spi);
20001e2e:	6878      	ldr	r0, [r7, #4]
20001e30:	f7ff ff16 	bl	20001c60 <read_slave_rx_fifo>
        
        /*
         * Call the command handler if one exists.
         */
        if(0u != this_spi->cmd_handler)
20001e34:	687b      	ldr	r3, [r7, #4]
20001e36:	6a1b      	ldr	r3, [r3, #32]
20001e38:	2b00      	cmp	r3, #0
20001e3a:	d00b      	beq.n	20001e54 <mss_spi_isr+0x148>
        {
            (*this_spi->cmd_handler)(this_spi->slave_rx_buffer, this_spi->slave_rx_idx);
20001e3c:	687b      	ldr	r3, [r7, #4]
20001e3e:	6a1b      	ldr	r3, [r3, #32]
20001e40:	687a      	ldr	r2, [r7, #4]
20001e42:	6a91      	ldr	r1, [r2, #40]	; 0x28
20001e44:	687a      	ldr	r2, [r7, #4]
20001e46:	6b12      	ldr	r2, [r2, #48]	; 0x30
20001e48:	4608      	mov	r0, r1
20001e4a:	4611      	mov	r1, r2
20001e4c:	4798      	blx	r3
            fill_slave_tx_fifo(this_spi);
20001e4e:	6878      	ldr	r0, [r7, #4]
20001e50:	f7ff fe96 	bl	20001b80 <fill_slave_tx_fifo>
        }
        /* Set cmd_done to indicate it is now safe to 0 fill TX FIFO */
        this_spi->cmd_done = 1u;
20001e54:	687b      	ldr	r3, [r7, #4]
20001e56:	f04f 0201 	mov.w	r2, #1
20001e5a:	625a      	str	r2, [r3, #36]	; 0x24
        /* Disable command interrupt until slave select becomes de-asserted to avoid retriggering. */
        this_spi->hw_reg->CONTROL2 &= ~(uint32_t)C2_ENABLE_CMD_IRQ_MASK;
20001e5c:	687b      	ldr	r3, [r7, #4]
20001e5e:	681b      	ldr	r3, [r3, #0]
20001e60:	687a      	ldr	r2, [r7, #4]
20001e62:	6812      	ldr	r2, [r2, #0]
20001e64:	6a92      	ldr	r2, [r2, #40]	; 0x28
20001e66:	f022 0210 	bic.w	r2, r2, #16
20001e6a:	629a      	str	r2, [r3, #40]	; 0x28
        this_spi->hw_reg->INT_CLEAR = CMD_IRQ_MASK;
20001e6c:	687b      	ldr	r3, [r7, #4]
20001e6e:	681b      	ldr	r3, [r3, #0]
20001e70:	f04f 0210 	mov.w	r2, #16
20001e74:	60da      	str	r2, [r3, #12]
    }

    if(0u != (*this_mis & RXOVFLOW_IRQ_MASK))
20001e76:	693b      	ldr	r3, [r7, #16]
20001e78:	681b      	ldr	r3, [r3, #0]
20001e7a:	f003 0304 	and.w	r3, r3, #4
20001e7e:	2b00      	cmp	r3, #0
20001e80:	d00f      	beq.n	20001ea2 <mss_spi_isr+0x196>
    {
        /*
         * Receive overflow, not a lot we can do for this. Reset the receive
         *  FIFO, clear the interrupt and hope it doesn't happen again...
         */
        this_spi->hw_reg->COMMAND |= RX_FIFO_RESET_MASK;
20001e82:	687b      	ldr	r3, [r7, #4]
20001e84:	681b      	ldr	r3, [r3, #0]
20001e86:	687a      	ldr	r2, [r7, #4]
20001e88:	6812      	ldr	r2, [r2, #0]
20001e8a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20001e8c:	f042 0204 	orr.w	r2, r2, #4
20001e90:	62da      	str	r2, [r3, #44]	; 0x2c
        recover_from_rx_overflow(this_spi);
20001e92:	6878      	ldr	r0, [r7, #4]
20001e94:	f7fe ff4c 	bl	20000d30 <recover_from_rx_overflow>
        this_spi->hw_reg->INT_CLEAR = RXOVFLOW_IRQ_MASK;
20001e98:	687b      	ldr	r3, [r7, #4]
20001e9a:	681b      	ldr	r3, [r3, #0]
20001e9c:	f04f 0204 	mov.w	r2, #4
20001ea0:	60da      	str	r2, [r3, #12]
     * slave TX FIFO data setup (if there is one).
     * In block mode this will probably not be very successful as we will
     * be out of synch with the master but the reset on SSEND will hopefully
     * take care of that for the next transfer.
     */
    if(0u != (*this_mis & TXURUN_IRQ_MASK))
20001ea2:	693b      	ldr	r3, [r7, #16]
20001ea4:	681b      	ldr	r3, [r3, #0]
20001ea6:	f003 0308 	and.w	r3, r3, #8
20001eaa:	2b00      	cmp	r3, #0
20001eac:	d031      	beq.n	20001f12 <mss_spi_isr+0x206>
    {
        this_spi->hw_reg->COMMAND |= TX_FIFO_RESET_MASK;
20001eae:	687b      	ldr	r3, [r7, #4]
20001eb0:	681b      	ldr	r3, [r3, #0]
20001eb2:	687a      	ldr	r2, [r7, #4]
20001eb4:	6812      	ldr	r2, [r2, #0]
20001eb6:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20001eb8:	f042 0208 	orr.w	r2, r2, #8
20001ebc:	62da      	str	r2, [r3, #44]	; 0x2c
        if( MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode )
20001ebe:	687b      	ldr	r3, [r7, #4]
20001ec0:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20001ec4:	2b02      	cmp	r3, #2
20001ec6:	d113      	bne.n	20001ef0 <mss_spi_isr+0x1e4>
        {
            this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK)
20001ec8:	687b      	ldr	r3, [r7, #4]
20001eca:	681a      	ldr	r2, [r3, #0]
20001ecc:	687b      	ldr	r3, [r7, #4]
20001ece:	681b      	ldr	r3, [r3, #0]
20001ed0:	6819      	ldr	r1, [r3, #0]
20001ed2:	f240 03ff 	movw	r3, #255	; 0xff
20001ed6:	f6cf 7300 	movt	r3, #65280	; 0xff00
20001eda:	ea01 0303 	and.w	r3, r1, r3
20001ede:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20001ee2:	6013      	str	r3, [r2, #0]
                                        | ((uint32_t)1u << TXRXDFCOUNT_SHIFT);
           /* Reload slave tx frame into Tx data register. */
            this_spi->hw_reg->TX_DATA = this_spi->slave_tx_frame;
20001ee4:	687b      	ldr	r3, [r7, #4]
20001ee6:	681b      	ldr	r3, [r3, #0]
20001ee8:	687a      	ldr	r2, [r7, #4]
20001eea:	6f92      	ldr	r2, [r2, #120]	; 0x78
20001eec:	615a      	str	r2, [r3, #20]
20001eee:	e00b      	b.n	20001f08 <mss_spi_isr+0x1fc>
        }
        else if( MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode )
20001ef0:	687b      	ldr	r3, [r7, #4]
20001ef2:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20001ef6:	2b01      	cmp	r3, #1
20001ef8:	d106      	bne.n	20001f08 <mss_spi_isr+0x1fc>
        {
            /* Block mode so reload FIFO to the max */
            this_spi->slave_tx_idx = 0u;
20001efa:	687b      	ldr	r3, [r7, #4]
20001efc:	f04f 0200 	mov.w	r2, #0
20001f00:	611a      	str	r2, [r3, #16]
            fill_slave_tx_fifo(this_spi);
20001f02:	6878      	ldr	r0, [r7, #4]
20001f04:	f7ff fe3c 	bl	20001b80 <fill_slave_tx_fifo>
        else
        {
            /* Not frame or block mode? Can't do anything here... */
        }

        this_spi->hw_reg->INT_CLEAR = TXURUN_IRQ_MASK;
20001f08:	687b      	ldr	r3, [r7, #4]
20001f0a:	681b      	ldr	r3, [r3, #0]
20001f0c:	f04f 0208 	mov.w	r2, #8
20001f10:	60da      	str	r2, [r3, #12]
    /*
     * Handle slave select becoming de-asserted. Only enables if
     * we are operating in block mode, in frame mode we do everything
     * in the receive and transmit interrupt handlers.
     */
    if(0u != (*this_mis & SSEND_IRQ_MASK))
20001f12:	693b      	ldr	r3, [r7, #16]
20001f14:	681b      	ldr	r3, [r3, #0]
20001f16:	f003 0320 	and.w	r3, r3, #32
20001f1a:	2b00      	cmp	r3, #0
20001f1c:	d049      	beq.n	20001fb2 <mss_spi_isr+0x2a6>
    {
        uint32_t rx_size;
        
        read_slave_rx_fifo(this_spi);
20001f1e:	6878      	ldr	r0, [r7, #4]
20001f20:	f7ff fe9e 	bl	20001c60 <read_slave_rx_fifo>
        rx_size = this_spi->slave_rx_idx;
20001f24:	687b      	ldr	r3, [r7, #4]
20001f26:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001f28:	617b      	str	r3, [r7, #20]
        /*
         * Re-enable command interrupt if required and clear all the response
         * buffer state in readiness for next response. This must be done
         * before reloading the TX FIFO.
         */
        if(0 != this_spi->cmd_handler)
20001f2a:	687b      	ldr	r3, [r7, #4]
20001f2c:	6a1b      	ldr	r3, [r3, #32]
20001f2e:	2b00      	cmp	r3, #0
20001f30:	d01c      	beq.n	20001f6c <mss_spi_isr+0x260>
        {
            this_spi->cmd_done = 0u;
20001f32:	687b      	ldr	r3, [r7, #4]
20001f34:	f04f 0200 	mov.w	r2, #0
20001f38:	625a      	str	r2, [r3, #36]	; 0x24
            this_spi->resp_tx_buffer = 0u;
20001f3a:	687b      	ldr	r3, [r7, #4]
20001f3c:	f04f 0200 	mov.w	r2, #0
20001f40:	615a      	str	r2, [r3, #20]
            this_spi->resp_buff_size = 0u;
20001f42:	687b      	ldr	r3, [r7, #4]
20001f44:	f04f 0200 	mov.w	r2, #0
20001f48:	619a      	str	r2, [r3, #24]
            this_spi->resp_buff_tx_idx = 0u;
20001f4a:	687b      	ldr	r3, [r7, #4]
20001f4c:	f04f 0200 	mov.w	r2, #0
20001f50:	61da      	str	r2, [r3, #28]
            this_spi->hw_reg->INT_CLEAR = CMD_IRQ_MASK;
20001f52:	687b      	ldr	r3, [r7, #4]
20001f54:	681b      	ldr	r3, [r3, #0]
20001f56:	f04f 0210 	mov.w	r2, #16
20001f5a:	60da      	str	r2, [r3, #12]
            this_spi->hw_reg->CONTROL2 |= C2_ENABLE_CMD_IRQ_MASK;
20001f5c:	687b      	ldr	r3, [r7, #4]
20001f5e:	681b      	ldr	r3, [r3, #0]
20001f60:	687a      	ldr	r2, [r7, #4]
20001f62:	6812      	ldr	r2, [r2, #0]
20001f64:	6a92      	ldr	r2, [r2, #40]	; 0x28
20001f66:	f042 0210 	orr.w	r2, r2, #16
20001f6a:	629a      	str	r2, [r3, #40]	; 0x28
        /* 
         * Reset the transmit index to 0 to restart transmit at the start of the
         * transmit buffer in the next transaction. This also requires flushing
         * the Tx FIFO and refilling it with the start of Tx data buffer.
         */
        this_spi->slave_tx_idx = 0u;
20001f6c:	687b      	ldr	r3, [r7, #4]
20001f6e:	f04f 0200 	mov.w	r2, #0
20001f72:	611a      	str	r2, [r3, #16]
        this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
20001f74:	687b      	ldr	r3, [r7, #4]
20001f76:	681b      	ldr	r3, [r3, #0]
20001f78:	687a      	ldr	r2, [r7, #4]
20001f7a:	6812      	ldr	r2, [r2, #0]
20001f7c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20001f7e:	f042 020c 	orr.w	r2, r2, #12
20001f82:	62da      	str	r2, [r3, #44]	; 0x2c
        fill_slave_tx_fifo(this_spi);
20001f84:	6878      	ldr	r0, [r7, #4]
20001f86:	f7ff fdfb 	bl	20001b80 <fill_slave_tx_fifo>
        
        /* Prepare to receive next packet. */
        this_spi->slave_rx_idx = 0u;
20001f8a:	687b      	ldr	r3, [r7, #4]
20001f8c:	f04f 0200 	mov.w	r2, #0
20001f90:	631a      	str	r2, [r3, #48]	; 0x30
        /*
         * Call the receive handler if one exists.
         */
        if(0u != this_spi->block_rx_handler)
20001f92:	687b      	ldr	r3, [r7, #4]
20001f94:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
20001f96:	2b00      	cmp	r3, #0
20001f98:	d006      	beq.n	20001fa8 <mss_spi_isr+0x29c>
        {
            (*this_spi->block_rx_handler)(this_spi->slave_rx_buffer, rx_size);
20001f9a:	687b      	ldr	r3, [r7, #4]
20001f9c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
20001f9e:	687a      	ldr	r2, [r7, #4]
20001fa0:	6a92      	ldr	r2, [r2, #40]	; 0x28
20001fa2:	4610      	mov	r0, r2
20001fa4:	6979      	ldr	r1, [r7, #20]
20001fa6:	4798      	blx	r3
        }
        
        this_spi->hw_reg->INT_CLEAR = SSEND_IRQ_MASK;
20001fa8:	687b      	ldr	r3, [r7, #4]
20001faa:	681b      	ldr	r3, [r3, #0]
20001fac:	f04f 0220 	mov.w	r2, #32
20001fb0:	60da      	str	r2, [r3, #12]
    }
}
20001fb2:	f107 0718 	add.w	r7, r7, #24
20001fb6:	46bd      	mov	sp, r7
20001fb8:	bd80      	pop	{r7, pc}
20001fba:	bf00      	nop

20001fbc <SPI0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void SPI0_IRQHandler(void)
#else
void SPI0_IRQHandler( void )
#endif
{
20001fbc:	4668      	mov	r0, sp
20001fbe:	f020 0107 	bic.w	r1, r0, #7
20001fc2:	468d      	mov	sp, r1
20001fc4:	b589      	push	{r0, r3, r7, lr}
20001fc6:	af00      	add	r7, sp, #0
    mss_spi_isr(&g_mss_spi0);
20001fc8:	f644 3094 	movw	r0, #19348	; 0x4b94
20001fcc:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001fd0:	f7ff fe9c 	bl	20001d0c <mss_spi_isr>
}
20001fd4:	46bd      	mov	sp, r7
20001fd6:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
20001fda:	4685      	mov	sp, r0
20001fdc:	4770      	bx	lr
20001fde:	bf00      	nop

20001fe0 <SPI1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void SPI1_IRQHandler(void)
#else
void SPI1_IRQHandler(void)
#endif
{
20001fe0:	4668      	mov	r0, sp
20001fe2:	f020 0107 	bic.w	r1, r0, #7
20001fe6:	468d      	mov	sp, r1
20001fe8:	b589      	push	{r0, r3, r7, lr}
20001fea:	af00      	add	r7, sp, #0
    mss_spi_isr(&g_mss_spi1);
20001fec:	f644 3010 	movw	r0, #19216	; 0x4b10
20001ff0:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001ff4:	f7ff fe8a 	bl	20001d0c <mss_spi_isr>
}
20001ff8:	46bd      	mov	sp, r7
20001ffa:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
20001ffe:	4685      	mov	sp, r0
20002000:	4770      	bx	lr
20002002:	bf00      	nop

20002004 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20002004:	b480      	push	{r7}
20002006:	b083      	sub	sp, #12
20002008:	af00      	add	r7, sp, #0
2000200a:	4603      	mov	r3, r0
2000200c:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
2000200e:	f24e 1300 	movw	r3, #57600	; 0xe100
20002012:	f2ce 0300 	movt	r3, #57344	; 0xe000
20002016:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000201a:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000201e:	79f9      	ldrb	r1, [r7, #7]
20002020:	f001 011f 	and.w	r1, r1, #31
20002024:	f04f 0001 	mov.w	r0, #1
20002028:	fa00 f101 	lsl.w	r1, r0, r1
2000202c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20002030:	f107 070c 	add.w	r7, r7, #12
20002034:	46bd      	mov	sp, r7
20002036:	bc80      	pop	{r7}
20002038:	4770      	bx	lr
2000203a:	bf00      	nop

2000203c <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
2000203c:	b480      	push	{r7}
2000203e:	b083      	sub	sp, #12
20002040:	af00      	add	r7, sp, #0
20002042:	4603      	mov	r3, r0
20002044:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
20002046:	f24e 1300 	movw	r3, #57600	; 0xe100
2000204a:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000204e:	f997 2007 	ldrsb.w	r2, [r7, #7]
20002052:	ea4f 1252 	mov.w	r2, r2, lsr #5
20002056:	79f9      	ldrb	r1, [r7, #7]
20002058:	f001 011f 	and.w	r1, r1, #31
2000205c:	f04f 0001 	mov.w	r0, #1
20002060:	fa00 f101 	lsl.w	r1, r0, r1
20002064:	f102 0260 	add.w	r2, r2, #96	; 0x60
20002068:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
2000206c:	f107 070c 	add.w	r7, r7, #12
20002070:	46bd      	mov	sp, r7
20002072:	bc80      	pop	{r7}
20002074:	4770      	bx	lr
20002076:	bf00      	nop

20002078 <PDMA_init>:

/***************************************************************************//**
 * See mss_pdma.h for description of this function.
 */
void PDMA_init(void)
{
20002078:	b580      	push	{r7, lr}
2000207a:	b082      	sub	sp, #8
2000207c:	af00      	add	r7, sp, #0
    int32_t i;
    
    /* Reset PDMA block. */
    SYSREG->SOFT_RST_CR |= PDMA_SOFT_RESET;
2000207e:	f248 0300 	movw	r3, #32768	; 0x8000
20002082:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002086:	f248 0200 	movw	r2, #32768	; 0x8000
2000208a:	f2c4 0203 	movt	r2, #16387	; 0x4003
2000208e:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002090:	f042 0220 	orr.w	r2, r2, #32
20002094:	649a      	str	r2, [r3, #72]	; 0x48
    
    /* Clear any previously pended MSS PDMA interrupt */
    NVIC_ClearPendingIRQ(DMA_IRQn);
20002096:	f04f 000d 	mov.w	r0, #13
2000209a:	f7ff ffcf 	bl	2000203c <NVIC_ClearPendingIRQ>
        
    /* Take PDMA controller out of reset*/
    SYSREG->SOFT_RST_CR &= ~PDMA_SOFT_RESET;
2000209e:	f248 0300 	movw	r3, #32768	; 0x8000
200020a2:	f2c4 0303 	movt	r3, #16387	; 0x4003
200020a6:	f248 0200 	movw	r2, #32768	; 0x8000
200020aa:	f2c4 0203 	movt	r2, #16387	; 0x4003
200020ae:	6c92      	ldr	r2, [r2, #72]	; 0x48
200020b0:	f022 0220 	bic.w	r2, r2, #32
200020b4:	649a      	str	r2, [r3, #72]	; 0x48
    
    /* Initialize channels state information. */
    for(i = 0; i < NB_OF_PDMA_CHANNELS; ++i)
200020b6:	f04f 0300 	mov.w	r3, #0
200020ba:	607b      	str	r3, [r7, #4]
200020bc:	e024      	b.n	20002108 <PDMA_init+0x90>
    {
        g_pdma_next_channel[i] = NEXT_CHANNEL_A;
200020be:	687a      	ldr	r2, [r7, #4]
200020c0:	f644 23d0 	movw	r3, #19152	; 0x4ad0
200020c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200020c8:	f04f 0100 	mov.w	r1, #0
200020cc:	5499      	strb	r1, [r3, r2]
        g_pdma_started_a[i] = CHANNEL_STOPPED;
200020ce:	687a      	ldr	r2, [r7, #4]
200020d0:	f644 23d8 	movw	r3, #19160	; 0x4ad8
200020d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200020d8:	f04f 0100 	mov.w	r1, #0
200020dc:	5499      	strb	r1, [r3, r2]
        g_pdma_started_b[i] = CHANNEL_STOPPED;
200020de:	687a      	ldr	r2, [r7, #4]
200020e0:	f644 23e0 	movw	r3, #19168	; 0x4ae0
200020e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200020e8:	f04f 0100 	mov.w	r1, #0
200020ec:	5499      	strb	r1, [r3, r2]
        g_pdma_isr_table[i] = 0;
200020ee:	687a      	ldr	r2, [r7, #4]
200020f0:	f644 23e8 	movw	r3, #19176	; 0x4ae8
200020f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200020f8:	f04f 0100 	mov.w	r1, #0
200020fc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        
    /* Take PDMA controller out of reset*/
    SYSREG->SOFT_RST_CR &= ~PDMA_SOFT_RESET;
    
    /* Initialize channels state information. */
    for(i = 0; i < NB_OF_PDMA_CHANNELS; ++i)
20002100:	687b      	ldr	r3, [r7, #4]
20002102:	f103 0301 	add.w	r3, r3, #1
20002106:	607b      	str	r3, [r7, #4]
20002108:	687b      	ldr	r3, [r7, #4]
2000210a:	2b07      	cmp	r3, #7
2000210c:	ddd7      	ble.n	200020be <PDMA_init+0x46>
        g_pdma_next_channel[i] = NEXT_CHANNEL_A;
        g_pdma_started_a[i] = CHANNEL_STOPPED;
        g_pdma_started_b[i] = CHANNEL_STOPPED;
        g_pdma_isr_table[i] = 0;
    }
}
2000210e:	f107 0708 	add.w	r7, r7, #8
20002112:	46bd      	mov	sp, r7
20002114:	bd80      	pop	{r7, pc}
20002116:	bf00      	nop

20002118 <PDMA_configure>:
    pdma_channel_id_t channel_id,
    pdma_src_dest_t src_dest,
    uint32_t channel_cfg,
    uint8_t write_adjust
)
{
20002118:	b580      	push	{r7, lr}
2000211a:	b098      	sub	sp, #96	; 0x60
2000211c:	af00      	add	r7, sp, #0
2000211e:	60ba      	str	r2, [r7, #8]
20002120:	4602      	mov	r2, r0
20002122:	73fa      	strb	r2, [r7, #15]
20002124:	460a      	mov	r2, r1
20002126:	73ba      	strb	r2, [r7, #14]
20002128:	71fb      	strb	r3, [r7, #7]
        CHANNEL_N_CTRL_PDMA_MASK | ( (uint32_t)12 << CHANNEL_N_PERIPH_SELECT_SHIFT) | CHANNEL_N_DIRECTION_MASK, /* PDMA_TO_FIC_1_DMAREADY_1 */
        CHANNEL_N_CTRL_PDMA_MASK | ( (uint32_t)13 << CHANNEL_N_PERIPH_SELECT_SHIFT),                            /* PDMA_FROM_FIC_1_DMAREADY_0 */
        CHANNEL_N_CTRL_PDMA_MASK | ( (uint32_t)13 << CHANNEL_N_PERIPH_SELECT_SHIFT) | CHANNEL_N_DIRECTION_MASK, /* PDMA_TO_FIC_1_DMAREADY_0 */
        CHANNEL_N_CTRL_PDMA_MASK | ( (uint32_t)14 << CHANNEL_N_PERIPH_SELECT_SHIFT),                            /* PDMA_FROM_COMBLK */
        CHANNEL_N_CTRL_PDMA_MASK | ( (uint32_t)15 << CHANNEL_N_PERIPH_SELECT_SHIFT) | CHANNEL_N_DIRECTION_MASK  /* PDMA_TO_COMBLK */
    };
2000212a:	f243 13a4 	movw	r3, #12708	; 0x31a4
2000212e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002132:	f107 0110 	add.w	r1, r7, #16
20002136:	461a      	mov	r2, r3
20002138:	f04f 0350 	mov.w	r3, #80	; 0x50
2000213c:	4608      	mov	r0, r1
2000213e:	4611      	mov	r1, r2
20002140:	461a      	mov	r2, r3
20002142:	f000 feb1 	bl	20002ea8 <memcpy>
    
    /* Reset the channel. */
    PDMA->CHANNEL[channel_id].CRTL |= CHANNEL_RESET_MASK;
20002146:	f243 0300 	movw	r3, #12288	; 0x3000
2000214a:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000214e:	7bf9      	ldrb	r1, [r7, #15]
20002150:	f243 0200 	movw	r2, #12288	; 0x3000
20002154:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002158:	7bf8      	ldrb	r0, [r7, #15]
2000215a:	f100 0001 	add.w	r0, r0, #1
2000215e:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002162:	4402      	add	r2, r0
20002164:	6812      	ldr	r2, [r2, #0]
20002166:	f042 0220 	orr.w	r2, r2, #32
2000216a:	f101 0101 	add.w	r1, r1, #1
2000216e:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002172:	440b      	add	r3, r1
20002174:	601a      	str	r2, [r3, #0]
    PDMA->CHANNEL[channel_id].CRTL &= ~CHANNEL_RESET_MASK;
20002176:	f243 0300 	movw	r3, #12288	; 0x3000
2000217a:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000217e:	7bf9      	ldrb	r1, [r7, #15]
20002180:	f243 0200 	movw	r2, #12288	; 0x3000
20002184:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002188:	7bf8      	ldrb	r0, [r7, #15]
2000218a:	f100 0001 	add.w	r0, r0, #1
2000218e:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002192:	4402      	add	r2, r0
20002194:	6812      	ldr	r2, [r2, #0]
20002196:	f022 0220 	bic.w	r2, r2, #32
2000219a:	f101 0101 	add.w	r1, r1, #1
2000219e:	ea4f 1141 	mov.w	r1, r1, lsl #5
200021a2:	440b      	add	r3, r1
200021a4:	601a      	str	r2, [r3, #0]

    /* Configure PDMA channel's data source and destination. */
    if(src_dest != PDMA_MEM_TO_MEM)
200021a6:	7bbb      	ldrb	r3, [r7, #14]
200021a8:	2b14      	cmp	r3, #20
200021aa:	d01f      	beq.n	200021ec <PDMA_configure+0xd4>
    {
        PDMA->CHANNEL[channel_id].CRTL |= src_dest_to_ctrl_reg_lut[src_dest];
200021ac:	f243 0300 	movw	r3, #12288	; 0x3000
200021b0:	f2c4 0300 	movt	r3, #16384	; 0x4000
200021b4:	7bf9      	ldrb	r1, [r7, #15]
200021b6:	f243 0200 	movw	r2, #12288	; 0x3000
200021ba:	f2c4 0200 	movt	r2, #16384	; 0x4000
200021be:	7bf8      	ldrb	r0, [r7, #15]
200021c0:	f100 0001 	add.w	r0, r0, #1
200021c4:	ea4f 1040 	mov.w	r0, r0, lsl #5
200021c8:	4402      	add	r2, r0
200021ca:	6810      	ldr	r0, [r2, #0]
200021cc:	7bba      	ldrb	r2, [r7, #14]
200021ce:	ea4f 0282 	mov.w	r2, r2, lsl #2
200021d2:	f107 0c60 	add.w	ip, r7, #96	; 0x60
200021d6:	4462      	add	r2, ip
200021d8:	f852 2c50 	ldr.w	r2, [r2, #-80]
200021dc:	ea40 0202 	orr.w	r2, r0, r2
200021e0:	f101 0101 	add.w	r1, r1, #1
200021e4:	ea4f 1141 	mov.w	r1, r1, lsl #5
200021e8:	440b      	add	r3, r1
200021ea:	601a      	str	r2, [r3, #0]
    }
    
    /* Configure PDMA channel trnasfer size, priority, source and destination address increment. */
    PDMA->CHANNEL[channel_id].CRTL |= channel_cfg;
200021ec:	f243 0300 	movw	r3, #12288	; 0x3000
200021f0:	f2c4 0300 	movt	r3, #16384	; 0x4000
200021f4:	7bf9      	ldrb	r1, [r7, #15]
200021f6:	f243 0200 	movw	r2, #12288	; 0x3000
200021fa:	f2c4 0200 	movt	r2, #16384	; 0x4000
200021fe:	7bf8      	ldrb	r0, [r7, #15]
20002200:	f100 0001 	add.w	r0, r0, #1
20002204:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002208:	4402      	add	r2, r0
2000220a:	6810      	ldr	r0, [r2, #0]
2000220c:	68ba      	ldr	r2, [r7, #8]
2000220e:	ea40 0202 	orr.w	r2, r0, r2
20002212:	f101 0101 	add.w	r1, r1, #1
20002216:	ea4f 1141 	mov.w	r1, r1, lsl #5
2000221a:	440b      	add	r3, r1
2000221c:	601a      	str	r2, [r3, #0]

    /* Posted write adjust. */
    PDMA->CHANNEL[channel_id].CRTL |= ((uint32_t)write_adjust << CHAN_POSTED_WRITE_ADJUST_SHIFT);
2000221e:	f243 0300 	movw	r3, #12288	; 0x3000
20002222:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002226:	7bf9      	ldrb	r1, [r7, #15]
20002228:	f243 0200 	movw	r2, #12288	; 0x3000
2000222c:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002230:	7bf8      	ldrb	r0, [r7, #15]
20002232:	f100 0001 	add.w	r0, r0, #1
20002236:	ea4f 1040 	mov.w	r0, r0, lsl #5
2000223a:	4402      	add	r2, r0
2000223c:	6810      	ldr	r0, [r2, #0]
2000223e:	79fa      	ldrb	r2, [r7, #7]
20002240:	ea4f 3282 	mov.w	r2, r2, lsl #14
20002244:	ea40 0202 	orr.w	r2, r0, r2
20002248:	f101 0101 	add.w	r1, r1, #1
2000224c:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002250:	440b      	add	r3, r1
20002252:	601a      	str	r2, [r3, #0]
}
20002254:	f107 0760 	add.w	r7, r7, #96	; 0x60
20002258:	46bd      	mov	sp, r7
2000225a:	bd80      	pop	{r7, pc}

2000225c <PDMA_start>:
    pdma_channel_id_t channel_id,
    uint32_t src_addr,
    uint32_t dest_addr,
    uint16_t transfer_count
)
{
2000225c:	b480      	push	{r7}
2000225e:	b085      	sub	sp, #20
20002260:	af00      	add	r7, sp, #0
20002262:	60b9      	str	r1, [r7, #8]
20002264:	607a      	str	r2, [r7, #4]
20002266:	4602      	mov	r2, r0
20002268:	73fa      	strb	r2, [r7, #15]
2000226a:	807b      	strh	r3, [r7, #2]
    /* Pause transfer. */
    PDMA->CHANNEL[channel_id].CRTL |= PAUSE_MASK;
2000226c:	f243 0300 	movw	r3, #12288	; 0x3000
20002270:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002274:	7bf9      	ldrb	r1, [r7, #15]
20002276:	f243 0200 	movw	r2, #12288	; 0x3000
2000227a:	f2c4 0200 	movt	r2, #16384	; 0x4000
2000227e:	7bf8      	ldrb	r0, [r7, #15]
20002280:	f100 0001 	add.w	r0, r0, #1
20002284:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002288:	4402      	add	r2, r0
2000228a:	6812      	ldr	r2, [r2, #0]
2000228c:	f042 0210 	orr.w	r2, r2, #16
20002290:	f101 0101 	add.w	r1, r1, #1
20002294:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002298:	440b      	add	r3, r1
2000229a:	601a      	str	r2, [r3, #0]
    
    /* Clear complete transfers. */
    if(PDMA->CHANNEL[channel_id].STATUS & PORT_A_COMPLETE_MASK)
2000229c:	f243 0300 	movw	r3, #12288	; 0x3000
200022a0:	f2c4 0300 	movt	r3, #16384	; 0x4000
200022a4:	7bfa      	ldrb	r2, [r7, #15]
200022a6:	f102 0201 	add.w	r2, r2, #1
200022aa:	ea4f 1242 	mov.w	r2, r2, lsl #5
200022ae:	4413      	add	r3, r2
200022b0:	f103 0304 	add.w	r3, r3, #4
200022b4:	681b      	ldr	r3, [r3, #0]
200022b6:	f003 0301 	and.w	r3, r3, #1
200022ba:	b2db      	uxtb	r3, r3
200022bc:	2b00      	cmp	r3, #0
200022be:	d01f      	beq.n	20002300 <PDMA_start+0xa4>
    {
        PDMA->CHANNEL[channel_id].CRTL |= CLEAR_PORT_A_DONE_MASK;
200022c0:	f243 0300 	movw	r3, #12288	; 0x3000
200022c4:	f2c4 0300 	movt	r3, #16384	; 0x4000
200022c8:	7bf9      	ldrb	r1, [r7, #15]
200022ca:	f243 0200 	movw	r2, #12288	; 0x3000
200022ce:	f2c4 0200 	movt	r2, #16384	; 0x4000
200022d2:	7bf8      	ldrb	r0, [r7, #15]
200022d4:	f100 0001 	add.w	r0, r0, #1
200022d8:	ea4f 1040 	mov.w	r0, r0, lsl #5
200022dc:	4402      	add	r2, r0
200022de:	6812      	ldr	r2, [r2, #0]
200022e0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
200022e4:	f101 0101 	add.w	r1, r1, #1
200022e8:	ea4f 1141 	mov.w	r1, r1, lsl #5
200022ec:	440b      	add	r3, r1
200022ee:	601a      	str	r2, [r3, #0]
        g_pdma_started_a[channel_id] = CHANNEL_STOPPED;
200022f0:	7bfa      	ldrb	r2, [r7, #15]
200022f2:	f644 23d8 	movw	r3, #19160	; 0x4ad8
200022f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200022fa:	f04f 0100 	mov.w	r1, #0
200022fe:	5499      	strb	r1, [r3, r2]
    }
    if(PDMA->CHANNEL[channel_id].STATUS & PORT_B_COMPLETE_MASK)
20002300:	f243 0300 	movw	r3, #12288	; 0x3000
20002304:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002308:	7bfa      	ldrb	r2, [r7, #15]
2000230a:	f102 0201 	add.w	r2, r2, #1
2000230e:	ea4f 1242 	mov.w	r2, r2, lsl #5
20002312:	4413      	add	r3, r2
20002314:	f103 0304 	add.w	r3, r3, #4
20002318:	681b      	ldr	r3, [r3, #0]
2000231a:	f003 0302 	and.w	r3, r3, #2
2000231e:	2b00      	cmp	r3, #0
20002320:	d01f      	beq.n	20002362 <PDMA_start+0x106>
    {
        PDMA->CHANNEL[channel_id].CRTL |= CLEAR_PORT_B_DONE_MASK;
20002322:	f243 0300 	movw	r3, #12288	; 0x3000
20002326:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000232a:	7bf9      	ldrb	r1, [r7, #15]
2000232c:	f243 0200 	movw	r2, #12288	; 0x3000
20002330:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002334:	7bf8      	ldrb	r0, [r7, #15]
20002336:	f100 0001 	add.w	r0, r0, #1
2000233a:	ea4f 1040 	mov.w	r0, r0, lsl #5
2000233e:	4402      	add	r2, r0
20002340:	6812      	ldr	r2, [r2, #0]
20002342:	f442 7280 	orr.w	r2, r2, #256	; 0x100
20002346:	f101 0101 	add.w	r1, r1, #1
2000234a:	ea4f 1141 	mov.w	r1, r1, lsl #5
2000234e:	440b      	add	r3, r1
20002350:	601a      	str	r2, [r3, #0]
        g_pdma_started_b[channel_id] = CHANNEL_STOPPED;
20002352:	7bfa      	ldrb	r2, [r7, #15]
20002354:	f644 23e0 	movw	r3, #19168	; 0x4ae0
20002358:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000235c:	f04f 0100 	mov.w	r1, #0
20002360:	5499      	strb	r1, [r3, r2]
    }
    
    /* Load source, destination and transfer count. */
    if(PDMA->CHANNEL[channel_id].STATUS & BUFFER_B_SELECT_MASK)
20002362:	f243 0300 	movw	r3, #12288	; 0x3000
20002366:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000236a:	7bfa      	ldrb	r2, [r7, #15]
2000236c:	f102 0201 	add.w	r2, r2, #1
20002370:	ea4f 1242 	mov.w	r2, r2, lsl #5
20002374:	4413      	add	r3, r2
20002376:	f103 0304 	add.w	r3, r3, #4
2000237a:	681b      	ldr	r3, [r3, #0]
2000237c:	f003 0304 	and.w	r3, r3, #4
20002380:	2b00      	cmp	r3, #0
20002382:	d034      	beq.n	200023ee <PDMA_start+0x192>
    {
        g_pdma_next_channel[channel_id] = NEXT_CHANNEL_A;
20002384:	7bfa      	ldrb	r2, [r7, #15]
20002386:	f644 23d0 	movw	r3, #19152	; 0x4ad0
2000238a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000238e:	f04f 0100 	mov.w	r1, #0
20002392:	5499      	strb	r1, [r3, r2]
        g_pdma_started_b[channel_id] = CHANNEL_STARTED;
20002394:	7bfa      	ldrb	r2, [r7, #15]
20002396:	f644 23e0 	movw	r3, #19168	; 0x4ae0
2000239a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000239e:	f04f 0101 	mov.w	r1, #1
200023a2:	5499      	strb	r1, [r3, r2]
        
        PDMA->CHANNEL[channel_id].BUFFER_B_SRC_ADDR = src_addr;
200023a4:	f243 0300 	movw	r3, #12288	; 0x3000
200023a8:	f2c4 0300 	movt	r3, #16384	; 0x4000
200023ac:	7bfa      	ldrb	r2, [r7, #15]
200023ae:	ea4f 1242 	mov.w	r2, r2, lsl #5
200023b2:	4413      	add	r3, r2
200023b4:	f103 0334 	add.w	r3, r3, #52	; 0x34
200023b8:	68ba      	ldr	r2, [r7, #8]
200023ba:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_B_DEST_ADDR = dest_addr;
200023bc:	f243 0300 	movw	r3, #12288	; 0x3000
200023c0:	f2c4 0300 	movt	r3, #16384	; 0x4000
200023c4:	7bfa      	ldrb	r2, [r7, #15]
200023c6:	ea4f 1242 	mov.w	r2, r2, lsl #5
200023ca:	4413      	add	r3, r2
200023cc:	f103 0338 	add.w	r3, r3, #56	; 0x38
200023d0:	687a      	ldr	r2, [r7, #4]
200023d2:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_B_TRANSFER_COUNT = transfer_count;
200023d4:	f243 0300 	movw	r3, #12288	; 0x3000
200023d8:	f2c4 0300 	movt	r3, #16384	; 0x4000
200023dc:	7bf9      	ldrb	r1, [r7, #15]
200023de:	887a      	ldrh	r2, [r7, #2]
200023e0:	ea4f 1141 	mov.w	r1, r1, lsl #5
200023e4:	440b      	add	r3, r1
200023e6:	f103 033c 	add.w	r3, r3, #60	; 0x3c
200023ea:	601a      	str	r2, [r3, #0]
200023ec:	e033      	b.n	20002456 <PDMA_start+0x1fa>
    }
    else
    {
        g_pdma_next_channel[channel_id] = NEXT_CHANNEL_B;
200023ee:	7bfa      	ldrb	r2, [r7, #15]
200023f0:	f644 23d0 	movw	r3, #19152	; 0x4ad0
200023f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200023f8:	f04f 0101 	mov.w	r1, #1
200023fc:	5499      	strb	r1, [r3, r2]
        g_pdma_started_a[channel_id] = CHANNEL_STARTED;
200023fe:	7bfa      	ldrb	r2, [r7, #15]
20002400:	f644 23d8 	movw	r3, #19160	; 0x4ad8
20002404:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002408:	f04f 0101 	mov.w	r1, #1
2000240c:	5499      	strb	r1, [r3, r2]
        
        PDMA->CHANNEL[channel_id].BUFFER_A_SRC_ADDR = src_addr;
2000240e:	f243 0300 	movw	r3, #12288	; 0x3000
20002412:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002416:	7bfa      	ldrb	r2, [r7, #15]
20002418:	ea4f 1242 	mov.w	r2, r2, lsl #5
2000241c:	4413      	add	r3, r2
2000241e:	f103 0328 	add.w	r3, r3, #40	; 0x28
20002422:	68ba      	ldr	r2, [r7, #8]
20002424:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_A_DEST_ADDR = dest_addr;
20002426:	f243 0300 	movw	r3, #12288	; 0x3000
2000242a:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000242e:	7bfa      	ldrb	r2, [r7, #15]
20002430:	ea4f 1242 	mov.w	r2, r2, lsl #5
20002434:	4413      	add	r3, r2
20002436:	f103 032c 	add.w	r3, r3, #44	; 0x2c
2000243a:	687a      	ldr	r2, [r7, #4]
2000243c:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_A_TRANSFER_COUNT = transfer_count;
2000243e:	f243 0300 	movw	r3, #12288	; 0x3000
20002442:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002446:	7bf9      	ldrb	r1, [r7, #15]
20002448:	887a      	ldrh	r2, [r7, #2]
2000244a:	ea4f 1141 	mov.w	r1, r1, lsl #5
2000244e:	440b      	add	r3, r1
20002450:	f103 0330 	add.w	r3, r3, #48	; 0x30
20002454:	601a      	str	r2, [r3, #0]
    }
    
    /* Start transfer */
    PDMA->CHANNEL[channel_id].CRTL &= ~PAUSE_MASK;
20002456:	f243 0300 	movw	r3, #12288	; 0x3000
2000245a:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000245e:	7bf9      	ldrb	r1, [r7, #15]
20002460:	f243 0200 	movw	r2, #12288	; 0x3000
20002464:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002468:	7bf8      	ldrb	r0, [r7, #15]
2000246a:	f100 0001 	add.w	r0, r0, #1
2000246e:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002472:	4402      	add	r2, r0
20002474:	6812      	ldr	r2, [r2, #0]
20002476:	f022 0210 	bic.w	r2, r2, #16
2000247a:	f101 0101 	add.w	r1, r1, #1
2000247e:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002482:	440b      	add	r3, r1
20002484:	601a      	str	r2, [r3, #0]
}
20002486:	f107 0714 	add.w	r7, r7, #20
2000248a:	46bd      	mov	sp, r7
2000248c:	bc80      	pop	{r7}
2000248e:	4770      	bx	lr

20002490 <PDMA_load_next_buffer>:
    pdma_channel_id_t channel_id,
    uint32_t src_addr,
    uint32_t dest_addr,
    uint16_t transfer_count
)
{
20002490:	b480      	push	{r7}
20002492:	b089      	sub	sp, #36	; 0x24
20002494:	af00      	add	r7, sp, #0
20002496:	60b9      	str	r1, [r7, #8]
20002498:	607a      	str	r2, [r7, #4]
2000249a:	4602      	mov	r2, r0
2000249c:	73fa      	strb	r2, [r7, #15]
2000249e:	807b      	strh	r3, [r7, #2]
    if(NEXT_CHANNEL_A == g_pdma_next_channel[channel_id])
200024a0:	7bfa      	ldrb	r2, [r7, #15]
200024a2:	f644 23d0 	movw	r3, #19152	; 0x4ad0
200024a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024aa:	5c9b      	ldrb	r3, [r3, r2]
200024ac:	2b00      	cmp	r3, #0
200024ae:	d168      	bne.n	20002582 <PDMA_load_next_buffer+0xf2>
    {
        /* Wait for channel A current transfer completion. */
        if(CHANNEL_STARTED == g_pdma_started_a[channel_id])
200024b0:	7bfa      	ldrb	r2, [r7, #15]
200024b2:	f644 23d8 	movw	r3, #19160	; 0x4ad8
200024b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024ba:	5c9b      	ldrb	r3, [r3, r2]
200024bc:	2b01      	cmp	r3, #1
200024be:	d12b      	bne.n	20002518 <PDMA_load_next_buffer+0x88>
        {
            uint32_t completed;
            uint32_t channel_mask;
            channel_mask = (uint32_t)1 << ((uint32_t)channel_id * 2U);
200024c0:	7bfb      	ldrb	r3, [r7, #15]
200024c2:	ea4f 0343 	mov.w	r3, r3, lsl #1
200024c6:	f04f 0201 	mov.w	r2, #1
200024ca:	fa02 f303 	lsl.w	r3, r2, r3
200024ce:	617b      	str	r3, [r7, #20]
            do {
                completed = PDMA->BUFFER_STATUS & channel_mask;
200024d0:	f243 0300 	movw	r3, #12288	; 0x3000
200024d4:	f2c4 0300 	movt	r3, #16384	; 0x4000
200024d8:	685a      	ldr	r2, [r3, #4]
200024da:	697b      	ldr	r3, [r7, #20]
200024dc:	ea02 0303 	and.w	r3, r2, r3
200024e0:	613b      	str	r3, [r7, #16]
            } while(0u == completed);
200024e2:	693b      	ldr	r3, [r7, #16]
200024e4:	2b00      	cmp	r3, #0
200024e6:	d0f3      	beq.n	200024d0 <PDMA_load_next_buffer+0x40>
            PDMA->CHANNEL[channel_id].CRTL |= CLEAR_PORT_A_DONE_MASK;
200024e8:	f243 0300 	movw	r3, #12288	; 0x3000
200024ec:	f2c4 0300 	movt	r3, #16384	; 0x4000
200024f0:	7bf9      	ldrb	r1, [r7, #15]
200024f2:	f243 0200 	movw	r2, #12288	; 0x3000
200024f6:	f2c4 0200 	movt	r2, #16384	; 0x4000
200024fa:	7bf8      	ldrb	r0, [r7, #15]
200024fc:	f100 0001 	add.w	r0, r0, #1
20002500:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002504:	4402      	add	r2, r0
20002506:	6812      	ldr	r2, [r2, #0]
20002508:	f042 0280 	orr.w	r2, r2, #128	; 0x80
2000250c:	f101 0101 	add.w	r1, r1, #1
20002510:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002514:	440b      	add	r3, r1
20002516:	601a      	str	r2, [r3, #0]
        }
        /* Load source, destination and transfer count. */
        PDMA->CHANNEL[channel_id].BUFFER_A_SRC_ADDR = src_addr;
20002518:	f243 0300 	movw	r3, #12288	; 0x3000
2000251c:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002520:	7bfa      	ldrb	r2, [r7, #15]
20002522:	ea4f 1242 	mov.w	r2, r2, lsl #5
20002526:	4413      	add	r3, r2
20002528:	f103 0328 	add.w	r3, r3, #40	; 0x28
2000252c:	68ba      	ldr	r2, [r7, #8]
2000252e:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_A_DEST_ADDR = dest_addr;
20002530:	f243 0300 	movw	r3, #12288	; 0x3000
20002534:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002538:	7bfa      	ldrb	r2, [r7, #15]
2000253a:	ea4f 1242 	mov.w	r2, r2, lsl #5
2000253e:	4413      	add	r3, r2
20002540:	f103 032c 	add.w	r3, r3, #44	; 0x2c
20002544:	687a      	ldr	r2, [r7, #4]
20002546:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_A_TRANSFER_COUNT = transfer_count;
20002548:	f243 0300 	movw	r3, #12288	; 0x3000
2000254c:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002550:	7bf9      	ldrb	r1, [r7, #15]
20002552:	887a      	ldrh	r2, [r7, #2]
20002554:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002558:	440b      	add	r3, r1
2000255a:	f103 0330 	add.w	r3, r3, #48	; 0x30
2000255e:	601a      	str	r2, [r3, #0]
        
        /* Update channel state information. */
        g_pdma_next_channel[channel_id] = NEXT_CHANNEL_B;
20002560:	7bfa      	ldrb	r2, [r7, #15]
20002562:	f644 23d0 	movw	r3, #19152	; 0x4ad0
20002566:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000256a:	f04f 0101 	mov.w	r1, #1
2000256e:	5499      	strb	r1, [r3, r2]
        g_pdma_started_a[channel_id] = CHANNEL_STARTED;
20002570:	7bfa      	ldrb	r2, [r7, #15]
20002572:	f644 23d8 	movw	r3, #19160	; 0x4ad8
20002576:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000257a:	f04f 0101 	mov.w	r1, #1
2000257e:	5499      	strb	r1, [r3, r2]
20002580:	e069      	b.n	20002656 <PDMA_load_next_buffer+0x1c6>
    }
    else
    {
        /* Wait for channel B current transfer completion. */
        if(CHANNEL_STARTED == g_pdma_started_b[channel_id])
20002582:	7bfa      	ldrb	r2, [r7, #15]
20002584:	f644 23e0 	movw	r3, #19168	; 0x4ae0
20002588:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000258c:	5c9b      	ldrb	r3, [r3, r2]
2000258e:	2b01      	cmp	r3, #1
20002590:	d12d      	bne.n	200025ee <PDMA_load_next_buffer+0x15e>
        {
            uint32_t completed;
            uint32_t channel_mask;
            channel_mask = (uint32_t)1 << (((uint32_t)channel_id * 2U) + 1U);
20002592:	7bfb      	ldrb	r3, [r7, #15]
20002594:	ea4f 0343 	mov.w	r3, r3, lsl #1
20002598:	f103 0301 	add.w	r3, r3, #1
2000259c:	f04f 0201 	mov.w	r2, #1
200025a0:	fa02 f303 	lsl.w	r3, r2, r3
200025a4:	61fb      	str	r3, [r7, #28]
            do {
                completed = PDMA->BUFFER_STATUS & channel_mask;
200025a6:	f243 0300 	movw	r3, #12288	; 0x3000
200025aa:	f2c4 0300 	movt	r3, #16384	; 0x4000
200025ae:	685a      	ldr	r2, [r3, #4]
200025b0:	69fb      	ldr	r3, [r7, #28]
200025b2:	ea02 0303 	and.w	r3, r2, r3
200025b6:	61bb      	str	r3, [r7, #24]
            } while(0u == completed);
200025b8:	69bb      	ldr	r3, [r7, #24]
200025ba:	2b00      	cmp	r3, #0
200025bc:	d0f3      	beq.n	200025a6 <PDMA_load_next_buffer+0x116>
            PDMA->CHANNEL[channel_id].CRTL |= CLEAR_PORT_B_DONE_MASK;
200025be:	f243 0300 	movw	r3, #12288	; 0x3000
200025c2:	f2c4 0300 	movt	r3, #16384	; 0x4000
200025c6:	7bf9      	ldrb	r1, [r7, #15]
200025c8:	f243 0200 	movw	r2, #12288	; 0x3000
200025cc:	f2c4 0200 	movt	r2, #16384	; 0x4000
200025d0:	7bf8      	ldrb	r0, [r7, #15]
200025d2:	f100 0001 	add.w	r0, r0, #1
200025d6:	ea4f 1040 	mov.w	r0, r0, lsl #5
200025da:	4402      	add	r2, r0
200025dc:	6812      	ldr	r2, [r2, #0]
200025de:	f442 7280 	orr.w	r2, r2, #256	; 0x100
200025e2:	f101 0101 	add.w	r1, r1, #1
200025e6:	ea4f 1141 	mov.w	r1, r1, lsl #5
200025ea:	440b      	add	r3, r1
200025ec:	601a      	str	r2, [r3, #0]
        }            
        /* Load source, destination and transfer count. */
        PDMA->CHANNEL[channel_id].BUFFER_B_SRC_ADDR = src_addr;
200025ee:	f243 0300 	movw	r3, #12288	; 0x3000
200025f2:	f2c4 0300 	movt	r3, #16384	; 0x4000
200025f6:	7bfa      	ldrb	r2, [r7, #15]
200025f8:	ea4f 1242 	mov.w	r2, r2, lsl #5
200025fc:	4413      	add	r3, r2
200025fe:	f103 0334 	add.w	r3, r3, #52	; 0x34
20002602:	68ba      	ldr	r2, [r7, #8]
20002604:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_B_DEST_ADDR = dest_addr;
20002606:	f243 0300 	movw	r3, #12288	; 0x3000
2000260a:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000260e:	7bfa      	ldrb	r2, [r7, #15]
20002610:	ea4f 1242 	mov.w	r2, r2, lsl #5
20002614:	4413      	add	r3, r2
20002616:	f103 0338 	add.w	r3, r3, #56	; 0x38
2000261a:	687a      	ldr	r2, [r7, #4]
2000261c:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_B_TRANSFER_COUNT = transfer_count;
2000261e:	f243 0300 	movw	r3, #12288	; 0x3000
20002622:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002626:	7bf9      	ldrb	r1, [r7, #15]
20002628:	887a      	ldrh	r2, [r7, #2]
2000262a:	ea4f 1141 	mov.w	r1, r1, lsl #5
2000262e:	440b      	add	r3, r1
20002630:	f103 033c 	add.w	r3, r3, #60	; 0x3c
20002634:	601a      	str	r2, [r3, #0]
        
        /* Update channel state information. */
        g_pdma_next_channel[channel_id] = NEXT_CHANNEL_A;
20002636:	7bfa      	ldrb	r2, [r7, #15]
20002638:	f644 23d0 	movw	r3, #19152	; 0x4ad0
2000263c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002640:	f04f 0100 	mov.w	r1, #0
20002644:	5499      	strb	r1, [r3, r2]
        g_pdma_started_b[channel_id] = CHANNEL_STARTED;
20002646:	7bfa      	ldrb	r2, [r7, #15]
20002648:	f644 23e0 	movw	r3, #19168	; 0x4ae0
2000264c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002650:	f04f 0101 	mov.w	r1, #1
20002654:	5499      	strb	r1, [r3, r2]
    }
}
20002656:	f107 0724 	add.w	r7, r7, #36	; 0x24
2000265a:	46bd      	mov	sp, r7
2000265c:	bc80      	pop	{r7}
2000265e:	4770      	bx	lr

20002660 <PDMA_status>:
 */
uint32_t PDMA_status
(
    pdma_channel_id_t  channel_id
)
{
20002660:	b480      	push	{r7}
20002662:	b085      	sub	sp, #20
20002664:	af00      	add	r7, sp, #0
20002666:	4603      	mov	r3, r0
20002668:	71fb      	strb	r3, [r7, #7]
    uint32_t status;
    
    status = PDMA->CHANNEL[channel_id].STATUS & (PORT_A_COMPLETE_MASK | PORT_B_COMPLETE_MASK);
2000266a:	f243 0300 	movw	r3, #12288	; 0x3000
2000266e:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002672:	79fa      	ldrb	r2, [r7, #7]
20002674:	f102 0201 	add.w	r2, r2, #1
20002678:	ea4f 1242 	mov.w	r2, r2, lsl #5
2000267c:	4413      	add	r3, r2
2000267e:	f103 0304 	add.w	r3, r3, #4
20002682:	681b      	ldr	r3, [r3, #0]
20002684:	f003 0303 	and.w	r3, r3, #3
20002688:	60fb      	str	r3, [r7, #12]
    
    return status;
2000268a:	68fb      	ldr	r3, [r7, #12]
}
2000268c:	4618      	mov	r0, r3
2000268e:	f107 0714 	add.w	r7, r7, #20
20002692:	46bd      	mov	sp, r7
20002694:	bc80      	pop	{r7}
20002696:	4770      	bx	lr

20002698 <get_channel_id_from_status>:

static pdma_channel_id_t get_channel_id_from_status
(
    uint16_t status
)
{
20002698:	b480      	push	{r7}
2000269a:	b085      	sub	sp, #20
2000269c:	af00      	add	r7, sp, #0
2000269e:	4603      	mov	r3, r0
200026a0:	80fb      	strh	r3, [r7, #6]
    pdma_channel_id_t channel_id = PDMA_CHANNEL_0;
200026a2:	f04f 0300 	mov.w	r3, #0
200026a6:	73fb      	strb	r3, [r7, #15]
    
    if(status & CHANNEL_0_STATUS_BITS_MASK)
200026a8:	88fb      	ldrh	r3, [r7, #6]
200026aa:	f003 0303 	and.w	r3, r3, #3
200026ae:	2b00      	cmp	r3, #0
200026b0:	d003      	beq.n	200026ba <get_channel_id_from_status+0x22>
    {
        channel_id = PDMA_CHANNEL_0;
200026b2:	f04f 0300 	mov.w	r3, #0
200026b6:	73fb      	strb	r3, [r7, #15]
200026b8:	e03f      	b.n	2000273a <get_channel_id_from_status+0xa2>
    }
    else if(status & CHANNEL_1_STATUS_BITS_MASK)
200026ba:	88fb      	ldrh	r3, [r7, #6]
200026bc:	f003 030c 	and.w	r3, r3, #12
200026c0:	2b00      	cmp	r3, #0
200026c2:	d003      	beq.n	200026cc <get_channel_id_from_status+0x34>
    {
        channel_id = PDMA_CHANNEL_1;
200026c4:	f04f 0301 	mov.w	r3, #1
200026c8:	73fb      	strb	r3, [r7, #15]
200026ca:	e036      	b.n	2000273a <get_channel_id_from_status+0xa2>
    }
    else if(status & CHANNEL_2_STATUS_BITS_MASK)
200026cc:	88fb      	ldrh	r3, [r7, #6]
200026ce:	f003 0330 	and.w	r3, r3, #48	; 0x30
200026d2:	2b00      	cmp	r3, #0
200026d4:	d003      	beq.n	200026de <get_channel_id_from_status+0x46>
    {
        channel_id = PDMA_CHANNEL_2;
200026d6:	f04f 0302 	mov.w	r3, #2
200026da:	73fb      	strb	r3, [r7, #15]
200026dc:	e02d      	b.n	2000273a <get_channel_id_from_status+0xa2>
    }
    else if(status & CHANNEL_3_STATUS_BITS_MASK)
200026de:	88fb      	ldrh	r3, [r7, #6]
200026e0:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
200026e4:	2b00      	cmp	r3, #0
200026e6:	d003      	beq.n	200026f0 <get_channel_id_from_status+0x58>
    {
        channel_id = PDMA_CHANNEL_3;
200026e8:	f04f 0303 	mov.w	r3, #3
200026ec:	73fb      	strb	r3, [r7, #15]
200026ee:	e024      	b.n	2000273a <get_channel_id_from_status+0xa2>
    }
    else if(status & CHANNEL_4_STATUS_BITS_MASK)
200026f0:	88fb      	ldrh	r3, [r7, #6]
200026f2:	f403 7340 	and.w	r3, r3, #768	; 0x300
200026f6:	2b00      	cmp	r3, #0
200026f8:	d003      	beq.n	20002702 <get_channel_id_from_status+0x6a>
    {
        channel_id = PDMA_CHANNEL_4;
200026fa:	f04f 0304 	mov.w	r3, #4
200026fe:	73fb      	strb	r3, [r7, #15]
20002700:	e01b      	b.n	2000273a <get_channel_id_from_status+0xa2>
    }
    else if(status & CHANNEL_5_STATUS_BITS_MASK)
20002702:	88fb      	ldrh	r3, [r7, #6]
20002704:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
20002708:	2b00      	cmp	r3, #0
2000270a:	d003      	beq.n	20002714 <get_channel_id_from_status+0x7c>
    {
        channel_id = PDMA_CHANNEL_5;
2000270c:	f04f 0305 	mov.w	r3, #5
20002710:	73fb      	strb	r3, [r7, #15]
20002712:	e012      	b.n	2000273a <get_channel_id_from_status+0xa2>
    }
    else if(status & CHANNEL_6_STATUS_BITS_MASK)
20002714:	88fb      	ldrh	r3, [r7, #6]
20002716:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
2000271a:	2b00      	cmp	r3, #0
2000271c:	d003      	beq.n	20002726 <get_channel_id_from_status+0x8e>
    {
        channel_id = PDMA_CHANNEL_6;
2000271e:	f04f 0306 	mov.w	r3, #6
20002722:	73fb      	strb	r3, [r7, #15]
20002724:	e009      	b.n	2000273a <get_channel_id_from_status+0xa2>
    }
    else if(status & CHANNEL_7_STATUS_BITS_MASK)
20002726:	88fb      	ldrh	r3, [r7, #6]
20002728:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
2000272c:	2b00      	cmp	r3, #0
2000272e:	d003      	beq.n	20002738 <get_channel_id_from_status+0xa0>
    {
        channel_id = PDMA_CHANNEL_7;
20002730:	f04f 0307 	mov.w	r3, #7
20002734:	73fb      	strb	r3, [r7, #15]
20002736:	e000      	b.n	2000273a <get_channel_id_from_status+0xa2>
    }
    else
    {
        ASSERT(0);
20002738:	be00      	bkpt	0x0000
    }
    return channel_id;
2000273a:	7bfb      	ldrb	r3, [r7, #15]
}
2000273c:	4618      	mov	r0, r3
2000273e:	f107 0714 	add.w	r7, r7, #20
20002742:	46bd      	mov	sp, r7
20002744:	bc80      	pop	{r7}
20002746:	4770      	bx	lr

20002748 <DMA_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void DMA_IRQHandler(void)
#else
void DMA_IRQHandler(void)
#endif
{
20002748:	4668      	mov	r0, sp
2000274a:	f020 0107 	bic.w	r1, r0, #7
2000274e:	468d      	mov	sp, r1
20002750:	b581      	push	{r0, r7, lr}
20002752:	b087      	sub	sp, #28
20002754:	af00      	add	r7, sp, #0
        (uint16_t)0x00C0, /* PDMA_CHANNEL_3 */
        (uint16_t)0x0300, /* PDMA_CHANNEL_4 */
        (uint16_t)0x0C00, /* PDMA_CHANNEL_5 */
        (uint16_t)0x3000, /* PDMA_CHANNEL_6 */
        (uint16_t)0xC000, /* PDMA_CHANNEL_7 */
    };
20002756:	f243 1394 	movw	r3, #12692	; 0x3194
2000275a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000275e:	f107 0c04 	add.w	ip, r7, #4
20002762:	cb0f      	ldmia	r3!, {r0, r1, r2, r3}
20002764:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

    status = (uint16_t)PDMA->BUFFER_STATUS;
20002768:	f243 0300 	movw	r3, #12288	; 0x3000
2000276c:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002770:	685b      	ldr	r3, [r3, #4]
20002772:	82bb      	strh	r3, [r7, #20]
    
    do {
        channel_id = get_channel_id_from_status(status);
20002774:	8abb      	ldrh	r3, [r7, #20]
20002776:	4618      	mov	r0, r3
20002778:	f7ff ff8e 	bl	20002698 <get_channel_id_from_status>
2000277c:	4603      	mov	r3, r0
2000277e:	75fb      	strb	r3, [r7, #23]
        status &= (uint16_t)~g_pdma_status_mask[channel_id];
20002780:	7dfb      	ldrb	r3, [r7, #23]
20002782:	ea4f 0343 	mov.w	r3, r3, lsl #1
20002786:	f107 0218 	add.w	r2, r7, #24
2000278a:	4413      	add	r3, r2
2000278c:	f833 3c14 	ldrh.w	r3, [r3, #-20]
20002790:	ea6f 0303 	mvn.w	r3, r3
20002794:	b29a      	uxth	r2, r3
20002796:	8abb      	ldrh	r3, [r7, #20]
20002798:	ea02 0303 	and.w	r3, r2, r3
2000279c:	82bb      	strh	r3, [r7, #20]
        if ( 0 != g_pdma_isr_table[channel_id])
2000279e:	7dfa      	ldrb	r2, [r7, #23]
200027a0:	f644 23e8 	movw	r3, #19176	; 0x4ae8
200027a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200027a8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
200027ac:	2b00      	cmp	r3, #0
200027ae:	d007      	beq.n	200027c0 <DMA_IRQHandler+0x78>
        {
            g_pdma_isr_table[channel_id]();
200027b0:	7dfa      	ldrb	r2, [r7, #23]
200027b2:	f644 23e8 	movw	r3, #19176	; 0x4ae8
200027b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200027ba:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
200027be:	4798      	blx	r3
        }
    } while(0u != status);
200027c0:	8abb      	ldrh	r3, [r7, #20]
200027c2:	2b00      	cmp	r3, #0
200027c4:	d1d6      	bne.n	20002774 <DMA_IRQHandler+0x2c>
}
200027c6:	f107 071c 	add.w	r7, r7, #28
200027ca:	46bd      	mov	sp, r7
200027cc:	e8bd 4081 	ldmia.w	sp!, {r0, r7, lr}
200027d0:	4685      	mov	sp, r0
200027d2:	4770      	bx	lr

200027d4 <PDMA_set_irq_handler>:
void PDMA_set_irq_handler
(
    pdma_channel_id_t channel_id,
    pdma_channel_isr_t handler
)
{
200027d4:	b580      	push	{r7, lr}
200027d6:	b082      	sub	sp, #8
200027d8:	af00      	add	r7, sp, #0
200027da:	4603      	mov	r3, r0
200027dc:	6039      	str	r1, [r7, #0]
200027de:	71fb      	strb	r3, [r7, #7]
    /* Save address of handler function in PDMA driver ISR lookup table. */
    g_pdma_isr_table[channel_id] = handler;
200027e0:	79fa      	ldrb	r2, [r7, #7]
200027e2:	f644 23e8 	movw	r3, #19176	; 0x4ae8
200027e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200027ea:	6839      	ldr	r1, [r7, #0]
200027ec:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    
    /* Enable PDMA channel's interrupt. */
    PDMA->CHANNEL[channel_id].CRTL |= PDMA_IRQ_ENABLE_MASK;
200027f0:	f243 0300 	movw	r3, #12288	; 0x3000
200027f4:	f2c4 0300 	movt	r3, #16384	; 0x4000
200027f8:	79f9      	ldrb	r1, [r7, #7]
200027fa:	f243 0200 	movw	r2, #12288	; 0x3000
200027fe:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002802:	79f8      	ldrb	r0, [r7, #7]
20002804:	f100 0001 	add.w	r0, r0, #1
20002808:	ea4f 1040 	mov.w	r0, r0, lsl #5
2000280c:	4402      	add	r2, r0
2000280e:	6812      	ldr	r2, [r2, #0]
20002810:	f042 0240 	orr.w	r2, r2, #64	; 0x40
20002814:	f101 0101 	add.w	r1, r1, #1
20002818:	ea4f 1141 	mov.w	r1, r1, lsl #5
2000281c:	440b      	add	r3, r1
2000281e:	601a      	str	r2, [r3, #0]
    
    /* Enable PDMA interrupt in Cortex-M3 NVIC. */
    NVIC_EnableIRQ(DMA_IRQn);
20002820:	f04f 000d 	mov.w	r0, #13
20002824:	f7ff fbee 	bl	20002004 <NVIC_EnableIRQ>
}
20002828:	f107 0708 	add.w	r7, r7, #8
2000282c:	46bd      	mov	sp, r7
2000282e:	bd80      	pop	{r7, pc}

20002830 <PDMA_enable_irq>:

/***************************************************************************//**
 * See mss_pdma.h for description of this function.
 */
void PDMA_enable_irq( pdma_channel_id_t channel_id )
{
20002830:	b580      	push	{r7, lr}
20002832:	b082      	sub	sp, #8
20002834:	af00      	add	r7, sp, #0
20002836:	4603      	mov	r3, r0
20002838:	71fb      	strb	r3, [r7, #7]
    PDMA->CHANNEL[channel_id].CRTL |= PDMA_IRQ_ENABLE_MASK;
2000283a:	f243 0300 	movw	r3, #12288	; 0x3000
2000283e:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002842:	79f9      	ldrb	r1, [r7, #7]
20002844:	f243 0200 	movw	r2, #12288	; 0x3000
20002848:	f2c4 0200 	movt	r2, #16384	; 0x4000
2000284c:	79f8      	ldrb	r0, [r7, #7]
2000284e:	f100 0001 	add.w	r0, r0, #1
20002852:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002856:	4402      	add	r2, r0
20002858:	6812      	ldr	r2, [r2, #0]
2000285a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
2000285e:	f101 0101 	add.w	r1, r1, #1
20002862:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002866:	440b      	add	r3, r1
20002868:	601a      	str	r2, [r3, #0]
    NVIC_EnableIRQ(DMA_IRQn);
2000286a:	f04f 000d 	mov.w	r0, #13
2000286e:	f7ff fbc9 	bl	20002004 <NVIC_EnableIRQ>
}
20002872:	f107 0708 	add.w	r7, r7, #8
20002876:	46bd      	mov	sp, r7
20002878:	bd80      	pop	{r7, pc}
2000287a:	bf00      	nop

2000287c <PDMA_clear_irq>:
 */
void PDMA_clear_irq
(
    pdma_channel_id_t channel_id
)
{
2000287c:	b480      	push	{r7}
2000287e:	b083      	sub	sp, #12
20002880:	af00      	add	r7, sp, #0
20002882:	4603      	mov	r3, r0
20002884:	71fb      	strb	r3, [r7, #7]
    /* Clear interrupt in PDMA controller. */
    PDMA->CHANNEL[channel_id].CRTL |= CLEAR_PORT_A_DONE_MASK;
20002886:	f243 0300 	movw	r3, #12288	; 0x3000
2000288a:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000288e:	79f9      	ldrb	r1, [r7, #7]
20002890:	f243 0200 	movw	r2, #12288	; 0x3000
20002894:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002898:	79f8      	ldrb	r0, [r7, #7]
2000289a:	f100 0001 	add.w	r0, r0, #1
2000289e:	ea4f 1040 	mov.w	r0, r0, lsl #5
200028a2:	4402      	add	r2, r0
200028a4:	6812      	ldr	r2, [r2, #0]
200028a6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
200028aa:	f101 0101 	add.w	r1, r1, #1
200028ae:	ea4f 1141 	mov.w	r1, r1, lsl #5
200028b2:	440b      	add	r3, r1
200028b4:	601a      	str	r2, [r3, #0]
    PDMA->CHANNEL[channel_id].CRTL |= CLEAR_PORT_B_DONE_MASK;
200028b6:	f243 0300 	movw	r3, #12288	; 0x3000
200028ba:	f2c4 0300 	movt	r3, #16384	; 0x4000
200028be:	79f9      	ldrb	r1, [r7, #7]
200028c0:	f243 0200 	movw	r2, #12288	; 0x3000
200028c4:	f2c4 0200 	movt	r2, #16384	; 0x4000
200028c8:	79f8      	ldrb	r0, [r7, #7]
200028ca:	f100 0001 	add.w	r0, r0, #1
200028ce:	ea4f 1040 	mov.w	r0, r0, lsl #5
200028d2:	4402      	add	r2, r0
200028d4:	6812      	ldr	r2, [r2, #0]
200028d6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
200028da:	f101 0101 	add.w	r1, r1, #1
200028de:	ea4f 1141 	mov.w	r1, r1, lsl #5
200028e2:	440b      	add	r3, r1
200028e4:	601a      	str	r2, [r3, #0]
}
200028e6:	f107 070c 	add.w	r7, r7, #12
200028ea:	46bd      	mov	sp, r7
200028ec:	bc80      	pop	{r7}
200028ee:	4770      	bx	lr

200028f0 <SystemInit>:

/***************************************************************************//**
 * See system_m2sxxx.h for details.
 */
void SystemInit(void)
{
200028f0:	b580      	push	{r7, lr}
200028f2:	af00      	add	r7, sp, #0
     */
#if (MSS_SYS_FACC_INIT_BY_CORTEX == 1)
    complete_clock_config();
#endif

    silicon_workarounds();
200028f4:	f000 f936 	bl	20002b64 <silicon_workarounds>
    /*--------------------------------------------------------------------------
     * Set STKALIGN to ensure exception stacking starts on 8 bytes address
     * boundary. This ensures compliance with the "Procedure Call Standards for
     * the ARM Architecture" (AAPCS).
     */
    SCB->CCR |= SCB_CCR_STKALIGN_Msk;
200028f8:	f64e 5300 	movw	r3, #60672	; 0xed00
200028fc:	f2ce 0300 	movt	r3, #57344	; 0xe000
20002900:	f64e 5200 	movw	r2, #60672	; 0xed00
20002904:	f2ce 0200 	movt	r2, #57344	; 0xe000
20002908:	6952      	ldr	r2, [r2, #20]
2000290a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
2000290e:	615a      	str	r2, [r3, #20]
#endif

    /*--------------------------------------------------------------------------
     * Call user defined configuration function.
     */
    mscc_post_hw_cfg_init();
20002910:	f7fd fccd 	bl	200002ae <mscc_post_hw_cfg_init>
    while(!CORE_SF2_CFG->INIT_DONE)
    {
        ;   /* Wait for INIT_DONE from CoreSF2Reset. */
    }
#endif
}
20002914:	bd80      	pop	{r7, pc}
20002916:	bf00      	nop

20002918 <SystemCoreClockUpdate>:
#define FREQ_1MHZ    1000000u
#define FREQ_25MHZ   25000000u
#define FREQ_50MHZ   50000000u

void SystemCoreClockUpdate(void)
{
20002918:	b580      	push	{r7, lr}
2000291a:	b088      	sub	sp, #32
2000291c:	af00      	add	r7, sp, #0
#if 1
    uint32_t controller_pll_init;
    uint32_t clk_src;

    controller_pll_init = SYSREG->MSSDDR_FACC1_CR & CONTROLLER_PLL_INIT_MASK;
2000291e:	f248 0300 	movw	r3, #32768	; 0x8000
20002922:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002926:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
2000292a:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
2000292e:	60fb      	str	r3, [r7, #12]
    
    if(0u == controller_pll_init)
20002930:	68fb      	ldr	r3, [r7, #12]
20002932:	2b00      	cmp	r3, #0
20002934:	f040 808b 	bne.w	20002a4e <SystemCoreClockUpdate+0x136>
    {
        /* Normal operations. */
        uint32_t global_mux_sel;
        
        global_mux_sel = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
20002938:	f248 0300 	movw	r3, #32768	; 0x8000
2000293c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002940:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20002944:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
20002948:	617b      	str	r3, [r7, #20]
        if(0u == global_mux_sel)
2000294a:	697b      	ldr	r3, [r7, #20]
2000294c:	2b00      	cmp	r3, #0
2000294e:	d13f      	bne.n	200029d0 <SystemCoreClockUpdate+0xb8>
        {
            /* MSS clocked from MSS PLL. Use Libero flow defines. */
            SystemCoreClock = MSS_SYS_M3_CLK_FREQ;
20002950:	f243 2348 	movw	r3, #12872	; 0x3248
20002954:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002958:	f24f 5280 	movw	r2, #62848	; 0xf580
2000295c:	f6c0 12e4 	movt	r2, #2532	; 0x9e4
20002960:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK0 = MSS_SYS_APB_0_CLK_FREQ;
20002962:	f243 234c 	movw	r3, #12876	; 0x324c
20002966:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000296a:	f647 22c0 	movw	r2, #31424	; 0x7ac0
2000296e:	f2c0 42f2 	movt	r2, #1266	; 0x4f2
20002972:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK1 = MSS_SYS_APB_1_CLK_FREQ;
20002974:	f243 2350 	movw	r3, #12880	; 0x3250
20002978:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000297c:	f647 22c0 	movw	r2, #31424	; 0x7ac0
20002980:	f2c0 42f2 	movt	r2, #1266	; 0x4f2
20002984:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
20002986:	f243 2354 	movw	r3, #12884	; 0x3254
2000298a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000298e:	f643 5260 	movw	r2, #15712	; 0x3d60
20002992:	f2c0 2279 	movt	r2, #633	; 0x279
20002996:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC0 = MSS_SYS_FIC_0_CLK_FREQ;
20002998:	f243 2358 	movw	r3, #12888	; 0x3258
2000299c:	f2c2 0300 	movt	r3, #8192	; 0x2000
200029a0:	f24f 5280 	movw	r2, #62848	; 0xf580
200029a4:	f6c0 12e4 	movt	r2, #2532	; 0x9e4
200029a8:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC1 = MSS_SYS_FIC_1_CLK_FREQ;
200029aa:	f243 235c 	movw	r3, #12892	; 0x325c
200029ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
200029b2:	f24f 5280 	movw	r2, #62848	; 0xf580
200029b6:	f6c0 12e4 	movt	r2, #2532	; 0x9e4
200029ba:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC64 = MSS_SYS_FIC64_CLK_FREQ;
200029bc:	f243 2360 	movw	r3, #12896	; 0x3260
200029c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200029c4:	f24f 5280 	movw	r2, #62848	; 0xf580
200029c8:	f6c0 12e4 	movt	r2, #2532	; 0x9e4
200029cc:	601a      	str	r2, [r3, #0]
                break;
                
                case CCC2ASCI_CLK_SRC:
                    /* Fall through. */
                default:
                    set_clock_frequency_globals(FREQ_1MHZ);
200029ce:	e045      	b.n	20002a5c <SystemCoreClockUpdate+0x144>
                                                   RCOSC_25_50MHZ_CLK_SRC,
                                                   CLK_XTAL_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC };
200029d0:	f243 13f4 	movw	r3, #12788	; 0x31f4
200029d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200029d8:	f107 0204 	add.w	r2, r7, #4
200029dc:	e893 0003 	ldmia.w	r3, {r0, r1}
200029e0:	e882 0003 	stmia.w	r2, {r0, r1}
            
            uint32_t standby_sel;
            uint8_t clock_source;
            
            standby_sel = (SYSREG->MSSDDR_FACC2_CR >> FACC_STANDBY_SHIFT) & FACC_STANDBY_SEL_MASK;
200029e4:	f248 0300 	movw	r3, #32768	; 0x8000
200029e8:	f2c4 0303 	movt	r3, #16387	; 0x4003
200029ec:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
200029f0:	ea4f 1393 	mov.w	r3, r3, lsr #6
200029f4:	f003 0307 	and.w	r3, r3, #7
200029f8:	61bb      	str	r3, [r7, #24]
            clock_source = standby_clock_lut[standby_sel];
200029fa:	69bb      	ldr	r3, [r7, #24]
200029fc:	f107 0220 	add.w	r2, r7, #32
20002a00:	4413      	add	r3, r2
20002a02:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
20002a06:	77fb      	strb	r3, [r7, #31]
            switch(clock_source)
20002a08:	7ffb      	ldrb	r3, [r7, #31]
20002a0a:	2b01      	cmp	r3, #1
20002a0c:	d00b      	beq.n	20002a26 <SystemCoreClockUpdate+0x10e>
20002a0e:	2b02      	cmp	r3, #2
20002a10:	d00e      	beq.n	20002a30 <SystemCoreClockUpdate+0x118>
20002a12:	2b00      	cmp	r3, #0
20002a14:	d114      	bne.n	20002a40 <SystemCoreClockUpdate+0x128>
            {
                case RCOSC_25_50MHZ_CLK_SRC:
                    clk_src = get_rcosc_25_50mhz_frequency();
20002a16:	f000 f825 	bl	20002a64 <get_rcosc_25_50mhz_frequency>
20002a1a:	4603      	mov	r3, r0
20002a1c:	613b      	str	r3, [r7, #16]
                    set_clock_frequency_globals(clk_src);
20002a1e:	6938      	ldr	r0, [r7, #16]
20002a20:	f000 f842 	bl	20002aa8 <set_clock_frequency_globals>
                break;
20002a24:	e01a      	b.n	20002a5c <SystemCoreClockUpdate+0x144>
                
                case CLK_XTAL_CLK_SRC:
                    set_clock_frequency_globals(FREQ_32KHZ);
20002a26:	f44f 4000 	mov.w	r0, #32768	; 0x8000
20002a2a:	f000 f83d 	bl	20002aa8 <set_clock_frequency_globals>
                break;
20002a2e:	e015      	b.n	20002a5c <SystemCoreClockUpdate+0x144>
                
                case RCOSC_1_MHZ_CLK_SRC:
                    set_clock_frequency_globals(FREQ_1MHZ);
20002a30:	f244 2040 	movw	r0, #16960	; 0x4240
20002a34:	f2c0 000f 	movt	r0, #15
20002a38:	f000 f836 	bl	20002aa8 <set_clock_frequency_globals>
                break;
20002a3c:	bf00      	nop
20002a3e:	e00d      	b.n	20002a5c <SystemCoreClockUpdate+0x144>
                
                case CCC2ASCI_CLK_SRC:
                    /* Fall through. */
                default:
                    set_clock_frequency_globals(FREQ_1MHZ);
20002a40:	f244 2040 	movw	r0, #16960	; 0x4240
20002a44:	f2c0 000f 	movt	r0, #15
20002a48:	f000 f82e 	bl	20002aa8 <set_clock_frequency_globals>
20002a4c:	e006      	b.n	20002a5c <SystemCoreClockUpdate+0x144>
        }
    }
    else
    {
        /* PLL initialization mode. Running from 25/50MHZ RC oscillator. */
        clk_src = get_rcosc_25_50mhz_frequency();
20002a4e:	f000 f809 	bl	20002a64 <get_rcosc_25_50mhz_frequency>
20002a52:	4603      	mov	r3, r0
20002a54:	613b      	str	r3, [r7, #16]
        set_clock_frequency_globals(clk_src);
20002a56:	6938      	ldr	r0, [r7, #16]
20002a58:	f000 f826 	bl	20002aa8 <set_clock_frequency_globals>
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
    g_FrequencyFIC0 = MSS_SYS_FIC_0_CLK_FREQ;
    g_FrequencyFIC1 = MSS_SYS_FIC_1_CLK_FREQ;
    g_FrequencyFIC64 = MSS_SYS_FIC64_CLK_FREQ;
#endif
}
20002a5c:	f107 0720 	add.w	r7, r7, #32
20002a60:	46bd      	mov	sp, r7
20002a62:	bd80      	pop	{r7, pc}

20002a64 <get_rcosc_25_50mhz_frequency>:

/***************************************************************************//**
 * Find out frequency generated by the 25_50mhz RC osciallator.
 */
static uint32_t get_rcosc_25_50mhz_frequency(void)
{
20002a64:	b480      	push	{r7}
20002a66:	b083      	sub	sp, #12
20002a68:	af00      	add	r7, sp, #0
    uint32_t rcosc_div2;
    uint32_t rcosc_frequency;
    
    rcosc_div2 = SYSREG->MSSDDR_PLL_STATUS & RCOSC_DIV2_MASK;
20002a6a:	f248 0300 	movw	r3, #32768	; 0x8000
20002a6e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002a72:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
20002a76:	f003 0304 	and.w	r3, r3, #4
20002a7a:	603b      	str	r3, [r7, #0]
    if(0u == rcosc_div2)
20002a7c:	683b      	ldr	r3, [r7, #0]
20002a7e:	2b00      	cmp	r3, #0
20002a80:	d105      	bne.n	20002a8e <get_rcosc_25_50mhz_frequency+0x2a>
    {
        /* 25_50mhz oscillator is configured for 25 MHz operations. */
        rcosc_frequency = FREQ_25MHZ;
20002a82:	f647 0340 	movw	r3, #30784	; 0x7840
20002a86:	f2c0 137d 	movt	r3, #381	; 0x17d
20002a8a:	607b      	str	r3, [r7, #4]
20002a8c:	e004      	b.n	20002a98 <get_rcosc_25_50mhz_frequency+0x34>
    }
    else
    {
        /* 25_50mhz oscillator is configured for 50 MHz operations. */
        rcosc_frequency = FREQ_50MHZ;
20002a8e:	f24f 0380 	movw	r3, #61568	; 0xf080
20002a92:	f2c0 23fa 	movt	r3, #762	; 0x2fa
20002a96:	607b      	str	r3, [r7, #4]
    }
    
    return rcosc_frequency;
20002a98:	687b      	ldr	r3, [r7, #4]
}
20002a9a:	4618      	mov	r0, r3
20002a9c:	f107 070c 	add.w	r7, r7, #12
20002aa0:	46bd      	mov	sp, r7
20002aa2:	bc80      	pop	{r7}
20002aa4:	4770      	bx	lr
20002aa6:	bf00      	nop

20002aa8 <set_clock_frequency_globals>:
        - g_FrequencyFIC0
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
20002aa8:	b480      	push	{r7}
20002aaa:	b083      	sub	sp, #12
20002aac:	af00      	add	r7, sp, #0
20002aae:	6078      	str	r0, [r7, #4]
    SystemCoreClock = standby_clk;
20002ab0:	f243 2348 	movw	r3, #12872	; 0x3248
20002ab4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002ab8:	687a      	ldr	r2, [r7, #4]
20002aba:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK0 = standby_clk;
20002abc:	f243 234c 	movw	r3, #12876	; 0x324c
20002ac0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002ac4:	687a      	ldr	r2, [r7, #4]
20002ac6:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK1 = standby_clk;
20002ac8:	f243 2350 	movw	r3, #12880	; 0x3250
20002acc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002ad0:	687a      	ldr	r2, [r7, #4]
20002ad2:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
20002ad4:	f243 2354 	movw	r3, #12884	; 0x3254
20002ad8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002adc:	f643 5260 	movw	r2, #15712	; 0x3d60
20002ae0:	f2c0 2279 	movt	r2, #633	; 0x279
20002ae4:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC0 = standby_clk;
20002ae6:	f243 2358 	movw	r3, #12888	; 0x3258
20002aea:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002aee:	687a      	ldr	r2, [r7, #4]
20002af0:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC1 = standby_clk;
20002af2:	f243 235c 	movw	r3, #12892	; 0x325c
20002af6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002afa:	687a      	ldr	r2, [r7, #4]
20002afc:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC64 = standby_clk;
20002afe:	f243 2360 	movw	r3, #12896	; 0x3260
20002b02:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002b06:	687a      	ldr	r2, [r7, #4]
20002b08:	601a      	str	r2, [r3, #0]
}
20002b0a:	f107 070c 	add.w	r7, r7, #12
20002b0e:	46bd      	mov	sp, r7
20002b10:	bc80      	pop	{r7}
20002b12:	4770      	bx	lr

20002b14 <get_silicon_revision>:

/*------------------------------------------------------------------------------
  Retrieve silicon revision from system registers.
 */
static uint32_t get_silicon_revision(void)
{
20002b14:	b480      	push	{r7}
20002b16:	b083      	sub	sp, #12
20002b18:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;
    uint32_t device_version;
    
    device_version = SYSREG->DEVICE_VERSION;
20002b1a:	f248 0300 	movw	r3, #32768	; 0x8000
20002b1e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002b22:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
20002b26:	607b      	str	r3, [r7, #4]
    switch(device_version)
20002b28:	687a      	ldr	r2, [r7, #4]
20002b2a:	f64f 0302 	movw	r3, #63490	; 0xf802
20002b2e:	429a      	cmp	r2, r3
20002b30:	d006      	beq.n	20002b40 <get_silicon_revision+0x2c>
20002b32:	f64f 0302 	movw	r3, #63490	; 0xf802
20002b36:	f2c0 0301 	movt	r3, #1
20002b3a:	429a      	cmp	r2, r3
20002b3c:	d004      	beq.n	20002b48 <get_silicon_revision+0x34>
20002b3e:	e007      	b.n	20002b50 <get_silicon_revision+0x3c>
    {
        case 0x0000F802:
            silicon_revision = M2S050_REV_A_SILICON;
20002b40:	f04f 0301 	mov.w	r3, #1
20002b44:	603b      	str	r3, [r7, #0]
            break;
20002b46:	e006      	b.n	20002b56 <get_silicon_revision+0x42>
            
        case 0x0001F802:
            silicon_revision = M2S050_REV_B_SILICON;
20002b48:	f04f 0302 	mov.w	r3, #2
20002b4c:	603b      	str	r3, [r7, #0]
            break;
20002b4e:	e002      	b.n	20002b56 <get_silicon_revision+0x42>
            
        default:
            silicon_revision = UNKNOWN_SILICON_REV;
20002b50:	f04f 0300 	mov.w	r3, #0
20002b54:	603b      	str	r3, [r7, #0]
            break;
    }
    
    return silicon_revision;
20002b56:	683b      	ldr	r3, [r7, #0]
}
20002b58:	4618      	mov	r0, r3
20002b5a:	f107 070c 	add.w	r7, r7, #12
20002b5e:	46bd      	mov	sp, r7
20002b60:	bc80      	pop	{r7}
20002b62:	4770      	bx	lr

20002b64 <silicon_workarounds>:

/*------------------------------------------------------------------------------
  Workarounds for various silicon versions.
 */
static void silicon_workarounds(void)
{
20002b64:	b580      	push	{r7, lr}
20002b66:	b082      	sub	sp, #8
20002b68:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;
    
    silicon_revision = get_silicon_revision();
20002b6a:	f7ff ffd3 	bl	20002b14 <get_silicon_revision>
20002b6e:	4603      	mov	r3, r0
20002b70:	607b      	str	r3, [r7, #4]
    
    switch(silicon_revision)
20002b72:	687b      	ldr	r3, [r7, #4]
20002b74:	2b01      	cmp	r3, #1
20002b76:	d101      	bne.n	20002b7c <silicon_workarounds+0x18>
    {
        case M2S050_REV_A_SILICON:
            m2s050_rev_a_workarounds();
20002b78:	f000 f804 	bl	20002b84 <m2s050_rev_a_workarounds>
        case UNKNOWN_SILICON_REV:
            /* Fall through. */
        default:
            break;
    }
}
20002b7c:	f107 0708 	add.w	r7, r7, #8
20002b80:	46bd      	mov	sp, r7
20002b82:	bd80      	pop	{r7, pc}

20002b84 <m2s050_rev_a_workarounds>:

/*------------------------------------------------------------------------------
  Silicon workarounds for M2S050 rev A.
 */
static void m2s050_rev_a_workarounds(void)
{
20002b84:	b480      	push	{r7}
20002b86:	af00      	add	r7, sp, #0
    /*--------------------------------------------------------------------------
     * Work around a couple of silicon issues:
     */
    /* DDR_CLK_EN <- 1 */
    SYSREG->MSSDDR_FACC1_CR |= (uint32_t)1 << DDR_CLK_EN_SHIFT;
20002b88:	f248 0300 	movw	r3, #32768	; 0x8000
20002b8c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002b90:	f248 0200 	movw	r2, #32768	; 0x8000
20002b94:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002b98:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
20002b9c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
20002ba0:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    
    /* CONTROLLER_PLL_INIT <- 0 */
    SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & ~CONTROLLER_PLL_INIT_MASK;
20002ba4:	f248 0300 	movw	r3, #32768	; 0x8000
20002ba8:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002bac:	f248 0200 	movw	r2, #32768	; 0x8000
20002bb0:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002bb4:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
20002bb8:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
20002bbc:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
}
20002bc0:	46bd      	mov	sp, r7
20002bc2:	bc80      	pop	{r7}
20002bc4:	4770      	bx	lr
20002bc6:	bf00      	nop

20002bc8 <_close>:

/*==============================================================================
 * Close a file.
 */
int _close(int file)
{
20002bc8:	b480      	push	{r7}
20002bca:	b083      	sub	sp, #12
20002bcc:	af00      	add	r7, sp, #0
20002bce:	6078      	str	r0, [r7, #4]
    return -1;
20002bd0:	f04f 33ff 	mov.w	r3, #4294967295
}
20002bd4:	4618      	mov	r0, r3
20002bd6:	f107 070c 	add.w	r7, r7, #12
20002bda:	46bd      	mov	sp, r7
20002bdc:	bc80      	pop	{r7}
20002bde:	4770      	bx	lr

20002be0 <_execve>:

/*==============================================================================
 * Transfer control to a new process.
 */
int _execve(char *name, char **argv, char **env)
{
20002be0:	b580      	push	{r7, lr}
20002be2:	b084      	sub	sp, #16
20002be4:	af00      	add	r7, sp, #0
20002be6:	60f8      	str	r0, [r7, #12]
20002be8:	60b9      	str	r1, [r7, #8]
20002bea:	607a      	str	r2, [r7, #4]
    errno = ENOMEM;
20002bec:	f000 f92e 	bl	20002e4c <__errno>
20002bf0:	4603      	mov	r3, r0
20002bf2:	f04f 020c 	mov.w	r2, #12
20002bf6:	601a      	str	r2, [r3, #0]
    return -1;
20002bf8:	f04f 33ff 	mov.w	r3, #4294967295
}
20002bfc:	4618      	mov	r0, r3
20002bfe:	f107 0710 	add.w	r7, r7, #16
20002c02:	46bd      	mov	sp, r7
20002c04:	bd80      	pop	{r7, pc}
20002c06:	bf00      	nop

20002c08 <_exit>:
{
    /* Should we force a system reset? */
    while( 1 )
    {
        ;
    }
20002c08:	b480      	push	{r7}
20002c0a:	b083      	sub	sp, #12
20002c0c:	af00      	add	r7, sp, #0
20002c0e:	6078      	str	r0, [r7, #4]
20002c10:	e7fe      	b.n	20002c10 <_exit+0x8>
20002c12:	bf00      	nop

20002c14 <_fork>:

/*==============================================================================
 * Create a new process.
 */
int _fork(void)
{
20002c14:	b580      	push	{r7, lr}
20002c16:	af00      	add	r7, sp, #0
    errno = EAGAIN;
20002c18:	f000 f918 	bl	20002e4c <__errno>
20002c1c:	4603      	mov	r3, r0
20002c1e:	f04f 020b 	mov.w	r2, #11
20002c22:	601a      	str	r2, [r3, #0]
    return -1;
20002c24:	f04f 33ff 	mov.w	r3, #4294967295
}
20002c28:	4618      	mov	r0, r3
20002c2a:	bd80      	pop	{r7, pc}

20002c2c <_fstat>:

/*==============================================================================
 * Status of an open file.
 */
int _fstat(int file, struct stat *st)
{
20002c2c:	b480      	push	{r7}
20002c2e:	b083      	sub	sp, #12
20002c30:	af00      	add	r7, sp, #0
20002c32:	6078      	str	r0, [r7, #4]
20002c34:	6039      	str	r1, [r7, #0]
    st->st_mode = S_IFCHR;
20002c36:	683b      	ldr	r3, [r7, #0]
20002c38:	f44f 5200 	mov.w	r2, #8192	; 0x2000
20002c3c:	605a      	str	r2, [r3, #4]
    return 0;
20002c3e:	f04f 0300 	mov.w	r3, #0
}
20002c42:	4618      	mov	r0, r3
20002c44:	f107 070c 	add.w	r7, r7, #12
20002c48:	46bd      	mov	sp, r7
20002c4a:	bc80      	pop	{r7}
20002c4c:	4770      	bx	lr
20002c4e:	bf00      	nop

20002c50 <_getpid>:

/*==============================================================================
 * Process-ID
 */
int _getpid(void)
{
20002c50:	b480      	push	{r7}
20002c52:	af00      	add	r7, sp, #0
    return 1;
20002c54:	f04f 0301 	mov.w	r3, #1
}
20002c58:	4618      	mov	r0, r3
20002c5a:	46bd      	mov	sp, r7
20002c5c:	bc80      	pop	{r7}
20002c5e:	4770      	bx	lr

20002c60 <_isatty>:

/*==============================================================================
 * Query whether output stream is a terminal.
 */
int _isatty(int file)
{
20002c60:	b480      	push	{r7}
20002c62:	b083      	sub	sp, #12
20002c64:	af00      	add	r7, sp, #0
20002c66:	6078      	str	r0, [r7, #4]
    return 1;
20002c68:	f04f 0301 	mov.w	r3, #1
}
20002c6c:	4618      	mov	r0, r3
20002c6e:	f107 070c 	add.w	r7, r7, #12
20002c72:	46bd      	mov	sp, r7
20002c74:	bc80      	pop	{r7}
20002c76:	4770      	bx	lr

20002c78 <_kill>:

/*==============================================================================
 * Send a signal.
 */
int _kill(int pid, int sig)
{
20002c78:	b580      	push	{r7, lr}
20002c7a:	b082      	sub	sp, #8
20002c7c:	af00      	add	r7, sp, #0
20002c7e:	6078      	str	r0, [r7, #4]
20002c80:	6039      	str	r1, [r7, #0]
    errno = EINVAL;
20002c82:	f000 f8e3 	bl	20002e4c <__errno>
20002c86:	4603      	mov	r3, r0
20002c88:	f04f 0216 	mov.w	r2, #22
20002c8c:	601a      	str	r2, [r3, #0]
    return -1;
20002c8e:	f04f 33ff 	mov.w	r3, #4294967295
}
20002c92:	4618      	mov	r0, r3
20002c94:	f107 0708 	add.w	r7, r7, #8
20002c98:	46bd      	mov	sp, r7
20002c9a:	bd80      	pop	{r7, pc}

20002c9c <_link>:

/*==============================================================================
 * Establish a new name for an existing file.
 */
int _link(char *old, char *new)
{
20002c9c:	b580      	push	{r7, lr}
20002c9e:	b082      	sub	sp, #8
20002ca0:	af00      	add	r7, sp, #0
20002ca2:	6078      	str	r0, [r7, #4]
20002ca4:	6039      	str	r1, [r7, #0]
    errno = EMLINK;
20002ca6:	f000 f8d1 	bl	20002e4c <__errno>
20002caa:	4603      	mov	r3, r0
20002cac:	f04f 021f 	mov.w	r2, #31
20002cb0:	601a      	str	r2, [r3, #0]
    return -1;
20002cb2:	f04f 33ff 	mov.w	r3, #4294967295
}
20002cb6:	4618      	mov	r0, r3
20002cb8:	f107 0708 	add.w	r7, r7, #8
20002cbc:	46bd      	mov	sp, r7
20002cbe:	bd80      	pop	{r7, pc}

20002cc0 <_lseek>:

/*==============================================================================
 * Set position in a file.
 */
int _lseek(int file, int ptr, int dir)
{
20002cc0:	b480      	push	{r7}
20002cc2:	b085      	sub	sp, #20
20002cc4:	af00      	add	r7, sp, #0
20002cc6:	60f8      	str	r0, [r7, #12]
20002cc8:	60b9      	str	r1, [r7, #8]
20002cca:	607a      	str	r2, [r7, #4]
    return 0;
20002ccc:	f04f 0300 	mov.w	r3, #0
}
20002cd0:	4618      	mov	r0, r3
20002cd2:	f107 0714 	add.w	r7, r7, #20
20002cd6:	46bd      	mov	sp, r7
20002cd8:	bc80      	pop	{r7}
20002cda:	4770      	bx	lr

20002cdc <_open>:

/*==============================================================================
 * Open a file.
 */
int _open(const char *name, int flags, int mode)
{
20002cdc:	b480      	push	{r7}
20002cde:	b085      	sub	sp, #20
20002ce0:	af00      	add	r7, sp, #0
20002ce2:	60f8      	str	r0, [r7, #12]
20002ce4:	60b9      	str	r1, [r7, #8]
20002ce6:	607a      	str	r2, [r7, #4]
    return -1;
20002ce8:	f04f 33ff 	mov.w	r3, #4294967295
}
20002cec:	4618      	mov	r0, r3
20002cee:	f107 0714 	add.w	r7, r7, #20
20002cf2:	46bd      	mov	sp, r7
20002cf4:	bc80      	pop	{r7}
20002cf6:	4770      	bx	lr

20002cf8 <_read>:

/*==============================================================================
 * Read from a file.
 */
int _read(int file, char *ptr, int len)
{
20002cf8:	b480      	push	{r7}
20002cfa:	b085      	sub	sp, #20
20002cfc:	af00      	add	r7, sp, #0
20002cfe:	60f8      	str	r0, [r7, #12]
20002d00:	60b9      	str	r1, [r7, #8]
20002d02:	607a      	str	r2, [r7, #4]
    return 0;
20002d04:	f04f 0300 	mov.w	r3, #0
}
20002d08:	4618      	mov	r0, r3
20002d0a:	f107 0714 	add.w	r7, r7, #20
20002d0e:	46bd      	mov	sp, r7
20002d10:	bc80      	pop	{r7}
20002d12:	4770      	bx	lr

20002d14 <_write_r>:
 * all files, including stdoutso if you need to generate any output, for
 * example to a serial port for debugging, you should make your minimal write
 * capable of doing this.
 */
int _write_r( void * reent, int file, char * ptr, int len )
{
20002d14:	b480      	push	{r7}
20002d16:	b085      	sub	sp, #20
20002d18:	af00      	add	r7, sp, #0
20002d1a:	60f8      	str	r0, [r7, #12]
20002d1c:	60b9      	str	r1, [r7, #8]
20002d1e:	607a      	str	r2, [r7, #4]
20002d20:	603b      	str	r3, [r7, #0]
     */
    MSS_UART_polled_tx(gp_my_uart, (uint8_t *)ptr, len);
    
    return len;
#else   /* MICROSEMI_STDIO_THRU_UART */
    return 0;
20002d22:	f04f 0300 	mov.w	r3, #0
#endif  /* MICROSEMI_STDIO_THRU_UART */
}
20002d26:	4618      	mov	r0, r3
20002d28:	f107 0714 	add.w	r7, r7, #20
20002d2c:	46bd      	mov	sp, r7
20002d2e:	bc80      	pop	{r7}
20002d30:	4770      	bx	lr
20002d32:	bf00      	nop

20002d34 <_sbrk>:
 * it is useful to have a working implementation. The following suffices for a
 * standalone system; it exploits the symbol _end automatically defined by the
 * GNU linker. 
 */
caddr_t _sbrk(int incr)
{
20002d34:	b580      	push	{r7, lr}
20002d36:	b084      	sub	sp, #16
20002d38:	af00      	add	r7, sp, #0
20002d3a:	6078      	str	r0, [r7, #4]
    extern char _end;        /* Defined by the linker */
    static char *heap_end;
    char *prev_heap_end;
    char * stack_ptr;
    
    if (heap_end == 0)
20002d3c:	f644 330c 	movw	r3, #19212	; 0x4b0c
20002d40:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d44:	681b      	ldr	r3, [r3, #0]
20002d46:	2b00      	cmp	r3, #0
20002d48:	d108      	bne.n	20002d5c <_sbrk+0x28>
    {
      heap_end = &_end;
20002d4a:	f644 330c 	movw	r3, #19212	; 0x4b0c
20002d4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d52:	f644 4218 	movw	r2, #19480	; 0x4c18
20002d56:	f2c2 0200 	movt	r2, #8192	; 0x2000
20002d5a:	601a      	str	r2, [r3, #0]
    }
    
    prev_heap_end = heap_end;
20002d5c:	f644 330c 	movw	r3, #19212	; 0x4b0c
20002d60:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d64:	681b      	ldr	r3, [r3, #0]
20002d66:	60bb      	str	r3, [r7, #8]
    asm volatile ("MRS %0, msp" : "=r" (stack_ptr) );
20002d68:	f3ef 8308 	mrs	r3, MSP
20002d6c:	60fb      	str	r3, [r7, #12]
    if (heap_end + incr > stack_ptr)
20002d6e:	f644 330c 	movw	r3, #19212	; 0x4b0c
20002d72:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d76:	681a      	ldr	r2, [r3, #0]
20002d78:	687b      	ldr	r3, [r7, #4]
20002d7a:	441a      	add	r2, r3
20002d7c:	68fb      	ldr	r3, [r7, #12]
20002d7e:	429a      	cmp	r2, r3
20002d80:	d90f      	bls.n	20002da2 <_sbrk+0x6e>
    {
      _write_r ((void *)0, 1, "Heap and stack collision\n", 25);
20002d82:	f04f 0000 	mov.w	r0, #0
20002d86:	f04f 0101 	mov.w	r1, #1
20002d8a:	f243 12fc 	movw	r2, #12796	; 0x31fc
20002d8e:	f2c2 0200 	movt	r2, #8192	; 0x2000
20002d92:	f04f 0319 	mov.w	r3, #25
20002d96:	f7ff ffbd 	bl	20002d14 <_write_r>
      _exit (1);
20002d9a:	f04f 0001 	mov.w	r0, #1
20002d9e:	f7ff ff33 	bl	20002c08 <_exit>
    }
  
    heap_end += incr;
20002da2:	f644 330c 	movw	r3, #19212	; 0x4b0c
20002da6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002daa:	681a      	ldr	r2, [r3, #0]
20002dac:	687b      	ldr	r3, [r7, #4]
20002dae:	441a      	add	r2, r3
20002db0:	f644 330c 	movw	r3, #19212	; 0x4b0c
20002db4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002db8:	601a      	str	r2, [r3, #0]
    return (caddr_t) prev_heap_end;
20002dba:	68bb      	ldr	r3, [r7, #8]
}
20002dbc:	4618      	mov	r0, r3
20002dbe:	f107 0710 	add.w	r7, r7, #16
20002dc2:	46bd      	mov	sp, r7
20002dc4:	bd80      	pop	{r7, pc}
20002dc6:	bf00      	nop

20002dc8 <_stat>:

/*==============================================================================
 * Status of a file (by name).
 */
int _stat(char *file, struct stat *st)
{
20002dc8:	b480      	push	{r7}
20002dca:	b083      	sub	sp, #12
20002dcc:	af00      	add	r7, sp, #0
20002dce:	6078      	str	r0, [r7, #4]
20002dd0:	6039      	str	r1, [r7, #0]
    st->st_mode = S_IFCHR;
20002dd2:	683b      	ldr	r3, [r7, #0]
20002dd4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
20002dd8:	605a      	str	r2, [r3, #4]
    return 0;
20002dda:	f04f 0300 	mov.w	r3, #0
}
20002dde:	4618      	mov	r0, r3
20002de0:	f107 070c 	add.w	r7, r7, #12
20002de4:	46bd      	mov	sp, r7
20002de6:	bc80      	pop	{r7}
20002de8:	4770      	bx	lr
20002dea:	bf00      	nop

20002dec <_times>:

/*==============================================================================
 * Timing information for current process.
 */
int _times(struct tms *buf)
{
20002dec:	b480      	push	{r7}
20002dee:	b083      	sub	sp, #12
20002df0:	af00      	add	r7, sp, #0
20002df2:	6078      	str	r0, [r7, #4]
    return -1;
20002df4:	f04f 33ff 	mov.w	r3, #4294967295
}
20002df8:	4618      	mov	r0, r3
20002dfa:	f107 070c 	add.w	r7, r7, #12
20002dfe:	46bd      	mov	sp, r7
20002e00:	bc80      	pop	{r7}
20002e02:	4770      	bx	lr

20002e04 <_unlink>:

/*==============================================================================
 * Remove a file's directory entry.
 */
int _unlink(char *name)
{
20002e04:	b580      	push	{r7, lr}
20002e06:	b082      	sub	sp, #8
20002e08:	af00      	add	r7, sp, #0
20002e0a:	6078      	str	r0, [r7, #4]
    errno = ENOENT;
20002e0c:	f000 f81e 	bl	20002e4c <__errno>
20002e10:	4603      	mov	r3, r0
20002e12:	f04f 0202 	mov.w	r2, #2
20002e16:	601a      	str	r2, [r3, #0]
    return -1;
20002e18:	f04f 33ff 	mov.w	r3, #4294967295
}
20002e1c:	4618      	mov	r0, r3
20002e1e:	f107 0708 	add.w	r7, r7, #8
20002e22:	46bd      	mov	sp, r7
20002e24:	bd80      	pop	{r7, pc}
20002e26:	bf00      	nop

20002e28 <_wait>:

/*==============================================================================
 * Wait for a child process.
 */
int _wait(int *status)
{
20002e28:	b580      	push	{r7, lr}
20002e2a:	b082      	sub	sp, #8
20002e2c:	af00      	add	r7, sp, #0
20002e2e:	6078      	str	r0, [r7, #4]
    errno = ECHILD;
20002e30:	f000 f80c 	bl	20002e4c <__errno>
20002e34:	4603      	mov	r3, r0
20002e36:	f04f 020a 	mov.w	r2, #10
20002e3a:	601a      	str	r2, [r3, #0]
    return -1;
20002e3c:	f04f 33ff 	mov.w	r3, #4294967295
}
20002e40:	4618      	mov	r0, r3
20002e42:	f107 0708 	add.w	r7, r7, #8
20002e46:	46bd      	mov	sp, r7
20002e48:	bd80      	pop	{r7, pc}
20002e4a:	bf00      	nop

20002e4c <__errno>:
20002e4c:	f243 2368 	movw	r3, #12904	; 0x3268
20002e50:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002e54:	6818      	ldr	r0, [r3, #0]
20002e56:	4770      	bx	lr

20002e58 <__libc_init_array>:
20002e58:	b570      	push	{r4, r5, r6, lr}
20002e5a:	f243 2638 	movw	r6, #12856	; 0x3238
20002e5e:	f243 2538 	movw	r5, #12856	; 0x3238
20002e62:	f2c2 0600 	movt	r6, #8192	; 0x2000
20002e66:	f2c2 0500 	movt	r5, #8192	; 0x2000
20002e6a:	1b76      	subs	r6, r6, r5
20002e6c:	10b6      	asrs	r6, r6, #2
20002e6e:	d006      	beq.n	20002e7e <__libc_init_array+0x26>
20002e70:	2400      	movs	r4, #0
20002e72:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
20002e76:	3401      	adds	r4, #1
20002e78:	4798      	blx	r3
20002e7a:	42a6      	cmp	r6, r4
20002e7c:	d8f9      	bhi.n	20002e72 <__libc_init_array+0x1a>
20002e7e:	f243 2538 	movw	r5, #12856	; 0x3238
20002e82:	f243 263c 	movw	r6, #12860	; 0x323c
20002e86:	f2c2 0500 	movt	r5, #8192	; 0x2000
20002e8a:	f2c2 0600 	movt	r6, #8192	; 0x2000
20002e8e:	1b76      	subs	r6, r6, r5
20002e90:	f000 f9c6 	bl	20003220 <_init>
20002e94:	10b6      	asrs	r6, r6, #2
20002e96:	d006      	beq.n	20002ea6 <__libc_init_array+0x4e>
20002e98:	2400      	movs	r4, #0
20002e9a:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
20002e9e:	3401      	adds	r4, #1
20002ea0:	4798      	blx	r3
20002ea2:	42a6      	cmp	r6, r4
20002ea4:	d8f9      	bhi.n	20002e9a <__libc_init_array+0x42>
20002ea6:	bd70      	pop	{r4, r5, r6, pc}

20002ea8 <memcpy>:
20002ea8:	2a03      	cmp	r2, #3
20002eaa:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
20002eae:	d80b      	bhi.n	20002ec8 <memcpy+0x20>
20002eb0:	b13a      	cbz	r2, 20002ec2 <memcpy+0x1a>
20002eb2:	2300      	movs	r3, #0
20002eb4:	f811 c003 	ldrb.w	ip, [r1, r3]
20002eb8:	f800 c003 	strb.w	ip, [r0, r3]
20002ebc:	3301      	adds	r3, #1
20002ebe:	4293      	cmp	r3, r2
20002ec0:	d1f8      	bne.n	20002eb4 <memcpy+0xc>
20002ec2:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
20002ec6:	4770      	bx	lr
20002ec8:	1882      	adds	r2, r0, r2
20002eca:	460c      	mov	r4, r1
20002ecc:	4603      	mov	r3, r0
20002ece:	e003      	b.n	20002ed8 <memcpy+0x30>
20002ed0:	f814 1c01 	ldrb.w	r1, [r4, #-1]
20002ed4:	f803 1c01 	strb.w	r1, [r3, #-1]
20002ed8:	f003 0603 	and.w	r6, r3, #3
20002edc:	4619      	mov	r1, r3
20002ede:	46a4      	mov	ip, r4
20002ee0:	3301      	adds	r3, #1
20002ee2:	3401      	adds	r4, #1
20002ee4:	2e00      	cmp	r6, #0
20002ee6:	d1f3      	bne.n	20002ed0 <memcpy+0x28>
20002ee8:	f01c 0403 	ands.w	r4, ip, #3
20002eec:	4663      	mov	r3, ip
20002eee:	bf08      	it	eq
20002ef0:	ebc1 0c02 	rsbeq	ip, r1, r2
20002ef4:	d068      	beq.n	20002fc8 <memcpy+0x120>
20002ef6:	4265      	negs	r5, r4
20002ef8:	f1c4 0a04 	rsb	sl, r4, #4
20002efc:	eb0c 0705 	add.w	r7, ip, r5
20002f00:	4633      	mov	r3, r6
20002f02:	ea4f 0aca 	mov.w	sl, sl, lsl #3
20002f06:	f85c 6005 	ldr.w	r6, [ip, r5]
20002f0a:	ea4f 08c4 	mov.w	r8, r4, lsl #3
20002f0e:	1a55      	subs	r5, r2, r1
20002f10:	e008      	b.n	20002f24 <memcpy+0x7c>
20002f12:	f857 4f04 	ldr.w	r4, [r7, #4]!
20002f16:	4626      	mov	r6, r4
20002f18:	fa04 f40a 	lsl.w	r4, r4, sl
20002f1c:	ea49 0404 	orr.w	r4, r9, r4
20002f20:	50cc      	str	r4, [r1, r3]
20002f22:	3304      	adds	r3, #4
20002f24:	185c      	adds	r4, r3, r1
20002f26:	2d03      	cmp	r5, #3
20002f28:	fa26 f908 	lsr.w	r9, r6, r8
20002f2c:	f1a5 0504 	sub.w	r5, r5, #4
20002f30:	eb0c 0603 	add.w	r6, ip, r3
20002f34:	dced      	bgt.n	20002f12 <memcpy+0x6a>
20002f36:	2300      	movs	r3, #0
20002f38:	e002      	b.n	20002f40 <memcpy+0x98>
20002f3a:	5cf1      	ldrb	r1, [r6, r3]
20002f3c:	54e1      	strb	r1, [r4, r3]
20002f3e:	3301      	adds	r3, #1
20002f40:	1919      	adds	r1, r3, r4
20002f42:	4291      	cmp	r1, r2
20002f44:	d3f9      	bcc.n	20002f3a <memcpy+0x92>
20002f46:	e7bc      	b.n	20002ec2 <memcpy+0x1a>
20002f48:	f853 4c40 	ldr.w	r4, [r3, #-64]
20002f4c:	f841 4c40 	str.w	r4, [r1, #-64]
20002f50:	f853 4c3c 	ldr.w	r4, [r3, #-60]
20002f54:	f841 4c3c 	str.w	r4, [r1, #-60]
20002f58:	f853 4c38 	ldr.w	r4, [r3, #-56]
20002f5c:	f841 4c38 	str.w	r4, [r1, #-56]
20002f60:	f853 4c34 	ldr.w	r4, [r3, #-52]
20002f64:	f841 4c34 	str.w	r4, [r1, #-52]
20002f68:	f853 4c30 	ldr.w	r4, [r3, #-48]
20002f6c:	f841 4c30 	str.w	r4, [r1, #-48]
20002f70:	f853 4c2c 	ldr.w	r4, [r3, #-44]
20002f74:	f841 4c2c 	str.w	r4, [r1, #-44]
20002f78:	f853 4c28 	ldr.w	r4, [r3, #-40]
20002f7c:	f841 4c28 	str.w	r4, [r1, #-40]
20002f80:	f853 4c24 	ldr.w	r4, [r3, #-36]
20002f84:	f841 4c24 	str.w	r4, [r1, #-36]
20002f88:	f853 4c20 	ldr.w	r4, [r3, #-32]
20002f8c:	f841 4c20 	str.w	r4, [r1, #-32]
20002f90:	f853 4c1c 	ldr.w	r4, [r3, #-28]
20002f94:	f841 4c1c 	str.w	r4, [r1, #-28]
20002f98:	f853 4c18 	ldr.w	r4, [r3, #-24]
20002f9c:	f841 4c18 	str.w	r4, [r1, #-24]
20002fa0:	f853 4c14 	ldr.w	r4, [r3, #-20]
20002fa4:	f841 4c14 	str.w	r4, [r1, #-20]
20002fa8:	f853 4c10 	ldr.w	r4, [r3, #-16]
20002fac:	f841 4c10 	str.w	r4, [r1, #-16]
20002fb0:	f853 4c0c 	ldr.w	r4, [r3, #-12]
20002fb4:	f841 4c0c 	str.w	r4, [r1, #-12]
20002fb8:	f853 4c08 	ldr.w	r4, [r3, #-8]
20002fbc:	f841 4c08 	str.w	r4, [r1, #-8]
20002fc0:	f853 4c04 	ldr.w	r4, [r3, #-4]
20002fc4:	f841 4c04 	str.w	r4, [r1, #-4]
20002fc8:	461c      	mov	r4, r3
20002fca:	460d      	mov	r5, r1
20002fcc:	3340      	adds	r3, #64	; 0x40
20002fce:	3140      	adds	r1, #64	; 0x40
20002fd0:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
20002fd4:	f1ac 0c40 	sub.w	ip, ip, #64	; 0x40
20002fd8:	dcb6      	bgt.n	20002f48 <memcpy+0xa0>
20002fda:	4621      	mov	r1, r4
20002fdc:	462b      	mov	r3, r5
20002fde:	1b54      	subs	r4, r2, r5
20002fe0:	e00f      	b.n	20003002 <memcpy+0x15a>
20002fe2:	f851 5c10 	ldr.w	r5, [r1, #-16]
20002fe6:	f843 5c10 	str.w	r5, [r3, #-16]
20002fea:	f851 5c0c 	ldr.w	r5, [r1, #-12]
20002fee:	f843 5c0c 	str.w	r5, [r3, #-12]
20002ff2:	f851 5c08 	ldr.w	r5, [r1, #-8]
20002ff6:	f843 5c08 	str.w	r5, [r3, #-8]
20002ffa:	f851 5c04 	ldr.w	r5, [r1, #-4]
20002ffe:	f843 5c04 	str.w	r5, [r3, #-4]
20003002:	2c0f      	cmp	r4, #15
20003004:	460d      	mov	r5, r1
20003006:	469c      	mov	ip, r3
20003008:	f101 0110 	add.w	r1, r1, #16
2000300c:	f103 0310 	add.w	r3, r3, #16
20003010:	f1a4 0410 	sub.w	r4, r4, #16
20003014:	dce5      	bgt.n	20002fe2 <memcpy+0x13a>
20003016:	ebcc 0102 	rsb	r1, ip, r2
2000301a:	2300      	movs	r3, #0
2000301c:	e003      	b.n	20003026 <memcpy+0x17e>
2000301e:	58ec      	ldr	r4, [r5, r3]
20003020:	f84c 4003 	str.w	r4, [ip, r3]
20003024:	3304      	adds	r3, #4
20003026:	195e      	adds	r6, r3, r5
20003028:	2903      	cmp	r1, #3
2000302a:	eb03 040c 	add.w	r4, r3, ip
2000302e:	f1a1 0104 	sub.w	r1, r1, #4
20003032:	dcf4      	bgt.n	2000301e <memcpy+0x176>
20003034:	e77f      	b.n	20002f36 <memcpy+0x8e>
20003036:	bf00      	nop

20003038 <memset>:
20003038:	2a03      	cmp	r2, #3
2000303a:	b2c9      	uxtb	r1, r1
2000303c:	b430      	push	{r4, r5}
2000303e:	d807      	bhi.n	20003050 <memset+0x18>
20003040:	b122      	cbz	r2, 2000304c <memset+0x14>
20003042:	2300      	movs	r3, #0
20003044:	54c1      	strb	r1, [r0, r3]
20003046:	3301      	adds	r3, #1
20003048:	4293      	cmp	r3, r2
2000304a:	d1fb      	bne.n	20003044 <memset+0xc>
2000304c:	bc30      	pop	{r4, r5}
2000304e:	4770      	bx	lr
20003050:	eb00 0c02 	add.w	ip, r0, r2
20003054:	4603      	mov	r3, r0
20003056:	e001      	b.n	2000305c <memset+0x24>
20003058:	f803 1c01 	strb.w	r1, [r3, #-1]
2000305c:	f003 0403 	and.w	r4, r3, #3
20003060:	461a      	mov	r2, r3
20003062:	3301      	adds	r3, #1
20003064:	2c00      	cmp	r4, #0
20003066:	d1f7      	bne.n	20003058 <memset+0x20>
20003068:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
2000306c:	ebc2 040c 	rsb	r4, r2, ip
20003070:	fb03 f301 	mul.w	r3, r3, r1
20003074:	e01f      	b.n	200030b6 <memset+0x7e>
20003076:	f842 3c40 	str.w	r3, [r2, #-64]
2000307a:	f842 3c3c 	str.w	r3, [r2, #-60]
2000307e:	f842 3c38 	str.w	r3, [r2, #-56]
20003082:	f842 3c34 	str.w	r3, [r2, #-52]
20003086:	f842 3c30 	str.w	r3, [r2, #-48]
2000308a:	f842 3c2c 	str.w	r3, [r2, #-44]
2000308e:	f842 3c28 	str.w	r3, [r2, #-40]
20003092:	f842 3c24 	str.w	r3, [r2, #-36]
20003096:	f842 3c20 	str.w	r3, [r2, #-32]
2000309a:	f842 3c1c 	str.w	r3, [r2, #-28]
2000309e:	f842 3c18 	str.w	r3, [r2, #-24]
200030a2:	f842 3c14 	str.w	r3, [r2, #-20]
200030a6:	f842 3c10 	str.w	r3, [r2, #-16]
200030aa:	f842 3c0c 	str.w	r3, [r2, #-12]
200030ae:	f842 3c08 	str.w	r3, [r2, #-8]
200030b2:	f842 3c04 	str.w	r3, [r2, #-4]
200030b6:	4615      	mov	r5, r2
200030b8:	3240      	adds	r2, #64	; 0x40
200030ba:	2c3f      	cmp	r4, #63	; 0x3f
200030bc:	f1a4 0440 	sub.w	r4, r4, #64	; 0x40
200030c0:	dcd9      	bgt.n	20003076 <memset+0x3e>
200030c2:	462a      	mov	r2, r5
200030c4:	ebc5 040c 	rsb	r4, r5, ip
200030c8:	e007      	b.n	200030da <memset+0xa2>
200030ca:	f842 3c10 	str.w	r3, [r2, #-16]
200030ce:	f842 3c0c 	str.w	r3, [r2, #-12]
200030d2:	f842 3c08 	str.w	r3, [r2, #-8]
200030d6:	f842 3c04 	str.w	r3, [r2, #-4]
200030da:	4615      	mov	r5, r2
200030dc:	3210      	adds	r2, #16
200030de:	2c0f      	cmp	r4, #15
200030e0:	f1a4 0410 	sub.w	r4, r4, #16
200030e4:	dcf1      	bgt.n	200030ca <memset+0x92>
200030e6:	462a      	mov	r2, r5
200030e8:	ebc5 050c 	rsb	r5, r5, ip
200030ec:	e001      	b.n	200030f2 <memset+0xba>
200030ee:	f842 3c04 	str.w	r3, [r2, #-4]
200030f2:	4614      	mov	r4, r2
200030f4:	3204      	adds	r2, #4
200030f6:	2d03      	cmp	r5, #3
200030f8:	f1a5 0504 	sub.w	r5, r5, #4
200030fc:	dcf7      	bgt.n	200030ee <memset+0xb6>
200030fe:	e001      	b.n	20003104 <memset+0xcc>
20003100:	f804 1b01 	strb.w	r1, [r4], #1
20003104:	4564      	cmp	r4, ip
20003106:	d3fb      	bcc.n	20003100 <memset+0xc8>
20003108:	e7a0      	b.n	2000304c <memset+0x14>
2000310a:	bf00      	nop

2000310c <g_m2s_serdes_0_config>:
2000310c:	a028 4002 080f 0000 9d98 4002 0030 0000     (..@.......@0...
2000311c:	9c00 4002 0080 0000 9c04 4002 0020 0000     ...@.......@ ...
2000312c:	9c08 4002 00f8 0000 9c0c 4002 0080 0000     ...@.......@....
2000313c:	9c14 4002 0029 0000 9c18 4002 0020 0000     ...@)......@ ...
2000314c:	9c24 4002 0080 0000 9c30 4002 0010 0000     $..@....0..@....
2000315c:	9c34 4002 0038 0000 9c3c 4002 0070 0000     4..@8...<..@p...
2000316c:	9dd4 4002 0002 0000 9dd8 4002 0022 0000     ...@.......@"...
2000317c:	9d98 4002 0000 0000 9e00 4002 0001 0000     ...@.......@....
2000318c:	a028 4002 0f0f 0000                         (..@....

20003194 <C.23.3634>:
20003194:	0003 000c 0030 00c0 0300 0c00 3000 c000     ....0........0..

200031a4 <C.22.3395>:
200031a4:	0001 0000 0003 0080 0001 0100 0003 0180     ................
200031b4:	0001 0200 0003 0280 0001 0300 0003 0380     ................
200031c4:	0001 0400 0003 0400 0001 0480 0003 0480     ................
200031d4:	0003 0500 0001 0580 0001 0600 0003 0600     ................
200031e4:	0001 0680 0003 0680 0001 0700 0003 0780     ................

200031f4 <C.18.3457>:
200031f4:	0100 0100 0202 0303 6548 7061 6120 646e     ........Heap and
20003204:	7320 6174 6b63 6320 6c6f 696c 6973 6e6f      stack collision
20003214:	000a 0000                                   ....

20003218 <_global_impure_ptr>:
20003218:	326c 2000 0043 0000                         l2. C...

20003220 <_init>:
20003220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20003222:	bf00      	nop
20003224:	bcf8      	pop	{r3, r4, r5, r6, r7}
20003226:	bc08      	pop	{r3}
20003228:	469e      	mov	lr, r3
2000322a:	4770      	bx	lr

2000322c <_fini>:
2000322c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000322e:	bf00      	nop
20003230:	bcf8      	pop	{r3, r4, r5, r6, r7}
20003232:	bc08      	pop	{r3}
20003234:	469e      	mov	lr, r3
20003236:	4770      	bx	lr

20003238 <__frame_dummy_init_array_entry>:
20003238:	0305 2000                                   ... 

2000323c <__do_global_dtors_aux_fini_array_entry>:
2000323c:	02f1 2000                                   ... 
